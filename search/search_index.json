{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn how to build your own Pack \u00b6 The Coda Pack SDK provides the components and tools you can use to build your own Packs. Get Started","title":"Home"},{"location":"#learn-how-to-build-your-own-pack","text":"The Coda Pack SDK provides the components and tools you can use to build your own Packs. Get Started","title":"Learn how to build your own Pack"},{"location":"support/","text":"Contact support \u00b6 TODO","title":"Support"},{"location":"support/#contact-support","text":"TODO","title":"Contact support"},{"location":"get-started/cli/","text":"Get started on your local machine \u00b6 Although it takes a little longer to get started, building Packs on your local machine has some advantages over the the web-based editor: You can use your own code editing tools, such as Visual Studio Code . You can use your own version control system, such as GitHub . You can use popular JavaScript libraries 1 , such as those in NPM . Local development is enabled through the coda command line tool (CLI). Keep reading to learn how to install the CLI and use it to build a Pack. Before you get started \u00b6 To create a Pack you will need a Coda account, with Doc Maker access in your workspace. If you're new to Coda, sign up for a free account and you'll automatically be made a Doc Maker in your personal workspace. Make sure you have node and npm available on your machine. These two tools often come bundled together, and more information on how to install them is available in the npm docs . The instructions below assume some familiarity with the terminal / command prompt. If you aren't used to using this interface consult the help material for your operating system. Set up the Pack structure \u00b6 Create a directory for your new Pack. mkdir my-pack cd my-pack Install the Pack SDK. npm install @codahq/packs-sdk The Pack SDK includes both the coda CLI as well as the libraries and type definitions needed to build Packs. Create the file structure for your Pack. npx coda init The coda init command creates the basic skeleton of a Pack based off of our template Pack . It's not required, but it's a fast way to get started. Your directory should now contain the following files: helpers.ts - A place to define helper functions used by your Pack. node_modules - The dependencies downloaded from NPM (standard for Node.js projects). pack.ts - The core Pack definition, where all of the formulas, sync tables, and other building blocks are added. package-lock.json - The versions of the dependencies downloaded from NPM (standard for Node.js projects). package.json - The project's dependencies from NPM (standard for Node.js projects). schemas.ts - A place to define the schemas (structured data types) used by your Pack. types.ts - A place to define TypeScript types for the data used by your Pack. Add code to the Pack \u00b6 Now that you've got the basic structure of a Pack it's time to add some code. In this tutorial you'll be creating a simple \"Hello World\" Pack with a single formula. Replace the contents of pack.ts with the following code, which adds a \"Hello\" formula: pack.ts /* Start making Packs! Try out the hello world sample below to create your first build. */ // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates your new Pack. export const pack = coda . newPack (); // Here, we add a new formula to this Pack. pack . addFormula ({ // This is the name that will be called in the formula builder. // Remember, your formula name cannot have spaces in it. name : \"Hello\" , description : \"A Hello World example.\" , // If your formula requires one or more inputs, you\u2019ll define them here. // Here, we're creating a string input called \u201cname\u201d. parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name you would like to say hello to.\" , }), ], // The resultType defines what will be returned in your Coda doc. Here, we're // returning a simple text string. resultType : coda.ValueType.String , // Everything inside this execute statement will happen anytime your Coda // formula is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ name ], context ) { return \"Hello \" + name + \"!\" ; }, }); Take a moment to read through the code and comments and get an understanding of how a formula is structured. Test the Pack locally \u00b6 One of the advantages of developing locally is that you can test your Pack code without having to upload it to Coda's servers. Let's test the new Hello formula you just added: npx coda execute pack.ts Hello \"world\" If everything works correctly this should output Hello world! . Upload the Pack \u00b6 So far everything you've built only exists on your local machine, and Coda has no knowledge of it. To see it working in a real doc you'll need to upload your Pack to Coda's servers. Register an API token \u00b6 The coda CLI uses the Coda API under the hood to upload your code, and likewise needs an API token to operate. Registering an API token is a one-time setup step. Register an API key for Pack uploads: npx coda register When prompted to create a new API token, type y and hit enter. This will open your browser to the API token creation dialog. In the Name field enter \"Hello World Pack\" and then click Generate API token . In the Coda API tokens section, find the token you just created, and click the Copy token link. Switch back to your terminal, paste your token into the prompt, and hit enter. This will create a new file .coda.json in your working directory that contains the API token. Don't check in .coda.json If you use a version control system you will likely want to make sure this file isn't check in, as the token within provides access to your account. For example, if using Git, add .coda.json to your .gitignore file . Create the Pack \u00b6 Now that you have the access configured you can create the new Pack on Coda's servers. This setup step that needs to be done for each Pack you create. npx coda create pack.ts --name \"Hello World\" --description \"My first Pack.\" Edit your branding later The name and description arguments are optional and can be changed later in the Pack Studio's Listing tab, along with a variety of other branding options. This will create a new, empty Pack on Coda's servers and output its URL in the Pack Studio. It stores the Pack's ID in the new file .coda-pack.json . Upload the first version \u00b6 Now that you've established access and created the empty Pack, you're finally ready to upload your code. npx coda upload pack.ts --notes \"Initial version.\" Source code not available If you open your Pack in the online Pack Studio code editor you'll see a message like: // Some boilerplate when failed to load source code This is expected, since the CLI will only upload the built Pack and not the source code. Install and use the Pack \u00b6 Your new Pack is now available to use in all your docs, and you can install it just any other Pack. Let's create a new document and install it: 1. Open Coda in your browser. 1. Click the + New doc button and select Start with a blank page . In your doc, click Explore , then Packs & import . Find your new Pack, Hello World , and click on it. This will open a dialog with more information about the Pack. Click the Install button in the upper right. Drag the Hello formula from the panel on the right into your doc. Alternative: Type the formula Place your cursor in the doc and type =Hello , and then press the tab key to select formula from your Pack. Complete the formula by passing in a name parameter, such as Hello(\"World\") , and hit enter. If everything has gone right you should see the result Hello World as the output of your formula. Tip For a more personalized message, try changing the formula to Hello(User()) . Update the Pack \u00b6 Now that you have your Pack up and running let's make a change to how it works. Back in your code editor, open pack.ts and update it to say \"Howdy\" instead of \"Hello\": formulas.ts execute : function ([ name ]) { return \"Howdy \" + name + \"!\" ; }, Run your code locally to ensure it works: npx coda execute pack.ts Hello \"world\" This should output Howdy world! . Run coda upload again to upload a new version. npx coda upload pack.ts --notes \"Changed to Howdy.\" When the upload has completed, switch back to your test document. You'll notice that the formula is still returning Hello World , and that's because formulas aren't automatically recalculated when you update your Pack code. In the Pack's panel, click the Settings tab. The Currently Installed version of the Pack should now read Version 1.0.1 . Re-opening the Pack's panel If you have navigated away from the Pack's panel, click Explore , Packs & import , and then your Pack name. Click the Refresh now button. A Syncing... indicator will appear at the top of the screen while the formulas are being refreshed. Your formula result should now be Howdy World . Tip To avoid having to hit the refresh button on every update, toggle on the setting Auto-Refresh When Version Changes . Not all libraries available on NPM are compatible with the Pack SDK. See the Using libraries guide for more information. \u21a9","title":"On your local machine"},{"location":"get-started/cli/#get-started-on-your-local-machine","text":"Although it takes a little longer to get started, building Packs on your local machine has some advantages over the the web-based editor: You can use your own code editing tools, such as Visual Studio Code . You can use your own version control system, such as GitHub . You can use popular JavaScript libraries 1 , such as those in NPM . Local development is enabled through the coda command line tool (CLI). Keep reading to learn how to install the CLI and use it to build a Pack.","title":"Get started on your local machine"},{"location":"get-started/cli/#before-you-get-started","text":"To create a Pack you will need a Coda account, with Doc Maker access in your workspace. If you're new to Coda, sign up for a free account and you'll automatically be made a Doc Maker in your personal workspace. Make sure you have node and npm available on your machine. These two tools often come bundled together, and more information on how to install them is available in the npm docs . The instructions below assume some familiarity with the terminal / command prompt. If you aren't used to using this interface consult the help material for your operating system.","title":"Before you get started"},{"location":"get-started/cli/#set-up-the-pack-structure","text":"Create a directory for your new Pack. mkdir my-pack cd my-pack Install the Pack SDK. npm install @codahq/packs-sdk The Pack SDK includes both the coda CLI as well as the libraries and type definitions needed to build Packs. Create the file structure for your Pack. npx coda init The coda init command creates the basic skeleton of a Pack based off of our template Pack . It's not required, but it's a fast way to get started. Your directory should now contain the following files: helpers.ts - A place to define helper functions used by your Pack. node_modules - The dependencies downloaded from NPM (standard for Node.js projects). pack.ts - The core Pack definition, where all of the formulas, sync tables, and other building blocks are added. package-lock.json - The versions of the dependencies downloaded from NPM (standard for Node.js projects). package.json - The project's dependencies from NPM (standard for Node.js projects). schemas.ts - A place to define the schemas (structured data types) used by your Pack. types.ts - A place to define TypeScript types for the data used by your Pack.","title":"Set up the Pack structure"},{"location":"get-started/cli/#add-code-to-the-pack","text":"Now that you've got the basic structure of a Pack it's time to add some code. In this tutorial you'll be creating a simple \"Hello World\" Pack with a single formula. Replace the contents of pack.ts with the following code, which adds a \"Hello\" formula: pack.ts /* Start making Packs! Try out the hello world sample below to create your first build. */ // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates your new Pack. export const pack = coda . newPack (); // Here, we add a new formula to this Pack. pack . addFormula ({ // This is the name that will be called in the formula builder. // Remember, your formula name cannot have spaces in it. name : \"Hello\" , description : \"A Hello World example.\" , // If your formula requires one or more inputs, you\u2019ll define them here. // Here, we're creating a string input called \u201cname\u201d. parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name you would like to say hello to.\" , }), ], // The resultType defines what will be returned in your Coda doc. Here, we're // returning a simple text string. resultType : coda.ValueType.String , // Everything inside this execute statement will happen anytime your Coda // formula is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ name ], context ) { return \"Hello \" + name + \"!\" ; }, }); Take a moment to read through the code and comments and get an understanding of how a formula is structured.","title":"Add code to the Pack"},{"location":"get-started/cli/#test-the-pack-locally","text":"One of the advantages of developing locally is that you can test your Pack code without having to upload it to Coda's servers. Let's test the new Hello formula you just added: npx coda execute pack.ts Hello \"world\" If everything works correctly this should output Hello world! .","title":"Test the Pack locally"},{"location":"get-started/cli/#upload-the-pack","text":"So far everything you've built only exists on your local machine, and Coda has no knowledge of it. To see it working in a real doc you'll need to upload your Pack to Coda's servers.","title":"Upload the Pack"},{"location":"get-started/cli/#register-an-api-token","text":"The coda CLI uses the Coda API under the hood to upload your code, and likewise needs an API token to operate. Registering an API token is a one-time setup step. Register an API key for Pack uploads: npx coda register When prompted to create a new API token, type y and hit enter. This will open your browser to the API token creation dialog. In the Name field enter \"Hello World Pack\" and then click Generate API token . In the Coda API tokens section, find the token you just created, and click the Copy token link. Switch back to your terminal, paste your token into the prompt, and hit enter. This will create a new file .coda.json in your working directory that contains the API token. Don't check in .coda.json If you use a version control system you will likely want to make sure this file isn't check in, as the token within provides access to your account. For example, if using Git, add .coda.json to your .gitignore file .","title":"Register an API token"},{"location":"get-started/cli/#create-the-pack","text":"Now that you have the access configured you can create the new Pack on Coda's servers. This setup step that needs to be done for each Pack you create. npx coda create pack.ts --name \"Hello World\" --description \"My first Pack.\" Edit your branding later The name and description arguments are optional and can be changed later in the Pack Studio's Listing tab, along with a variety of other branding options. This will create a new, empty Pack on Coda's servers and output its URL in the Pack Studio. It stores the Pack's ID in the new file .coda-pack.json .","title":"Create the Pack"},{"location":"get-started/cli/#upload-the-first-version","text":"Now that you've established access and created the empty Pack, you're finally ready to upload your code. npx coda upload pack.ts --notes \"Initial version.\" Source code not available If you open your Pack in the online Pack Studio code editor you'll see a message like: // Some boilerplate when failed to load source code This is expected, since the CLI will only upload the built Pack and not the source code.","title":"Upload the first version"},{"location":"get-started/cli/#install-and-use-the-pack","text":"Your new Pack is now available to use in all your docs, and you can install it just any other Pack. Let's create a new document and install it: 1. Open Coda in your browser. 1. Click the + New doc button and select Start with a blank page . In your doc, click Explore , then Packs & import . Find your new Pack, Hello World , and click on it. This will open a dialog with more information about the Pack. Click the Install button in the upper right. Drag the Hello formula from the panel on the right into your doc. Alternative: Type the formula Place your cursor in the doc and type =Hello , and then press the tab key to select formula from your Pack. Complete the formula by passing in a name parameter, such as Hello(\"World\") , and hit enter. If everything has gone right you should see the result Hello World as the output of your formula. Tip For a more personalized message, try changing the formula to Hello(User()) .","title":"Install and use the Pack"},{"location":"get-started/cli/#update-the-pack","text":"Now that you have your Pack up and running let's make a change to how it works. Back in your code editor, open pack.ts and update it to say \"Howdy\" instead of \"Hello\": formulas.ts execute : function ([ name ]) { return \"Howdy \" + name + \"!\" ; }, Run your code locally to ensure it works: npx coda execute pack.ts Hello \"world\" This should output Howdy world! . Run coda upload again to upload a new version. npx coda upload pack.ts --notes \"Changed to Howdy.\" When the upload has completed, switch back to your test document. You'll notice that the formula is still returning Hello World , and that's because formulas aren't automatically recalculated when you update your Pack code. In the Pack's panel, click the Settings tab. The Currently Installed version of the Pack should now read Version 1.0.1 . Re-opening the Pack's panel If you have navigated away from the Pack's panel, click Explore , Packs & import , and then your Pack name. Click the Refresh now button. A Syncing... indicator will appear at the top of the screen while the formulas are being refreshed. Your formula result should now be Howdy World . Tip To avoid having to hit the refresh button on every update, toggle on the setting Auto-Refresh When Version Changes . Not all libraries available on NPM are compatible with the Pack SDK. See the Using libraries guide for more information. \u21a9","title":"Update the Pack"},{"location":"get-started/web/","text":"Get started in the browser \u00b6 The fastest and easiest way to create a Pack is to use our web-based Pack Studio. You don't need to download any code or tools, just make sure you have: A Coda account, with Doc Maker access in your workspace. If you're new to Coda, sign up for a free account and you'll automatically be made a Doc Maker in your personal workspace. Navigate to the Pack Studio \u00b6 The Pack Studio is built right in to the Coda application. To get there: Open Coda in your browser. Click on the name of your workspace in the navigation menu on the left. Click on Packs in the header. Click the New Pack button in the upper right. You are now in the Pack Studio, ready to start building! Create a Pack from sample code \u00b6 All new Packs created in the Pack Studio start off with the basic Hello World sample code. Take a moment to read through the code and comments and get an understanding of how a Pack is structured. Next we'll use the Pack Studio to build that code and get it ready to use: Click on the Pack name Untitled Pack in the upper left, and change it to \"Hello World\". Click the Build button in the bottom left. This checks your Pack for errors and Packages it up for use in a Coda doc. It can take a few seconds for the build to complete. When the confirmation screen appears, click Create a blank test doc . Your Pack is now built and ready to use! Install and use the Pack \u00b6 Your new Pack is now available to use in all your docs, and you can install it just any other Pack. In your doc, click Explore , then Packs & import . Find your new Pack, Hello World , and click on it. This will open a dialog with more information about the Pack. Click the Install button in the upper right. Drag the Hello formula from the panel on the right into your doc. Alternative: Type the formula Place your cursor in the doc and type =Hello , and then press the tab key to select formula from your Pack. Complete the formula by passing in a name parameter, such as Hello(\"World\") , and hit enter. If everything has gone right you should see the result Hello World as the output of your formula. Tip For a more personalized message, try changing the formula to Hello(User()) . Update the Pack \u00b6 Now that you have your Pack up and running let's make a change to how it works. Back in the Pack Studio, update your code to say \"Howdy\" instead of \"Hello\": execute : function ([ name ]) { return \"Howdy \" + name + \"!\" ; }, Click the Build button again to rebuild your Pack with this change. When the Build has completed, switch back to your test document. You'll notice that the formula is still returning Hello World , and that's because formulas aren't automatically recalculated when you update your Pack code. In the Pack's panel, click the Settings tab. The Currently Installed version of the Pack should now read Version 2 . Re-opening the Pack's panel If you have navigated away from the Pack's panel, click Explore , Packs & import , and then your Pack name. Click the Refresh now button. A Syncing... indicator will appear at the top of the screen while the formulas are being refreshed. Your formula result should now be Howdy World . Tip To avoid having to hit the refresh button on every update, toggle on the setting Auto-Refresh When Version Changes .","title":"In the browser"},{"location":"get-started/web/#get-started-in-the-browser","text":"The fastest and easiest way to create a Pack is to use our web-based Pack Studio. You don't need to download any code or tools, just make sure you have: A Coda account, with Doc Maker access in your workspace. If you're new to Coda, sign up for a free account and you'll automatically be made a Doc Maker in your personal workspace.","title":"Get started in the browser"},{"location":"get-started/web/#navigate-to-the-pack-studio","text":"The Pack Studio is built right in to the Coda application. To get there: Open Coda in your browser. Click on the name of your workspace in the navigation menu on the left. Click on Packs in the header. Click the New Pack button in the upper right. You are now in the Pack Studio, ready to start building!","title":"Navigate to the Pack Studio"},{"location":"get-started/web/#create-a-pack-from-sample-code","text":"All new Packs created in the Pack Studio start off with the basic Hello World sample code. Take a moment to read through the code and comments and get an understanding of how a Pack is structured. Next we'll use the Pack Studio to build that code and get it ready to use: Click on the Pack name Untitled Pack in the upper left, and change it to \"Hello World\". Click the Build button in the bottom left. This checks your Pack for errors and Packages it up for use in a Coda doc. It can take a few seconds for the build to complete. When the confirmation screen appears, click Create a blank test doc . Your Pack is now built and ready to use!","title":"Create a Pack from sample code"},{"location":"get-started/web/#install-and-use-the-pack","text":"Your new Pack is now available to use in all your docs, and you can install it just any other Pack. In your doc, click Explore , then Packs & import . Find your new Pack, Hello World , and click on it. This will open a dialog with more information about the Pack. Click the Install button in the upper right. Drag the Hello formula from the panel on the right into your doc. Alternative: Type the formula Place your cursor in the doc and type =Hello , and then press the tab key to select formula from your Pack. Complete the formula by passing in a name parameter, such as Hello(\"World\") , and hit enter. If everything has gone right you should see the result Hello World as the output of your formula. Tip For a more personalized message, try changing the formula to Hello(User()) .","title":"Install and use the Pack"},{"location":"get-started/web/#update-the-pack","text":"Now that you have your Pack up and running let's make a change to how it works. Back in the Pack Studio, update your code to say \"Howdy\" instead of \"Hello\": execute : function ([ name ]) { return \"Howdy \" + name + \"!\" ; }, Click the Build button again to rebuild your Pack with this change. When the Build has completed, switch back to your test document. You'll notice that the formula is still returning Hello World , and that's because formulas aren't automatically recalculated when you update your Pack code. In the Pack's panel, click the Settings tab. The Currently Installed version of the Pack should now read Version 2 . Re-opening the Pack's panel If you have navigated away from the Pack's panel, click Explore , Packs & import , and then your Pack name. Click the Refresh now button. A Syncing... indicator will appear at the top of the screen while the formulas are being refreshed. Your formula result should now be Howdy World . Tip To avoid having to hit the refresh button on every update, toggle on the setting Auto-Refresh When Version Changes .","title":"Update the Pack"},{"location":"guides/troubleshooting/","text":"How to troubleshoot your code \u00b6 Logging \u00b6 See here for more information on logging.","title":"Troubleshooting"},{"location":"guides/troubleshooting/#how-to-troubleshoot-your-code","text":"","title":"How to troubleshoot your code"},{"location":"guides/troubleshooting/#logging","text":"See here for more information on logging.","title":"Logging"},{"location":"guides/advanced/authentication/","text":"Authenticating with other services \u00b6 See here for more information on how to configure authentication.","title":"Authentication"},{"location":"guides/advanced/authentication/#authenticating-with-other-services","text":"See here for more information on how to configure authentication.","title":"Authenticating with other services"},{"location":"guides/advanced/autocomplete/","text":"Autocomplete parameter options \u00b6 If you have a parameter that accepts a defined set of values it's usually best to provide those options using autocomplete. These options are presented to the user in the Coda UI and they can simply click on one instead of entering the value manually. Autocomplete can be used with String and Number parameters. View Sample Code Using autocomplete \u00b6 In the formula editor, parameter options show up in a the same pane used for the autocompletion of built-in elements of the Coda Formula Language. In the actions builder and sync table settings options are presented in a drop down. In the formula editor In the action builder In the sync table settings Simple options \u00b6 The simplest way to set this up is to set the autocomplete property of the parameter to an array of valid options. coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ \"cow\" , \"pig\" , \"sheep\" ] }) Custom labels \u00b6 If you want the options to have a different label you can provide an array of SimpleAutocompleteOption objects, each containing a display and value property. The display label will be what's shown in the list of choices, but once they select a choice it will be replaced by the value which is what is passed into your execute function. coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ { display : \"Friendly Cow\" , value : \"cow\" }, { display : \"Messy Pig\" , value : \"pig\" }, { display : \"Quiet Sheep\" , value : \"sheep\" }, ], }) The values can be either strings or numbers, and should match the type of the parameter. Dynamic options \u00b6 When the autocomplete options can't be known upfront you can instead use a function to generate them dynamically. Define an autocomplete function that returns an array of autocomplete objects, usually generated from the results of an API call. The function has access to the formula context (and fetcher) as well as the user's current input for the parameter, which you can use to filter the results. The helper function coda.autocompleteSearchObjects is useful for converting an API response into an array of SimpleAutocompleteOption objects. coda . makeParameter ({ type : coda . ParameterType . String , name : \"gameId\" , description : \"The ID of the game on boardgameatlas.com\" , autocomplete : async function ( context , search ) { let url = coda . withQueryParams ( \"https://api.boardgameatlas.com/api/search\" , { fuzzy_match : true , name : search }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); let results = response . body . games ; // Generate an array of autocomplete objects, using the game's name as the // label and it's ID for the value. return coda . autocompleteSearchObjects ( search , results , \"name\" , \"id\" ); }, }), Accessing previous parameter values \u00b6 The autocomplete function also has access to the values entered for previous parameters. Unlike in the execute function where these are passed in as an array and accessed by position, in autocomplete functions they are passed as an object of key/value pairs and accessed by name. coda . makeParameter ({ type : coda . ParameterType . String , name : \"language\" , description : \"The language to use.\" , autocomplete : [ { display : \"English\" , value : \"en\" }, { display : \"Spanish\" , value : \"es\" }, ], }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"greeting\" , description : \"The greeting to use.\" , autocomplete : async function ( context , search , { language }) { let options ; if ( language === \"es\" ) { options = [ \"Hola\" , \"Buenos d\u00edas\" ]; } else { options = [ \"Hello\" , \"Howdy\" ]; } return coda . simpleAutocomplete ( search , options ); }, }), Object destructuring In the code above we used object destructuring to pull values out of the parameters object and assign them to variables. You could alternatively do that within the body of the autocomplete function. autocomplete : async function ( context , search , parameters ) { let language = parameters . language ; // ... }, Validation \u00b6 Users are not forced to select one of the provided autocomplete options and may instead enter their own custom value. If your formula logic requires that the user only select from the autocomplete options you will need to add code to validate the parameter value. const AnimalOptions = [ \"cow\" , \"pig\" , \"sheep\" ]; pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : AnimalOptions , }), ], // ... execute : async function ([ animal ], context ) { if ( ! AnimalOptions . includes ( animal )) { throw new coda . UserVisibleError ( \"Unknown animal: \" + animal ); } } });","title":"Autocomplete"},{"location":"guides/advanced/autocomplete/#autocomplete-parameter-options","text":"If you have a parameter that accepts a defined set of values it's usually best to provide those options using autocomplete. These options are presented to the user in the Coda UI and they can simply click on one instead of entering the value manually. Autocomplete can be used with String and Number parameters. View Sample Code","title":"Autocomplete parameter options"},{"location":"guides/advanced/autocomplete/#using-autocomplete","text":"In the formula editor, parameter options show up in a the same pane used for the autocompletion of built-in elements of the Coda Formula Language. In the actions builder and sync table settings options are presented in a drop down. In the formula editor In the action builder In the sync table settings","title":"Using autocomplete"},{"location":"guides/advanced/autocomplete/#simple-options","text":"The simplest way to set this up is to set the autocomplete property of the parameter to an array of valid options. coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ \"cow\" , \"pig\" , \"sheep\" ] })","title":"Simple options"},{"location":"guides/advanced/autocomplete/#custom-labels","text":"If you want the options to have a different label you can provide an array of SimpleAutocompleteOption objects, each containing a display and value property. The display label will be what's shown in the list of choices, but once they select a choice it will be replaced by the value which is what is passed into your execute function. coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ { display : \"Friendly Cow\" , value : \"cow\" }, { display : \"Messy Pig\" , value : \"pig\" }, { display : \"Quiet Sheep\" , value : \"sheep\" }, ], }) The values can be either strings or numbers, and should match the type of the parameter.","title":"Custom labels"},{"location":"guides/advanced/autocomplete/#dynamic-options","text":"When the autocomplete options can't be known upfront you can instead use a function to generate them dynamically. Define an autocomplete function that returns an array of autocomplete objects, usually generated from the results of an API call. The function has access to the formula context (and fetcher) as well as the user's current input for the parameter, which you can use to filter the results. The helper function coda.autocompleteSearchObjects is useful for converting an API response into an array of SimpleAutocompleteOption objects. coda . makeParameter ({ type : coda . ParameterType . String , name : \"gameId\" , description : \"The ID of the game on boardgameatlas.com\" , autocomplete : async function ( context , search ) { let url = coda . withQueryParams ( \"https://api.boardgameatlas.com/api/search\" , { fuzzy_match : true , name : search }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); let results = response . body . games ; // Generate an array of autocomplete objects, using the game's name as the // label and it's ID for the value. return coda . autocompleteSearchObjects ( search , results , \"name\" , \"id\" ); }, }),","title":"Dynamic options"},{"location":"guides/advanced/autocomplete/#accessing-previous-parameter-values","text":"The autocomplete function also has access to the values entered for previous parameters. Unlike in the execute function where these are passed in as an array and accessed by position, in autocomplete functions they are passed as an object of key/value pairs and accessed by name. coda . makeParameter ({ type : coda . ParameterType . String , name : \"language\" , description : \"The language to use.\" , autocomplete : [ { display : \"English\" , value : \"en\" }, { display : \"Spanish\" , value : \"es\" }, ], }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"greeting\" , description : \"The greeting to use.\" , autocomplete : async function ( context , search , { language }) { let options ; if ( language === \"es\" ) { options = [ \"Hola\" , \"Buenos d\u00edas\" ]; } else { options = [ \"Hello\" , \"Howdy\" ]; } return coda . simpleAutocomplete ( search , options ); }, }), Object destructuring In the code above we used object destructuring to pull values out of the parameters object and assign them to variables. You could alternatively do that within the body of the autocomplete function. autocomplete : async function ( context , search , parameters ) { let language = parameters . language ; // ... },","title":"Accessing previous parameter values"},{"location":"guides/advanced/autocomplete/#validation","text":"Users are not forced to select one of the provided autocomplete options and may instead enter their own custom value. If your formula logic requires that the user only select from the autocomplete options you will need to add code to validate the parameter value. const AnimalOptions = [ \"cow\" , \"pig\" , \"sheep\" ]; pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : AnimalOptions , }), ], // ... execute : async function ([ animal ], context ) { if ( ! AnimalOptions . includes ( animal )) { throw new coda . UserVisibleError ( \"Unknown animal: \" + animal ); } } });","title":"Validation"},{"location":"guides/advanced/cli/","text":"Using the command line interface \u00b6 See here for more information on how to use the Packs CLI.","title":"Using the CLI"},{"location":"guides/advanced/cli/#using-the-command-line-interface","text":"See here for more information on how to use the Packs CLI.","title":"Using the command line interface"},{"location":"guides/advanced/fetcher/","text":"Fetching remote data \u00b6 Many Packs use cases require fetching data from an outside source such as an API, which is done using the custom Fetcher interface. Other methods for making network requests in JavaScript (such as XMLHttpRequest or libraries like axios or jQuery ) are not supported. View Sample Code Network domains \u00b6 Before you can start making any requests using the fetcher, your Pack must declare which domain names it is going to communicate with. This can be done using the addNetworkDomain() method of the pack: pack . addNetworkDomain ( \"example.com\" ); The fetcher can to communicate with URLs on that domain and all sub-domains. It's usually best select the root domain of the service you are working with. For example, if you want to make requests to api.example.com , add the network domain example.com , in case you later determine you need to access related content on images.example.com , etc. By default a Pack is only allowed to register a single domain. This is done to limit abuse potential and provide transparency to users. If your use case requires making requests to multiple domains you may request an exemption by contacting support . Accessing the fetcher \u00b6 The fetcher is made available in the execute method of a formula through the context object. This object is the second parameter of the execute method, after the array of formula parameters set by the user: pack . addFormula ({ // ... execute : async ([ foo , bar ], context ) => { let fetcher = context . fetcher ; // ... }, }); In metadata formulas, such as those that determine autocomplete choices or connection names, the context is the only parameter: coda . makeParameter ({ // ... autocomplete : async ( context ) => { let fetcher = context . fetcher ; // ... }, }), Making requests \u00b6 The fetcher has only one method, fetch , which accepts an object containing the settings of the request. The method and url fields are required, with other fields like headers and body as optional. You can see the full list of supported fields in the FetchRequest interface . context . fetcher . fetch ({ method : \"GET\" , url : \"http://www.example.com\" , }); By default the fetcher runs asynchronously, meaning that the code will continue on to the next line even if the server hasn't responded yet. You can get the fetcher to behave synchronously the using the async / await paradigm. Make sure the outer function is declared using the async keyword and then use the await keyword to tell your code to wait for the server's response before continuing on. pack . addFormula ({ // ... execute : async ([], context ) => { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"http://www.example.com\" , }); // Any following code won't run until the response is received. }, }); In parallel \u00b6 If you want to make multiple requests in parallel you can instead kick off all of your requests, wait for them all to finish, and then look at the results. This requires some understanding of Promises , but basically follows a pattern like: pack . addFormula ({ // ... execute : async ([], context ) => { let urls = [ // The URLs to fetch in parallel. ]; let requests = []; for ( let url of urls ) { // Kick off the request. let request = context . fetcher . fetch ({ method : \"GET\" , url : url , }); requests . push ( request ); } // Wait for all the requests to finish. let responses = await Promise . all ( requests ); for ( let response of responses ) { // Do something with the response. } }, }); Sending data \u00b6 Many API requests involve sending data to an external server, usually using a POST or PUT request. To do so using the fetcher, just set the method property to the desired method and pass the data you want to send in body property. You'll usually want to set a Content-Type header as well, which tells the server what format the data is in. let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , headers : { \"Content-Type\" : \"text/plain\" , }, body : \"This is some plain text.\" , }); JSON \u00b6 Sending JSON is just like sending text above, except you typically define the payload as a JavaScript object first and then convert it into a string using JSON.stringify() . In addition, you'll need to set the Content-Type header to application/json . let payload = { foo : \"bar\" , }; let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ( payload ), }); Form data \u00b6 To send data to a server that expects form input ( application/x-www-form-urlencoded ) use the form property of the request. It takes key-value pairs and automatically encodes, passes them in the body, and sets the correct Content-Type header. let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , form : { name : \"Alice\" , active : true , days : 15 , }, }); Sending attachments ( multipart/form-data ) is not supported. URL query parameters \u00b6 To send data in the URL query parameters, simply append those parameters to the URL passed to the fetcher. For example, http://www.example.com?foo=bar&thing=true . The SDK provides a helper function, coda.withQueryParams() that simplifies the process of encoding and appending query parameters to a URL. let url = coda . withQueryParams ( \"http://www.example.com\" , { foo : \"bar\" , thing : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); Binary \u00b6 Sending binary data (files, images, etc) is currently not supported by the fetcher. Working with responses \u00b6 If your request was successful it will return a FetchResponse object, which contains the status code, headers, and body of the response. Depending on the format of the response (determined by the Content-Type header) the body may already be parsed for you. Text \u00b6 Except for the special content types described below, the response body will be returned as plain text. let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://www.example.com\" , // Returns an HTML page. }); let html = response . body ; let bodyStart = html . indexOf ( '<body>' ); JSON \u00b6 Responses with the content type application/json will be automatically parsed into a JavaScript object. This allows you to start accessing the data without needing to first call JSON.parse() . let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://api.exchangerate.host/latest?format=json\" , }); let parsed = response . body ; // How you access data in the parsed JSON object depends on the contents. let rate = parsed . rates [ \"USD\" ]; XML \u00b6 Responses with the content type application/xml or text/xml will be automatically parsed into a JavaScript object, using the library xml2js . Specifically, every XML element is converted into a JavaScript object, where the keys are the name of child elements and the values are the contents of those elements. Even when an element only contains a single value it is always returned within an array. The special key $ reserved for attributes on the element. For example: Original XML <basket pending= \"true\" > <item quantity= \"1\" > <name> Bread </name> <cost> $5 </cost> </item> <item quantity= \"5\" > <name> Apple </name> <cost> $1 </cost> </item> </basket> Parsed JSON { \"$\" : { \"pending\" : \"true\" }, \"item\" : [ { \"$\" : { \"quantity\" : \"1\" }, \"name\" : [ \"Bread\" ], \"cost\" : [ \"$5\" ] }, { \"$\" : { \"quantity\" : \"5\" }, \"name\" : [ \"Apple\" ], \"cost\" : [ \"$1\" ] } ] } During development it is a good idea to log the parsed JavaScript object, so that you can more clearly understand the structure of the parsed XML. let response = await context . fetcher . fetch ({ method : \"GET\" , // Open this URL in your browser to see what the data looks like. url : \"https://api.exchangerate.host/latest?format=xml\" , }); let parsed = response . body ; // Log the parsed XML, for reference when developing. console . log ( parsed ); let usd = parsed . data . find ( item => item . code [ 0 ] === \"USD\" ) let rate = usd . rate [ 0 ]; Binary \u00b6 When fetching binary data, enable the request option isBinaryResponse to let the fetcher know that it shouldn't try to parse the server response. When binary responses are enabled the body field of the response object will contain a Node.js Buffer . let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/cat\" , // Returns a random cat image. isBinaryResponse : true , }); let buffer = response . body ; let byteLength = buffer . length ; Errors \u00b6 When a request fails (a response code of 300 or higher) the fetch will fail with a StatusCodeError exception. This exception contains useful information about the failed request, including the full response body. let response ; try { response = await context . fetcher . fetch ({ method : \"GET\" , // Open this URL in your browser to see what the data looks like. url : `https://dog.ceo/api/breed/snoopy/images` , }); } catch ( error ) { // If the request failed because of a non-200 status code. if ( error . statusCode ) { // Cast the error as a StatusCodeError, for better intellisense. let statusError = error as coda . StatusCodeError ; // If the API returned an error message in the body, show it to the user. let message = statusError . body ? . message ; if ( message ) { throw new coda . UserVisibleError ( message ); } } // The request failed for some other reason. Re-throw the error so that it // bubbles up. throw error ; } Authentication \u00b6 The authentication you configure for your Pack is automatically applied to fetcher requests, with no extra code needed. For example, if you have setup HeaderBearer authentication, an Authorization header with the user's token will be automatically added to your fetcher requests. This is only done for formulas that use a connected account: those that have a connectionRequirement of REQUIRED , or OPTIONAL and the user opted to selected an account. To disable this behavior for a specific request within a formula, set the fetch option disableAuthentication: true . let response = await context . fetcher . fetch ({ method : \"GET\" , url : `https://www.example.com` , disableAuthentication : true , // No auth will be applied to this request. }); Caching \u00b6 For performance reasons the Packs runtime caches the HTTP responses of fetcher requests, meaning that your code may not always be getting the latest response from the server. You can adjust this behavior by setting the cacheTtlSecs field in the fetch request, which specifies for how many seconds the response should be cached. To disable caching for a request set that value to zero.","title":"Fetching remote data"},{"location":"guides/advanced/fetcher/#fetching-remote-data","text":"Many Packs use cases require fetching data from an outside source such as an API, which is done using the custom Fetcher interface. Other methods for making network requests in JavaScript (such as XMLHttpRequest or libraries like axios or jQuery ) are not supported. View Sample Code","title":"Fetching remote data"},{"location":"guides/advanced/fetcher/#network-domains","text":"Before you can start making any requests using the fetcher, your Pack must declare which domain names it is going to communicate with. This can be done using the addNetworkDomain() method of the pack: pack . addNetworkDomain ( \"example.com\" ); The fetcher can to communicate with URLs on that domain and all sub-domains. It's usually best select the root domain of the service you are working with. For example, if you want to make requests to api.example.com , add the network domain example.com , in case you later determine you need to access related content on images.example.com , etc. By default a Pack is only allowed to register a single domain. This is done to limit abuse potential and provide transparency to users. If your use case requires making requests to multiple domains you may request an exemption by contacting support .","title":"Network domains"},{"location":"guides/advanced/fetcher/#accessing-the-fetcher","text":"The fetcher is made available in the execute method of a formula through the context object. This object is the second parameter of the execute method, after the array of formula parameters set by the user: pack . addFormula ({ // ... execute : async ([ foo , bar ], context ) => { let fetcher = context . fetcher ; // ... }, }); In metadata formulas, such as those that determine autocomplete choices or connection names, the context is the only parameter: coda . makeParameter ({ // ... autocomplete : async ( context ) => { let fetcher = context . fetcher ; // ... }, }),","title":"Accessing the fetcher"},{"location":"guides/advanced/fetcher/#making-requests","text":"The fetcher has only one method, fetch , which accepts an object containing the settings of the request. The method and url fields are required, with other fields like headers and body as optional. You can see the full list of supported fields in the FetchRequest interface . context . fetcher . fetch ({ method : \"GET\" , url : \"http://www.example.com\" , }); By default the fetcher runs asynchronously, meaning that the code will continue on to the next line even if the server hasn't responded yet. You can get the fetcher to behave synchronously the using the async / await paradigm. Make sure the outer function is declared using the async keyword and then use the await keyword to tell your code to wait for the server's response before continuing on. pack . addFormula ({ // ... execute : async ([], context ) => { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"http://www.example.com\" , }); // Any following code won't run until the response is received. }, });","title":"Making requests"},{"location":"guides/advanced/fetcher/#in-parallel","text":"If you want to make multiple requests in parallel you can instead kick off all of your requests, wait for them all to finish, and then look at the results. This requires some understanding of Promises , but basically follows a pattern like: pack . addFormula ({ // ... execute : async ([], context ) => { let urls = [ // The URLs to fetch in parallel. ]; let requests = []; for ( let url of urls ) { // Kick off the request. let request = context . fetcher . fetch ({ method : \"GET\" , url : url , }); requests . push ( request ); } // Wait for all the requests to finish. let responses = await Promise . all ( requests ); for ( let response of responses ) { // Do something with the response. } }, });","title":"In parallel"},{"location":"guides/advanced/fetcher/#sending-data","text":"Many API requests involve sending data to an external server, usually using a POST or PUT request. To do so using the fetcher, just set the method property to the desired method and pass the data you want to send in body property. You'll usually want to set a Content-Type header as well, which tells the server what format the data is in. let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , headers : { \"Content-Type\" : \"text/plain\" , }, body : \"This is some plain text.\" , });","title":"Sending data"},{"location":"guides/advanced/fetcher/#json","text":"Sending JSON is just like sending text above, except you typically define the payload as a JavaScript object first and then convert it into a string using JSON.stringify() . In addition, you'll need to set the Content-Type header to application/json . let payload = { foo : \"bar\" , }; let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ( payload ), });","title":"JSON"},{"location":"guides/advanced/fetcher/#form-data","text":"To send data to a server that expects form input ( application/x-www-form-urlencoded ) use the form property of the request. It takes key-value pairs and automatically encodes, passes them in the body, and sets the correct Content-Type header. let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"https://httpbin.org/post\" , form : { name : \"Alice\" , active : true , days : 15 , }, }); Sending attachments ( multipart/form-data ) is not supported.","title":"Form data"},{"location":"guides/advanced/fetcher/#url-query-parameters","text":"To send data in the URL query parameters, simply append those parameters to the URL passed to the fetcher. For example, http://www.example.com?foo=bar&thing=true . The SDK provides a helper function, coda.withQueryParams() that simplifies the process of encoding and appending query parameters to a URL. let url = coda . withQueryParams ( \"http://www.example.com\" , { foo : \"bar\" , thing : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , });","title":"URL query parameters"},{"location":"guides/advanced/fetcher/#binary","text":"Sending binary data (files, images, etc) is currently not supported by the fetcher.","title":"Binary"},{"location":"guides/advanced/fetcher/#working-with-responses","text":"If your request was successful it will return a FetchResponse object, which contains the status code, headers, and body of the response. Depending on the format of the response (determined by the Content-Type header) the body may already be parsed for you.","title":"Working with responses"},{"location":"guides/advanced/fetcher/#text","text":"Except for the special content types described below, the response body will be returned as plain text. let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://www.example.com\" , // Returns an HTML page. }); let html = response . body ; let bodyStart = html . indexOf ( '<body>' );","title":"Text"},{"location":"guides/advanced/fetcher/#json_1","text":"Responses with the content type application/json will be automatically parsed into a JavaScript object. This allows you to start accessing the data without needing to first call JSON.parse() . let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://api.exchangerate.host/latest?format=json\" , }); let parsed = response . body ; // How you access data in the parsed JSON object depends on the contents. let rate = parsed . rates [ \"USD\" ];","title":"JSON"},{"location":"guides/advanced/fetcher/#xml","text":"Responses with the content type application/xml or text/xml will be automatically parsed into a JavaScript object, using the library xml2js . Specifically, every XML element is converted into a JavaScript object, where the keys are the name of child elements and the values are the contents of those elements. Even when an element only contains a single value it is always returned within an array. The special key $ reserved for attributes on the element. For example: Original XML <basket pending= \"true\" > <item quantity= \"1\" > <name> Bread </name> <cost> $5 </cost> </item> <item quantity= \"5\" > <name> Apple </name> <cost> $1 </cost> </item> </basket> Parsed JSON { \"$\" : { \"pending\" : \"true\" }, \"item\" : [ { \"$\" : { \"quantity\" : \"1\" }, \"name\" : [ \"Bread\" ], \"cost\" : [ \"$5\" ] }, { \"$\" : { \"quantity\" : \"5\" }, \"name\" : [ \"Apple\" ], \"cost\" : [ \"$1\" ] } ] } During development it is a good idea to log the parsed JavaScript object, so that you can more clearly understand the structure of the parsed XML. let response = await context . fetcher . fetch ({ method : \"GET\" , // Open this URL in your browser to see what the data looks like. url : \"https://api.exchangerate.host/latest?format=xml\" , }); let parsed = response . body ; // Log the parsed XML, for reference when developing. console . log ( parsed ); let usd = parsed . data . find ( item => item . code [ 0 ] === \"USD\" ) let rate = usd . rate [ 0 ];","title":"XML"},{"location":"guides/advanced/fetcher/#binary_1","text":"When fetching binary data, enable the request option isBinaryResponse to let the fetcher know that it shouldn't try to parse the server response. When binary responses are enabled the body field of the response object will contain a Node.js Buffer . let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/cat\" , // Returns a random cat image. isBinaryResponse : true , }); let buffer = response . body ; let byteLength = buffer . length ;","title":"Binary"},{"location":"guides/advanced/fetcher/#errors","text":"When a request fails (a response code of 300 or higher) the fetch will fail with a StatusCodeError exception. This exception contains useful information about the failed request, including the full response body. let response ; try { response = await context . fetcher . fetch ({ method : \"GET\" , // Open this URL in your browser to see what the data looks like. url : `https://dog.ceo/api/breed/snoopy/images` , }); } catch ( error ) { // If the request failed because of a non-200 status code. if ( error . statusCode ) { // Cast the error as a StatusCodeError, for better intellisense. let statusError = error as coda . StatusCodeError ; // If the API returned an error message in the body, show it to the user. let message = statusError . body ? . message ; if ( message ) { throw new coda . UserVisibleError ( message ); } } // The request failed for some other reason. Re-throw the error so that it // bubbles up. throw error ; }","title":"Errors"},{"location":"guides/advanced/fetcher/#authentication","text":"The authentication you configure for your Pack is automatically applied to fetcher requests, with no extra code needed. For example, if you have setup HeaderBearer authentication, an Authorization header with the user's token will be automatically added to your fetcher requests. This is only done for formulas that use a connected account: those that have a connectionRequirement of REQUIRED , or OPTIONAL and the user opted to selected an account. To disable this behavior for a specific request within a formula, set the fetch option disableAuthentication: true . let response = await context . fetcher . fetch ({ method : \"GET\" , url : `https://www.example.com` , disableAuthentication : true , // No auth will be applied to this request. });","title":"Authentication"},{"location":"guides/advanced/fetcher/#caching","text":"For performance reasons the Packs runtime caches the HTTP responses of fetcher requests, meaning that your code may not always be getting the latest response from the server. You can adjust this behavior by setting the cacheTtlSecs field in the fetch request, which specifies for how many seconds the response should be cached. To disable caching for a request set that value to zero.","title":"Caching"},{"location":"guides/advanced/libraries/","text":"Using libraries \u00b6 JavaScript has a rich and diverse set of libraries available, making it easy to re-use the work of others and more quickly develop an application. You can utilize many of these libraries when building Packs, but there are some important limitations to be aware of. Only available in the CLI \u00b6 At the moment you can only add libraries to your Pack when building with the Packs command line tool (CLI). If you are using the browser-based Pack Studio and want to use a library you'll have to migrate to the CLI workflow. See the CLI getting started guide for information on how to install and setup the CLI. Use NPM \u00b6 The easiest way to install libraries is via the Node package manager (NPM). While originally created just for the Node.js environment, it's now used to distribute all sorts of JavaScript libraries. If you completed the CLI getting started guide then you should already have NPM installed. To add a library to your Pack simply use npm install to install it. For example, to install the popular JavaScript library Lodash you would run: npm install lodash You can then import this library into your code using either Node's require or the more modern import syntax: const _ = require ( 'lodash' ); // ... or ... import _ from 'lodash' ; Info How to import the library may vary; consult the library's documentation for the correct syntax. Library compatibility \u00b6 Some JavaScript libraries are written assuming the code is being run in either a web browser or on a Node.js server, and the Packs execution environment isn't exactly either. The execution environment provides access to the standard built-in JavaScript objects , but doesn't support Web APIs or Node.js APIs . These include but are not limited to: Browser: window , document , XMLHttpRequest , fetch() Node.js: fs , http , buffer 1 Both: setTimeout() 1 , setInterval() 1 Unfortunately there isn't an easy way to determine beforehand if a given library will fail due to an unavailable API. At the moment the best approach is to try the library and see if it runs successfully in the Packs environment. While many compatibility issues will be caught when the Pack is being built, there are others that are only exposed at runtime. In those cases your code will fail with an error like <function> is not defined . The code execute command runs your code in a VM with all of the same limitations in place, allowing you test compatibility without needing to upload your code to the server. Shims \u00b6 When using the CLI, browserify is used to provide shims for some Node.js modules . These shims themselves are designed to work in the browser, so not all modules that browserify supports may be supported in the Packs execution environment. Additionally, the CLI provides optional shims for some timer-related functions ( setTimeout and setInterval ). To enable these shims, pass the flag --timerStrategy=fake when executing and uploading your Pack. Note that these shims attempt to approximate the behavior of these methods, but may not work reliably. A shim exists for this feature. \u21a9 \u21a9 \u21a9","title":"Using libraries"},{"location":"guides/advanced/libraries/#using-libraries","text":"JavaScript has a rich and diverse set of libraries available, making it easy to re-use the work of others and more quickly develop an application. You can utilize many of these libraries when building Packs, but there are some important limitations to be aware of.","title":"Using libraries"},{"location":"guides/advanced/libraries/#only-available-in-the-cli","text":"At the moment you can only add libraries to your Pack when building with the Packs command line tool (CLI). If you are using the browser-based Pack Studio and want to use a library you'll have to migrate to the CLI workflow. See the CLI getting started guide for information on how to install and setup the CLI.","title":"Only available in the CLI"},{"location":"guides/advanced/libraries/#use-npm","text":"The easiest way to install libraries is via the Node package manager (NPM). While originally created just for the Node.js environment, it's now used to distribute all sorts of JavaScript libraries. If you completed the CLI getting started guide then you should already have NPM installed. To add a library to your Pack simply use npm install to install it. For example, to install the popular JavaScript library Lodash you would run: npm install lodash You can then import this library into your code using either Node's require or the more modern import syntax: const _ = require ( 'lodash' ); // ... or ... import _ from 'lodash' ; Info How to import the library may vary; consult the library's documentation for the correct syntax.","title":"Use NPM"},{"location":"guides/advanced/libraries/#library-compatibility","text":"Some JavaScript libraries are written assuming the code is being run in either a web browser or on a Node.js server, and the Packs execution environment isn't exactly either. The execution environment provides access to the standard built-in JavaScript objects , but doesn't support Web APIs or Node.js APIs . These include but are not limited to: Browser: window , document , XMLHttpRequest , fetch() Node.js: fs , http , buffer 1 Both: setTimeout() 1 , setInterval() 1 Unfortunately there isn't an easy way to determine beforehand if a given library will fail due to an unavailable API. At the moment the best approach is to try the library and see if it runs successfully in the Packs environment. While many compatibility issues will be caught when the Pack is being built, there are others that are only exposed at runtime. In those cases your code will fail with an error like <function> is not defined . The code execute command runs your code in a VM with all of the same limitations in place, allowing you test compatibility without needing to upload your code to the server.","title":"Library compatibility"},{"location":"guides/advanced/libraries/#shims","text":"When using the CLI, browserify is used to provide shims for some Node.js modules . These shims themselves are designed to work in the browser, so not all modules that browserify supports may be supported in the Packs execution environment. Additionally, the CLI provides optional shims for some timer-related functions ( setTimeout and setInterval ). To enable these shims, pass the flag --timerStrategy=fake when executing and uploading your Pack. Note that these shims attempt to approximate the behavior of these methods, but may not work reliably. A shim exists for this feature. \u21a9 \u21a9 \u21a9","title":"Shims"},{"location":"guides/advanced/schemas/","text":"Structuring data with schemas \u00b6 See here for more information on how to define schemas.","title":"Schemas"},{"location":"guides/advanced/schemas/#structuring-data-with-schemas","text":"See here for more information on how to define schemas.","title":"Structuring data with schemas"},{"location":"guides/basics/data-types/","text":"Return data with meaningful types \u00b6 See here for more information on how to type hints.","title":"Data types"},{"location":"guides/basics/data-types/#return-data-with-meaningful-types","text":"See here for more information on how to type hints.","title":"Return data with meaningful types"},{"location":"guides/basics/parameters/","text":"Accept input with parameters \u00b6 The primary mechanism for passing data from the user or document into your Pack is via parameters. You define the parameters in your code and the user fills them with values when they use your Pack. The same parameter mechanism is used by formulas, actions, and sync tables. View Sample Code Using parameters \u00b6 In the formula editor parameters are entered as comma-separated values, while in the action dialog or sync table side panel they presented as input boxes. In the formula editor In the action builder In the sync table settings Defining parameters \u00b6 The parameters property of a formula contains the array of parameter definitions, each one containing information about the parameter. The helper function makeParameter() is used to create these definitions, and a type , name , and description are required. coda . makeParameter ({ type : coda . ParameterType . String , name : \"type\" , description : \"The type of cookie.\" , }) See ParamDef for the full set of properties you can define for a parameter. Accessing parameter values \u00b6 At runtime, the values set by the user are passed to the formula's execute function as the first argument, bundled up as an array. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"type\" , description : \"The type of cookie.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"num\" , description : \"How many cookies.\" , }), ], // ... execute : async function ([ type , num ], context ) { // ... }, }); The order that you define the parameters determines the order they are passed into the execute function. The names of the parameters don't need to match the variable names you use for them in the execute function, but it's usually more readable to keep them the same. Array destructuring In the code above, and across our other samples, we typically use array destructuring to pull values out of the parameter array and assign them to variables. You could alternatively do that within the body of the execute function: execute : async function ( parameters , context ) { let word = parameters [ 0 ]; let count = parameters [ 1 ]; }, Optional parameters \u00b6 By default all parameters you define are required. To make a parameter optional simply add optional: true to your parameter definition. Optional parameters are shown to the user but not required in order for the formula to execute. Optional parameters must be defined after all of the required parameters, and like required parameters their order is reflected in the Coda formula editor and the array of values passed to the execute function. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The person's name.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"suffix\" , description : \"A suffix, like 'MD' or 'Jr'.\" , optional : true , }), ], // ... execute : async function ([ name , suffix ], context ) { // ... }, }); Optional parameters that have not been set by the user will default to the JavaScript value undefined in your execute function. When you initialize your parameter variables in the execute function you can assign a default value that will get used when the parameter has not been explicitly set by the user. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\". pack . addFormula ({ name : \"Scream\" , description : \"Make text uppercase and add exclamation points.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"The text to scream.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"volume\" , description : \"The number of exclamation points to add.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"character\" , description : \"The character to repeat.\" , optional : true , }), ], resultType : coda.ValueType.String , execute : async function ([ text , volume = 3 , character = \"!\" ], context ) { return text . toUpperCase () + character . repeat ( volume ); }, }); When using a formula with optional parameters, the user may choose to set those parameters by name, instead of by position. This can be useful when they want to skip over some optional parameters that appear earlier in the list. Scream ( \"What is this\" , character : \"?\" ) In this case the text and character parameters would be set, but the volume parameter would be undefined, and therefore use it's default value of 3 . Suggested values \u00b6 As a convenience to users of your Pack, you can provide a suggested value for a parameter. When they use your formula the default will be pre-populated in the formula editor, action dialog, etc. The user is then free to edit or replace it this value. To add a suggested value to a parameter set the field defaultValue to the value you'd like to use. The suggested value must be of the same type as the parameter, for example a number parameter must have a number as it's suggested default value. coda . makeParameter ({ type : coda . ParameterType . Number , name : \"days\" , description : \"How many days of data to fetch.\" , defaultValue : 30 , }) Currently suggested values are only used for required parameters, and setting them for optional parameters has no effect. Accepting multiple values \u00b6 For some formulas you may want to allow the user to enter multiple values for a parameter. You could use an array parameter for this case but a more user-friendly approach may be to use variable argument (vararg) parameters. These are parameters that you allow the user to repeat as many times as needed. Foo(List(\"A\", \"B\", \"C\")) # A string array parameter. Foo(\"A\", \"B\", \"C\") # A string variable argument parameter. They are defined using the varargParameters property and accept the same parameter objects. The values set by the user are passed in to the execute just like normal parameters, only there is an unknown number of them. The easiest way to access them is by using JavaScript's \"rest\" syntax , which captures the remaining values into an array. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The person's name.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"nickname\" , description : \"A nickname for the person.\" , }), ], // ... execute : async function ([ name , ... nicknames ], context ) { // ... }, }); There are some important differences between vararg parameters and standard parameters: They appear at the end of the formula, after all standard parameters. Unlike standard parameters they are optional by default, and cannot by made required. You can't provide a default value, since the user must always enter an explicit value. You can have more than one, but if so the user is required to enter complete sets of values. For example, if you have two vararg parameters a and b , the user can't provide a value for a without also providing a value for b . These pairs of parameters can then be repeated multiple times: Foo(\"a1\", \"b1\", \"a2\", \"b2\") . import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Takes an unknown number of steps and labels and outputs a simple diagram. // Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\") // Result: Idea --Experiment--> Prototype --Refine--> Product pack . addFormula ({ name : \"Steps\" , description : \"Draws a simple step diagram using text.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"start\" , description : \"The starting step.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"label\" , description : \"The label for the arrow.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"step\" , description : \"The next step.\" , }), ], resultType : coda.ValueType.String , execute : async function ([ start , ... varargs ], context ) { let result = start ; while ( varargs . length > 0 ) { let label ; let step ; // Pull the first set of varargs off the list, and leave the rest. [ label , step , ... varargs ] = varargs ; result += ` -- ${ label } --> ${ step } ` ; } return result ; }, }); Autocomplete \u00b6 If you have a parameter that accepts a limited set of values it's usually best to provide those options using autocomplete. See the Autocomplete guide for more information. Reusing parameters \u00b6 It's often the case that many formulas in a Pack use the same parameter. For example, the Google Calendar Pack has many formulas have a parameter for the calendar to operate on. Rather than redefine the same parameter for each formula, it can be more efficient to define the shared parameter once outside of a formula and then reuse it multiple times. const ProjectParam = coda . makeParameter ({ type : coda . ParameterType . String , name : \"projectId\" , description : \"The ID of the project.\" , }); pack . addFormula ({ name : \"GetProject\" , description : \"Get a project.\" , parameters : [ ProjectParam , ], // ... }); pack . addFormula ({ name : \"GetTask\" , description : \"Get a task within a project.\" , parameters : [ ProjectParam , coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task.\" , }), ], // ... }); Date range parameters \u00b6 Parameters of the type DateArray are often used for date ranges, with the first date representing the start of the range and the second date representing the end. When a DateArray parameter is used in an action or sync table the the input box displays a date range picker to make it easier for the user to select a range. These parameters also support a special set of suggested values that represent date ranges relative to the current date. These are available in the PrecannedDateRange enumeration. coda . makeParameter ({ type : coda . ParameterType . DateArray , name : \"dateRange\" , description : \"The date range over which data should be fetched.\" , defaultValue : coda.PrecannedDateRange.Last30Days , })","title":"Parameters"},{"location":"guides/basics/parameters/#accept-input-with-parameters","text":"The primary mechanism for passing data from the user or document into your Pack is via parameters. You define the parameters in your code and the user fills them with values when they use your Pack. The same parameter mechanism is used by formulas, actions, and sync tables. View Sample Code","title":"Accept input with parameters"},{"location":"guides/basics/parameters/#using-parameters","text":"In the formula editor parameters are entered as comma-separated values, while in the action dialog or sync table side panel they presented as input boxes. In the formula editor In the action builder In the sync table settings","title":"Using parameters"},{"location":"guides/basics/parameters/#defining-parameters","text":"The parameters property of a formula contains the array of parameter definitions, each one containing information about the parameter. The helper function makeParameter() is used to create these definitions, and a type , name , and description are required. coda . makeParameter ({ type : coda . ParameterType . String , name : \"type\" , description : \"The type of cookie.\" , }) See ParamDef for the full set of properties you can define for a parameter.","title":"Defining parameters"},{"location":"guides/basics/parameters/#accessing-parameter-values","text":"At runtime, the values set by the user are passed to the formula's execute function as the first argument, bundled up as an array. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"type\" , description : \"The type of cookie.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"num\" , description : \"How many cookies.\" , }), ], // ... execute : async function ([ type , num ], context ) { // ... }, }); The order that you define the parameters determines the order they are passed into the execute function. The names of the parameters don't need to match the variable names you use for them in the execute function, but it's usually more readable to keep them the same. Array destructuring In the code above, and across our other samples, we typically use array destructuring to pull values out of the parameter array and assign them to variables. You could alternatively do that within the body of the execute function: execute : async function ( parameters , context ) { let word = parameters [ 0 ]; let count = parameters [ 1 ]; },","title":"Accessing parameter values"},{"location":"guides/basics/parameters/#optional-parameters","text":"By default all parameters you define are required. To make a parameter optional simply add optional: true to your parameter definition. Optional parameters are shown to the user but not required in order for the formula to execute. Optional parameters must be defined after all of the required parameters, and like required parameters their order is reflected in the Coda formula editor and the array of values passed to the execute function. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The person's name.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"suffix\" , description : \"A suffix, like 'MD' or 'Jr'.\" , optional : true , }), ], // ... execute : async function ([ name , suffix ], context ) { // ... }, }); Optional parameters that have not been set by the user will default to the JavaScript value undefined in your execute function. When you initialize your parameter variables in the execute function you can assign a default value that will get used when the parameter has not been explicitly set by the user. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\". pack . addFormula ({ name : \"Scream\" , description : \"Make text uppercase and add exclamation points.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"The text to scream.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"volume\" , description : \"The number of exclamation points to add.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"character\" , description : \"The character to repeat.\" , optional : true , }), ], resultType : coda.ValueType.String , execute : async function ([ text , volume = 3 , character = \"!\" ], context ) { return text . toUpperCase () + character . repeat ( volume ); }, }); When using a formula with optional parameters, the user may choose to set those parameters by name, instead of by position. This can be useful when they want to skip over some optional parameters that appear earlier in the list. Scream ( \"What is this\" , character : \"?\" ) In this case the text and character parameters would be set, but the volume parameter would be undefined, and therefore use it's default value of 3 .","title":"Optional parameters"},{"location":"guides/basics/parameters/#suggested-values","text":"As a convenience to users of your Pack, you can provide a suggested value for a parameter. When they use your formula the default will be pre-populated in the formula editor, action dialog, etc. The user is then free to edit or replace it this value. To add a suggested value to a parameter set the field defaultValue to the value you'd like to use. The suggested value must be of the same type as the parameter, for example a number parameter must have a number as it's suggested default value. coda . makeParameter ({ type : coda . ParameterType . Number , name : \"days\" , description : \"How many days of data to fetch.\" , defaultValue : 30 , }) Currently suggested values are only used for required parameters, and setting them for optional parameters has no effect.","title":"Suggested values"},{"location":"guides/basics/parameters/#accepting-multiple-values","text":"For some formulas you may want to allow the user to enter multiple values for a parameter. You could use an array parameter for this case but a more user-friendly approach may be to use variable argument (vararg) parameters. These are parameters that you allow the user to repeat as many times as needed. Foo(List(\"A\", \"B\", \"C\")) # A string array parameter. Foo(\"A\", \"B\", \"C\") # A string variable argument parameter. They are defined using the varargParameters property and accept the same parameter objects. The values set by the user are passed in to the execute just like normal parameters, only there is an unknown number of them. The easiest way to access them is by using JavaScript's \"rest\" syntax , which captures the remaining values into an array. pack . addFormula ({ // ... parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The person's name.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"nickname\" , description : \"A nickname for the person.\" , }), ], // ... execute : async function ([ name , ... nicknames ], context ) { // ... }, }); There are some important differences between vararg parameters and standard parameters: They appear at the end of the formula, after all standard parameters. Unlike standard parameters they are optional by default, and cannot by made required. You can't provide a default value, since the user must always enter an explicit value. You can have more than one, but if so the user is required to enter complete sets of values. For example, if you have two vararg parameters a and b , the user can't provide a value for a without also providing a value for b . These pairs of parameters can then be repeated multiple times: Foo(\"a1\", \"b1\", \"a2\", \"b2\") . import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Takes an unknown number of steps and labels and outputs a simple diagram. // Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\") // Result: Idea --Experiment--> Prototype --Refine--> Product pack . addFormula ({ name : \"Steps\" , description : \"Draws a simple step diagram using text.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"start\" , description : \"The starting step.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"label\" , description : \"The label for the arrow.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"step\" , description : \"The next step.\" , }), ], resultType : coda.ValueType.String , execute : async function ([ start , ... varargs ], context ) { let result = start ; while ( varargs . length > 0 ) { let label ; let step ; // Pull the first set of varargs off the list, and leave the rest. [ label , step , ... varargs ] = varargs ; result += ` -- ${ label } --> ${ step } ` ; } return result ; }, });","title":"Accepting multiple values"},{"location":"guides/basics/parameters/#autocomplete","text":"If you have a parameter that accepts a limited set of values it's usually best to provide those options using autocomplete. See the Autocomplete guide for more information.","title":"Autocomplete"},{"location":"guides/basics/parameters/#reusing-parameters","text":"It's often the case that many formulas in a Pack use the same parameter. For example, the Google Calendar Pack has many formulas have a parameter for the calendar to operate on. Rather than redefine the same parameter for each formula, it can be more efficient to define the shared parameter once outside of a formula and then reuse it multiple times. const ProjectParam = coda . makeParameter ({ type : coda . ParameterType . String , name : \"projectId\" , description : \"The ID of the project.\" , }); pack . addFormula ({ name : \"GetProject\" , description : \"Get a project.\" , parameters : [ ProjectParam , ], // ... }); pack . addFormula ({ name : \"GetTask\" , description : \"Get a task within a project.\" , parameters : [ ProjectParam , coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task.\" , }), ], // ... });","title":"Reusing parameters"},{"location":"guides/basics/parameters/#date-range-parameters","text":"Parameters of the type DateArray are often used for date ranges, with the first date representing the start of the range and the second date representing the end. When a DateArray parameter is used in an action or sync table the the input box displays a date range picker to make it easier for the user to select a range. These parameters also support a special set of suggested values that represent date ranges relative to the current date. These are available in the PrecannedDateRange enumeration. coda . makeParameter ({ type : coda . ParameterType . DateArray , name : \"dateRange\" , description : \"The date range over which data should be fetched.\" , defaultValue : coda.PrecannedDateRange.Last30Days , })","title":"Date range parameters"},{"location":"guides/blocks/actions/","text":"Add custom actions \u00b6 TODO","title":"Actions"},{"location":"guides/blocks/actions/#add-custom-actions","text":"TODO","title":"Add custom actions"},{"location":"guides/blocks/formulas/","text":"Add custom formulas \u00b6 Formulas are one of the most basic building blocks in Coda; used to calculate values, filter tables, and so much more. Coda provides a wide array of built-in formulas , and using Packs you can add your own custom formulas. Once your Pack is installed in a doc you can use those custom formulas anywhere, intermingling them with built-in formulas or those from other Packs. View Sample Code Structure of a formula \u00b6 TODO Naming \u00b6 The name of a formula can only contain the letters, numbers, and underscores. This restriction exists to ensure that custom formulas are compatible with the Coda Formula Language. By convention formula names are written in upper camel case, like DoSomethingCool . Formula names must be unique within a Pack, but can be the same as built-in formulas or those in other Packs. When a doc has access to multiple formulas with the same name the Pack's icon is used to distinguish them. Parameters \u00b6 Formulas can accept parameters, which is the primary way for them to access data from the document. See the Parameters guide for more information and examples. Results \u00b6 TODO Caching \u00b6 TODO Recalculation \u00b6 TODO","title":"Formulas"},{"location":"guides/blocks/formulas/#add-custom-formulas","text":"Formulas are one of the most basic building blocks in Coda; used to calculate values, filter tables, and so much more. Coda provides a wide array of built-in formulas , and using Packs you can add your own custom formulas. Once your Pack is installed in a doc you can use those custom formulas anywhere, intermingling them with built-in formulas or those from other Packs. View Sample Code","title":"Add custom formulas"},{"location":"guides/blocks/formulas/#structure-of-a-formula","text":"TODO","title":"Structure of a formula"},{"location":"guides/blocks/formulas/#naming","text":"The name of a formula can only contain the letters, numbers, and underscores. This restriction exists to ensure that custom formulas are compatible with the Coda Formula Language. By convention formula names are written in upper camel case, like DoSomethingCool . Formula names must be unique within a Pack, but can be the same as built-in formulas or those in other Packs. When a doc has access to multiple formulas with the same name the Pack's icon is used to distinguish them.","title":"Naming"},{"location":"guides/blocks/formulas/#parameters","text":"Formulas can accept parameters, which is the primary way for them to access data from the document. See the Parameters guide for more information and examples.","title":"Parameters"},{"location":"guides/blocks/formulas/#results","text":"TODO","title":"Results"},{"location":"guides/blocks/formulas/#caching","text":"TODO","title":"Caching"},{"location":"guides/blocks/formulas/#recalculation","text":"TODO","title":"Recalculation"},{"location":"guides/blocks/sync-tables/","text":"Add custom sync tables \u00b6 See here for more information on how to build sync tables.","title":"Sync tables"},{"location":"guides/blocks/sync-tables/#add-custom-sync-tables","text":"See here for more information on how to build sync tables.","title":"Add custom sync tables"},{"location":"reference/sdk/","text":"@codahq/packs-sdk \u00b6 Enumerations \u00b6 AttributionNodeType AuthenticationType ConnectionRequirement CurrencyFormat DefaultConnectionType DurationUnit NetworkConnection ParameterType PostSetupType PrecannedDateRange ScaleIconSet Type ValueHintType ValueType Classes \u00b6 PackDefinitionBuilder StatusCodeError UserVisibleError Interfaces \u00b6 ArraySchema ArrayType BooleanSchema Continuation CurrencySchema DurationSchema DynamicSyncTableDef EmptyFormulaDef ExecutionContext ExternalPackVersionMetadata FetchRequest FetchResponse Fetcher Format Identity IdentityDefinition MetadataFormulaObjectResultType Network NumericDateSchema NumericDateTimeSchema NumericSchema NumericTimeSchema OAuth2Authentication ObjectSchema ObjectSchemaProperty PackDefinition PackFormatMetadata PackFormulaDef PackFormulas PackFormulasMetadata PackVersionDefinition ParamDef ScaleSchema SimpleAutocompleteOption SimpleStringSchema SliderSchema StringDateSchema StringDateTimeSchema StringTimeSchema SyncExecutionContext SyncFormulaResult SyncTableDef TemporaryBlobStorage WebBasicAuthentication Type aliases \u00b6 Authentication BasicPackDefinition DefaultValueType ExternalObjectPackFormula ExternalPackFormat ExternalPackFormatMetadata ExternalPackFormula ExternalPackFormulas ExternalPackMetadata ExternalSyncTable FetchMethodType Formula GenericDynamicSyncTable GenericObjectSchema GenericSyncFormula GenericSyncFormulaResult GenericSyncTable MetadataContext MetadataFormula MetadataFormulaResultType NumberSchema ObjectSchemaProperties PackFormulaMetadata PackFormulaResult PackFormulaValue PackId PackMetadata PackSyncTable PackVersionMetadata ParamDefs ParamValues ParamsList Schema SchemaType StringSchema SystemAuthentication TypedPackFormula Functions \u00b6 assertCondition autocompleteSearchObjects ensureExists ensureNonEmptyString ensureUnreachable generateSchema getQueryParams joinUrl makeAttributionNode makeDynamicSyncTable makeEmptyFormula makeFormula makeMetadataFormula makeObjectSchema makeParameter makeReferenceSchemaFromObjectSchema makeSchema makeSimpleAutocompleteMetadataFormula makeSyncTable makeTranslateObjectFormula newPack simpleAutocomplete withQueryParams","title":"@codahq/packs-sdk"},{"location":"reference/sdk/#codahqpacks-sdk","text":"","title":"@codahq/packs-sdk"},{"location":"reference/sdk/#enumerations","text":"AttributionNodeType AuthenticationType ConnectionRequirement CurrencyFormat DefaultConnectionType DurationUnit NetworkConnection ParameterType PostSetupType PrecannedDateRange ScaleIconSet Type ValueHintType ValueType","title":"Enumerations"},{"location":"reference/sdk/#classes","text":"PackDefinitionBuilder StatusCodeError UserVisibleError","title":"Classes"},{"location":"reference/sdk/#interfaces","text":"ArraySchema ArrayType BooleanSchema Continuation CurrencySchema DurationSchema DynamicSyncTableDef EmptyFormulaDef ExecutionContext ExternalPackVersionMetadata FetchRequest FetchResponse Fetcher Format Identity IdentityDefinition MetadataFormulaObjectResultType Network NumericDateSchema NumericDateTimeSchema NumericSchema NumericTimeSchema OAuth2Authentication ObjectSchema ObjectSchemaProperty PackDefinition PackFormatMetadata PackFormulaDef PackFormulas PackFormulasMetadata PackVersionDefinition ParamDef ScaleSchema SimpleAutocompleteOption SimpleStringSchema SliderSchema StringDateSchema StringDateTimeSchema StringTimeSchema SyncExecutionContext SyncFormulaResult SyncTableDef TemporaryBlobStorage WebBasicAuthentication","title":"Interfaces"},{"location":"reference/sdk/#type-aliases","text":"Authentication BasicPackDefinition DefaultValueType ExternalObjectPackFormula ExternalPackFormat ExternalPackFormatMetadata ExternalPackFormula ExternalPackFormulas ExternalPackMetadata ExternalSyncTable FetchMethodType Formula GenericDynamicSyncTable GenericObjectSchema GenericSyncFormula GenericSyncFormulaResult GenericSyncTable MetadataContext MetadataFormula MetadataFormulaResultType NumberSchema ObjectSchemaProperties PackFormulaMetadata PackFormulaResult PackFormulaValue PackId PackMetadata PackSyncTable PackVersionMetadata ParamDefs ParamValues ParamsList Schema SchemaType StringSchema SystemAuthentication TypedPackFormula","title":"Type aliases"},{"location":"reference/sdk/#functions","text":"assertCondition autocompleteSearchObjects ensureExists ensureNonEmptyString ensureUnreachable generateSchema getQueryParams joinUrl makeAttributionNode makeDynamicSyncTable makeEmptyFormula makeFormula makeMetadataFormula makeObjectSchema makeParameter makeReferenceSchemaFromObjectSchema makeSchema makeSimpleAutocompleteMetadataFormula makeSyncTable makeTranslateObjectFormula newPack simpleAutocomplete withQueryParams","title":"Functions"},{"location":"reference/sdk/classes/PackDefinitionBuilder/","text":"Class: PackDefinitionBuilder \u00b6 A class that assists in constructing a pack definition. Use newPack to create one. Implements \u00b6 BasicPackDefinition Constructors \u00b6 constructor \u00b6 \u2022 new PackDefinitionBuilder ( definition? ) Constructs a PackDefinitionBuilder . However, coda.newPack() should be used instead rather than constructing a builder directly. Parameters \u00b6 Name Type definition? Partial < PackVersionDefinition > Defined in \u00b6 builder.ts:85 Properties \u00b6 defaultAuthentication \u00b6 \u2022 Optional defaultAuthentication : Authentication See PackVersionDefinition.defaultAuthentication . Implementation of \u00b6 BasicPackDefinition.defaultAuthentication Defined in \u00b6 builder.ts:66 formats \u00b6 \u2022 formats : Format [] See PackVersionDefinition.formats . Implementation of \u00b6 BasicPackDefinition.formats Defined in \u00b6 builder.ts:53 formulaNamespace \u00b6 \u2022 Optional formulaNamespace : string deprecated Implementation of \u00b6 BasicPackDefinition.formulaNamespace Defined in \u00b6 builder.ts:77 formulas \u00b6 \u2022 formulas : ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] See PackVersionDefinition.formulas . Implementation of \u00b6 BasicPackDefinition.formulas Defined in \u00b6 builder.ts:49 networkDomains \u00b6 \u2022 networkDomains : string [] See PackVersionDefinition.networkDomains . Implementation of \u00b6 BasicPackDefinition.networkDomains Defined in \u00b6 builder.ts:61 syncTables \u00b6 \u2022 syncTables : SyncTable [] See PackVersionDefinition.syncTables . Implementation of \u00b6 BasicPackDefinition.syncTables Defined in \u00b6 builder.ts:57 systemConnectionAuthentication \u00b6 \u2022 Optional systemConnectionAuthentication : SystemAuthentication See PackVersionDefinition.systemConnectionAuthentication . Implementation of \u00b6 BasicPackDefinition.systemConnectionAuthentication Defined in \u00b6 builder.ts:70 version \u00b6 \u2022 Optional version : string See PackVersionDefinition.version . Defined in \u00b6 builder.ts:75 Methods \u00b6 addColumnFormat \u00b6 \u25b8 addColumnFormat ( format ): PackDefinitionBuilder Adds a column format definition to this pack. In the web editor, the /ColumnFormat shortcut will insert a snippet of a skeleton format. example pack.addColumnFormat({ name: 'MyColumn', formulaName: 'MyFormula', }); Parameters \u00b6 Name Type format Format Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:229 addDynamicSyncTable \u00b6 \u25b8 addDynamicSyncTable < K , L , ParamDefsT , SchemaT >( definition ): PackDefinitionBuilder Adds a dynamic sync table definition to this pack. In the web editor, the /DynamicSyncTable shortcut will insert a snippet of a skeleton sync table. example pack.addDynamicSyncTable({ name: 'MySyncTable', getName: async (context) => { const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl}); return response.body.name; }, getName: async (context) => { const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl}); return response.body.browserLink; }, ... }); Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchemaDefinition < K , L , SchemaT > Parameters \u00b6 Name Type definition DynamicSyncTableOptions < K , L , ParamDefsT , SchemaT > Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:202 addFormula \u00b6 \u25b8 addFormula < ParamDefsT , ResultT , SchemaT >( definition ): PackDefinitionBuilder Adds a formula definition to this pack. In the web editor, the /Formula shortcut will insert a snippet of a skeleton formula. example pack.addFormula({ resultType: ValueType.String, name: 'MyFormula', description: 'My description.', parameters: [ makeParameter({ type: ParameterType.String, name: 'myParam', description: 'My param description.', }), ], execute: async ([param]) => { return `Hello ${param}`; }, }); Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs ResultT extends FormulaResultValueType SchemaT extends Schema Parameters \u00b6 Name Type definition FormulaDefinitionV2 < ParamDefsT , ResultT , SchemaT > Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:130 addNetworkDomain \u00b6 \u25b8 addNetworkDomain (... domain ): PackDefinitionBuilder Adds the domain that this pack makes HTTP requests to. For example, if your pack makes HTTP requests to \"api.example.com\", use \"example.com\" as your network domain. If your pack make HTTP requests, it must declare a network domain, for security purposes. Coda enforces that your pack cannot make requests to any undeclared domains. You are allowed one network domain per pack by default. If your pack needs to connect to multiple domains, contact Coda Support for approval. example pack.addNetworkDomain('example.com'); Parameters \u00b6 Name Type ...domain string [] Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:324 addSyncTable \u00b6 \u25b8 addSyncTable < K , L , ParamDefsT , SchemaT >( __namedParameters ): PackDefinitionBuilder Adds a sync table definition to this pack. In the web editor, the /SyncTable shortcut will insert a snippet of a skeleton sync table. example pack.addSyncTable({ name: 'MySyncTable', identityName: 'EntityName', schema: coda.makeObjectSchema({ ... }), formula: { ... }, }); Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchema < K , L , SchemaT > Parameters \u00b6 Name Type __namedParameters SyncTableOptions < K , L , ParamDefsT , SchemaT > Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:160 setSystemAuthentication \u00b6 \u25b8 setSystemAuthentication ( systemAuthentication ): PackDefinitionBuilder Sets this pack to use authentication provided by you as the maker of this pack. You will need to register credentials to use with this pack. When users use the pack, their requests will be authenticated with those system credentials, they need not register their own account. In the web editor, the /SystemAuthentication shortcut will insert a snippet of a skeleton authentication definition. example pack.setSystemAuthentication({ type: AuthenticationType.HeaderBearerToken, }); Parameters \u00b6 Name Type systemAuthentication SystemAuthenticationDef Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:294 setUserAuthentication \u00b6 \u25b8 setUserAuthentication ( authDef ): PackDefinitionBuilder Sets this pack to use authentication for individual users, using the authentication method is the given definition. Each user will need to register an account in order to use this pack. In the web editor, the /UserAuthentication shortcut will insert a snippet of a skeleton authentication definition. By default, this will set a default connection (account) requirement, making a user account required to invoke all formulas in this pack unless you specify differently on a particular formula. To change the default, you can pass a defaultConnectionRequirement option into this method. example pack.setUserAuthentication({ type: AuthenticationType.HeaderBearerToken, }); Parameters \u00b6 Name Type authDef NoAuthentication & { defaultConnectionRequirement? : ConnectionRequirement } & VariousAuthentication & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < HeaderBearerTokenAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < CodaApiBearerTokenAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < CustomHeaderTokenAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < QueryParamTokenAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < MultiQueryParamTokenAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < OAuth2Authentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < WebBasicAuthentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } & Omit < AWSSignature4Authentication , \"getConnectionName\" | \"getConnectionUserId\" > & { getConnectionName? : MetadataFormulaDef } & { defaultConnectionRequirement? : ConnectionRequirement } Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:255 setVersion \u00b6 \u25b8 setVersion ( version ): PackDefinitionBuilder Sets the semantic version of this pack version, e.g. '1.2.3' . This is optional, and you only need to provide a version if you are manually doing semantic versioning, or using the CLI. If using the web editor, you can omit this and the web editor will automatically provide an appropriate semantic version each time you build a version. example pack.setVersion('1.2.3'); Parameters \u00b6 Name Type version string Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:342","title":"Class: PackDefinitionBuilder"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#class-packdefinitionbuilder","text":"A class that assists in constructing a pack definition. Use newPack to create one.","title":"Class: PackDefinitionBuilder"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#implements","text":"BasicPackDefinition","title":"Implements"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#constructors","text":"","title":"Constructors"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#constructor","text":"\u2022 new PackDefinitionBuilder ( definition? ) Constructs a PackDefinitionBuilder . However, coda.newPack() should be used instead rather than constructing a builder directly.","title":"constructor"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#properties","text":"","title":"Properties"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#defaultauthentication","text":"\u2022 Optional defaultAuthentication : Authentication See PackVersionDefinition.defaultAuthentication .","title":"defaultAuthentication"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#formats","text":"\u2022 formats : Format [] See PackVersionDefinition.formats .","title":"formats"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#formulanamespace","text":"\u2022 Optional formulaNamespace : string deprecated","title":"formulaNamespace"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#formulas","text":"\u2022 formulas : ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] See PackVersionDefinition.formulas .","title":"formulas"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#networkdomains","text":"\u2022 networkDomains : string [] See PackVersionDefinition.networkDomains .","title":"networkDomains"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#synctables","text":"\u2022 syncTables : SyncTable [] See PackVersionDefinition.syncTables .","title":"syncTables"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#systemconnectionauthentication","text":"\u2022 Optional systemConnectionAuthentication : SystemAuthentication See PackVersionDefinition.systemConnectionAuthentication .","title":"systemConnectionAuthentication"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#version","text":"\u2022 Optional version : string See PackVersionDefinition.version .","title":"version"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#methods","text":"","title":"Methods"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#addcolumnformat","text":"\u25b8 addColumnFormat ( format ): PackDefinitionBuilder Adds a column format definition to this pack. In the web editor, the /ColumnFormat shortcut will insert a snippet of a skeleton format. example pack.addColumnFormat({ name: 'MyColumn', formulaName: 'MyFormula', });","title":"addColumnFormat"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#adddynamicsynctable","text":"\u25b8 addDynamicSyncTable < K , L , ParamDefsT , SchemaT >( definition ): PackDefinitionBuilder Adds a dynamic sync table definition to this pack. In the web editor, the /DynamicSyncTable shortcut will insert a snippet of a skeleton sync table. example pack.addDynamicSyncTable({ name: 'MySyncTable', getName: async (context) => { const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl}); return response.body.name; }, getName: async (context) => { const response = await context.fetcher.fetch({method: 'GET', url: context.sync.dynamicUrl}); return response.body.browserLink; }, ... });","title":"addDynamicSyncTable"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#addformula","text":"\u25b8 addFormula < ParamDefsT , ResultT , SchemaT >( definition ): PackDefinitionBuilder Adds a formula definition to this pack. In the web editor, the /Formula shortcut will insert a snippet of a skeleton formula. example pack.addFormula({ resultType: ValueType.String, name: 'MyFormula', description: 'My description.', parameters: [ makeParameter({ type: ParameterType.String, name: 'myParam', description: 'My param description.', }), ], execute: async ([param]) => { return `Hello ${param}`; }, });","title":"addFormula"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#addnetworkdomain","text":"\u25b8 addNetworkDomain (... domain ): PackDefinitionBuilder Adds the domain that this pack makes HTTP requests to. For example, if your pack makes HTTP requests to \"api.example.com\", use \"example.com\" as your network domain. If your pack make HTTP requests, it must declare a network domain, for security purposes. Coda enforces that your pack cannot make requests to any undeclared domains. You are allowed one network domain per pack by default. If your pack needs to connect to multiple domains, contact Coda Support for approval. example pack.addNetworkDomain('example.com');","title":"addNetworkDomain"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#addsynctable","text":"\u25b8 addSyncTable < K , L , ParamDefsT , SchemaT >( __namedParameters ): PackDefinitionBuilder Adds a sync table definition to this pack. In the web editor, the /SyncTable shortcut will insert a snippet of a skeleton sync table. example pack.addSyncTable({ name: 'MySyncTable', identityName: 'EntityName', schema: coda.makeObjectSchema({ ... }), formula: { ... }, });","title":"addSyncTable"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#setsystemauthentication","text":"\u25b8 setSystemAuthentication ( systemAuthentication ): PackDefinitionBuilder Sets this pack to use authentication provided by you as the maker of this pack. You will need to register credentials to use with this pack. When users use the pack, their requests will be authenticated with those system credentials, they need not register their own account. In the web editor, the /SystemAuthentication shortcut will insert a snippet of a skeleton authentication definition. example pack.setSystemAuthentication({ type: AuthenticationType.HeaderBearerToken, });","title":"setSystemAuthentication"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#setuserauthentication","text":"\u25b8 setUserAuthentication ( authDef ): PackDefinitionBuilder Sets this pack to use authentication for individual users, using the authentication method is the given definition. Each user will need to register an account in order to use this pack. In the web editor, the /UserAuthentication shortcut will insert a snippet of a skeleton authentication definition. By default, this will set a default connection (account) requirement, making a user account required to invoke all formulas in this pack unless you specify differently on a particular formula. To change the default, you can pass a defaultConnectionRequirement option into this method. example pack.setUserAuthentication({ type: AuthenticationType.HeaderBearerToken, });","title":"setUserAuthentication"},{"location":"reference/sdk/classes/PackDefinitionBuilder/#setversion","text":"\u25b8 setVersion ( version ): PackDefinitionBuilder Sets the semantic version of this pack version, e.g. '1.2.3' . This is optional, and you only need to provide a version if you are manually doing semantic versioning, or using the CLI. If using the web editor, you can omit this and the web editor will automatically provide an appropriate semantic version each time you build a version. example pack.setVersion('1.2.3');","title":"setVersion"},{"location":"reference/sdk/classes/StatusCodeError/","text":"Class: StatusCodeError \u00b6 An error that will be thrown by Fetcher.fetch when the fetcher response has an HTTP status code of 400 or greater. This class largely models the StatusCodeError from the (now deprecated) request-promise library, which has a quirky structure. Hierarchy \u00b6 Error \u21b3 StatusCodeError Properties \u00b6 body \u00b6 \u2022 body : any The parsed body of the HTTP response. Defined in \u00b6 api.ts:107 error \u00b6 \u2022 error : any Alias for body . Defined in \u00b6 api.ts:111 name \u00b6 \u2022 name : string = 'StatusCodeError' The name of the error, for identiciation purposes. Overrides \u00b6 Error.name Defined in \u00b6 api.ts:99 options \u00b6 \u2022 options : FetchRequest The original fetcher request used to make this HTTP request. Defined in \u00b6 api.ts:115 response \u00b6 \u2022 response : StatusCodeErrorResponse The raw HTTP response, including headers. Defined in \u00b6 api.ts:119 statusCode \u00b6 \u2022 statusCode : number The HTTP status code, e.g. 404 . Defined in \u00b6 api.ts:103","title":"Class: StatusCodeError"},{"location":"reference/sdk/classes/StatusCodeError/#class-statuscodeerror","text":"An error that will be thrown by Fetcher.fetch when the fetcher response has an HTTP status code of 400 or greater. This class largely models the StatusCodeError from the (now deprecated) request-promise library, which has a quirky structure.","title":"Class: StatusCodeError"},{"location":"reference/sdk/classes/StatusCodeError/#hierarchy","text":"Error \u21b3 StatusCodeError","title":"Hierarchy"},{"location":"reference/sdk/classes/StatusCodeError/#properties","text":"","title":"Properties"},{"location":"reference/sdk/classes/StatusCodeError/#body","text":"\u2022 body : any The parsed body of the HTTP response.","title":"body"},{"location":"reference/sdk/classes/StatusCodeError/#error","text":"\u2022 error : any Alias for body .","title":"error"},{"location":"reference/sdk/classes/StatusCodeError/#name","text":"\u2022 name : string = 'StatusCodeError' The name of the error, for identiciation purposes.","title":"name"},{"location":"reference/sdk/classes/StatusCodeError/#options","text":"\u2022 options : FetchRequest The original fetcher request used to make this HTTP request.","title":"options"},{"location":"reference/sdk/classes/StatusCodeError/#response","text":"\u2022 response : StatusCodeErrorResponse The raw HTTP response, including headers.","title":"response"},{"location":"reference/sdk/classes/StatusCodeError/#statuscode","text":"\u2022 statusCode : number The HTTP status code, e.g. 404 .","title":"statusCode"},{"location":"reference/sdk/classes/UserVisibleError/","text":"Class: UserVisibleError \u00b6 An error whose message will be shown to the end user in the UI when it occurs. If an error is encountered in a formula and you want to describe the error to the end user, throw a UserVisibleError with a user-friendly message and the Coda UI will display the message. Hierarchy \u00b6 Error \u21b3 UserVisibleError Constructors \u00b6 constructor \u00b6 \u2022 new UserVisibleError ( message? , internalError? ) Use to construct a user-visible error. example if (!url.startsWith(\"http\")) { throw new coda.UserVisibleError(\"Please provide a valid url.\"); } Parameters \u00b6 Name Type message? string internalError? Error Overrides \u00b6 Error.constructor Defined in \u00b6 api.ts:72","title":"Class: UserVisibleError"},{"location":"reference/sdk/classes/UserVisibleError/#class-uservisibleerror","text":"An error whose message will be shown to the end user in the UI when it occurs. If an error is encountered in a formula and you want to describe the error to the end user, throw a UserVisibleError with a user-friendly message and the Coda UI will display the message.","title":"Class: UserVisibleError"},{"location":"reference/sdk/classes/UserVisibleError/#hierarchy","text":"Error \u21b3 UserVisibleError","title":"Hierarchy"},{"location":"reference/sdk/classes/UserVisibleError/#constructors","text":"","title":"Constructors"},{"location":"reference/sdk/classes/UserVisibleError/#constructor","text":"\u2022 new UserVisibleError ( message? , internalError? ) Use to construct a user-visible error. example if (!url.startsWith(\"http\")) { throw new coda.UserVisibleError(\"Please provide a valid url.\"); }","title":"constructor"},{"location":"reference/sdk/enums/AttributionNodeType/","text":"Enumeration: AttributionNodeType \u00b6 The type of content in this attribution node. Multiple attribution nodes can be rendered all together, for example to have attribution that contains both text and a logo image. Enumeration members \u00b6 Image \u00b6 \u2022 Image = 3 An image, often a logo of the data source. Defined in \u00b6 schema.ts:599 Link \u00b6 \u2022 Link = 2 A hyperlink pointing to the data source. Defined in \u00b6 schema.ts:595 Text \u00b6 \u2022 Text = 1 Text attribution content. Defined in \u00b6 schema.ts:591","title":"Enumeration: AttributionNodeType"},{"location":"reference/sdk/enums/AttributionNodeType/#enumeration-attributionnodetype","text":"The type of content in this attribution node. Multiple attribution nodes can be rendered all together, for example to have attribution that contains both text and a logo image.","title":"Enumeration: AttributionNodeType"},{"location":"reference/sdk/enums/AttributionNodeType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/AttributionNodeType/#image","text":"\u2022 Image = 3 An image, often a logo of the data source.","title":"Image"},{"location":"reference/sdk/enums/AttributionNodeType/#link","text":"\u2022 Link = 2 A hyperlink pointing to the data source.","title":"Link"},{"location":"reference/sdk/enums/AttributionNodeType/#text","text":"\u2022 Text = 1 Text attribution content.","title":"Text"},{"location":"reference/sdk/enums/AuthenticationType/","text":"Enumeration: AuthenticationType \u00b6 Authentication types supported by Coda Packs. Enumeration members \u00b6 CodaApiHeaderBearerToken \u00b6 \u2022 CodaApiHeaderBearerToken = \"CodaApiHeaderBearerToken\" Authenticate using a Coda REST API token, sent as an HTTP header. This is identical to HeaderBearerToken except the user wil be presented with a UI to generate an API token rather than needing to paste an arbitrary API token into a text input. This is primarily for use by Coda-authored packs, as it is only relevant for interacting with the Coda REST API. Defined in \u00b6 types.ts:101 CustomHeaderToken \u00b6 \u2022 CustomHeaderToken = \"CustomHeaderToken\" Authenticate using an HTTP header with a custom name and token prefix that you specify. The header name is defined in the {@link headerName} property. Defined in \u00b6 types.ts:52 HeaderBearerToken \u00b6 \u2022 HeaderBearerToken = \"HeaderBearerToken\" Authenticate using an HTTP header of the form Authorization: Bearer <token> . Defined in \u00b6 types.ts:47 MultiQueryParamToken \u00b6 \u2022 MultiQueryParamToken = \"MultiQueryParamToken\" Authenticate using multiple tokens, each passed as a different URL parameter, e.g. https://example.com/api?param1=token1&param2=token2 The parameter names are defined in the params array property. Defined in \u00b6 types.ts:66 None \u00b6 \u2022 None = \"None\" Indicates this pack does not use authentication. You may also omit an authentication declaration entirely. Defined in \u00b6 types.ts:43 OAuth2 \u00b6 \u2022 OAuth2 = \"OAuth2\" Authenticate using OAuth2. You must specify the authorization URL, token exchange URL, and scopes here as part of the pack definition. You'll provide the application's client ID and client secret in the pack management UI, so that these can be stored securely. The API must use a (largely) standards-compliant implementation of OAuth2. Defined in \u00b6 types.ts:74 QueryParamToken \u00b6 \u2022 QueryParamToken = \"QueryParamToken\" Authenticate using a token that is passed as a URL parameter with each request, e.g. https://example.com/api?paramName=token The parameter name is defined in the {@link paramName} property. Defined in \u00b6 types.ts:59 WebBasic \u00b6 \u2022 WebBasic = \"WebBasic\" Authenticate using HTTP Basic authorization. The user provides a username and password (sometimes optional) which are included as an HTTP header according to the Basic auth standard. See https://en.wikipedia.org/wiki/Basic_access_authentication Defined in \u00b6 types.ts:81","title":"Enumeration: AuthenticationType"},{"location":"reference/sdk/enums/AuthenticationType/#enumeration-authenticationtype","text":"Authentication types supported by Coda Packs.","title":"Enumeration: AuthenticationType"},{"location":"reference/sdk/enums/AuthenticationType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/AuthenticationType/#codaapiheaderbearertoken","text":"\u2022 CodaApiHeaderBearerToken = \"CodaApiHeaderBearerToken\" Authenticate using a Coda REST API token, sent as an HTTP header. This is identical to HeaderBearerToken except the user wil be presented with a UI to generate an API token rather than needing to paste an arbitrary API token into a text input. This is primarily for use by Coda-authored packs, as it is only relevant for interacting with the Coda REST API.","title":"CodaApiHeaderBearerToken"},{"location":"reference/sdk/enums/AuthenticationType/#customheadertoken","text":"\u2022 CustomHeaderToken = \"CustomHeaderToken\" Authenticate using an HTTP header with a custom name and token prefix that you specify. The header name is defined in the {@link headerName} property.","title":"CustomHeaderToken"},{"location":"reference/sdk/enums/AuthenticationType/#headerbearertoken","text":"\u2022 HeaderBearerToken = \"HeaderBearerToken\" Authenticate using an HTTP header of the form Authorization: Bearer <token> .","title":"HeaderBearerToken"},{"location":"reference/sdk/enums/AuthenticationType/#multiqueryparamtoken","text":"\u2022 MultiQueryParamToken = \"MultiQueryParamToken\" Authenticate using multiple tokens, each passed as a different URL parameter, e.g. https://example.com/api?param1=token1&param2=token2 The parameter names are defined in the params array property.","title":"MultiQueryParamToken"},{"location":"reference/sdk/enums/AuthenticationType/#none","text":"\u2022 None = \"None\" Indicates this pack does not use authentication. You may also omit an authentication declaration entirely.","title":"None"},{"location":"reference/sdk/enums/AuthenticationType/#oauth2","text":"\u2022 OAuth2 = \"OAuth2\" Authenticate using OAuth2. You must specify the authorization URL, token exchange URL, and scopes here as part of the pack definition. You'll provide the application's client ID and client secret in the pack management UI, so that these can be stored securely. The API must use a (largely) standards-compliant implementation of OAuth2.","title":"OAuth2"},{"location":"reference/sdk/enums/AuthenticationType/#queryparamtoken","text":"\u2022 QueryParamToken = \"QueryParamToken\" Authenticate using a token that is passed as a URL parameter with each request, e.g. https://example.com/api?paramName=token The parameter name is defined in the {@link paramName} property.","title":"QueryParamToken"},{"location":"reference/sdk/enums/AuthenticationType/#webbasic","text":"\u2022 WebBasic = \"WebBasic\" Authenticate using HTTP Basic authorization. The user provides a username and password (sometimes optional) which are included as an HTTP header according to the Basic auth standard. See https://en.wikipedia.org/wiki/Basic_access_authentication","title":"WebBasic"},{"location":"reference/sdk/enums/ConnectionRequirement/","text":"Enumeration: ConnectionRequirement \u00b6 Enumeration of requirement states for whether a given formula or sync table requires a connection (account) to use. Enumeration members \u00b6 None \u00b6 \u2022 None = \"none\" Indicates this building block does not make use of an account. Defined in \u00b6 api_types.ts:319 Optional \u00b6 \u2022 Optional = \"optional\" Indicates that this building block can be used with or without an account. An optional parameter will be added to the formula (or sync formula) for the calling user to specify an account to use. Defined in \u00b6 api_types.ts:326 Required \u00b6 \u2022 Required = \"required\" Indicates that this building block must be used with an account. A required parameter will be added to the formula (or sync formula) for the calling user to specify an account to use. Defined in \u00b6 api_types.ts:333","title":"Enumeration: ConnectionRequirement"},{"location":"reference/sdk/enums/ConnectionRequirement/#enumeration-connectionrequirement","text":"Enumeration of requirement states for whether a given formula or sync table requires a connection (account) to use.","title":"Enumeration: ConnectionRequirement"},{"location":"reference/sdk/enums/ConnectionRequirement/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/ConnectionRequirement/#none","text":"\u2022 None = \"none\" Indicates this building block does not make use of an account.","title":"None"},{"location":"reference/sdk/enums/ConnectionRequirement/#optional","text":"\u2022 Optional = \"optional\" Indicates that this building block can be used with or without an account. An optional parameter will be added to the formula (or sync formula) for the calling user to specify an account to use.","title":"Optional"},{"location":"reference/sdk/enums/ConnectionRequirement/#required","text":"\u2022 Required = \"required\" Indicates that this building block must be used with an account. A required parameter will be added to the formula (or sync formula) for the calling user to specify an account to use.","title":"Required"},{"location":"reference/sdk/enums/CurrencyFormat/","text":"Enumeration: CurrencyFormat \u00b6 Enumeration of formats supported by schemas that use ValueHintType.Currency . These affect how a numeric value is rendered in docs. Enumeration members \u00b6 Accounting \u00b6 \u2022 Accounting = \"accounting\" Indicates the value should be rendered as a number with a currency symbol as a prefix, but padded to allow the numeric values to line up vertically, e.g. $ 2.50 $ 29.99 Defined in \u00b6 schema.ts:309 Currency \u00b6 \u2022 Currency = \"currency\" Indicates the value should be rendered as a number with a currency symbol as a prefix, e.g. $2.50 . Defined in \u00b6 schema.ts:299 Financial \u00b6 \u2022 Financial = \"financial\" Indicates the value should be rendered as a number without a currency symbol, e.g. 2.50 . Defined in \u00b6 schema.ts:313","title":"Enumeration: CurrencyFormat"},{"location":"reference/sdk/enums/CurrencyFormat/#enumeration-currencyformat","text":"Enumeration of formats supported by schemas that use ValueHintType.Currency . These affect how a numeric value is rendered in docs.","title":"Enumeration: CurrencyFormat"},{"location":"reference/sdk/enums/CurrencyFormat/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/CurrencyFormat/#accounting","text":"\u2022 Accounting = \"accounting\" Indicates the value should be rendered as a number with a currency symbol as a prefix, but padded to allow the numeric values to line up vertically, e.g. $ 2.50 $ 29.99","title":"Accounting"},{"location":"reference/sdk/enums/CurrencyFormat/#currency","text":"\u2022 Currency = \"currency\" Indicates the value should be rendered as a number with a currency symbol as a prefix, e.g. $2.50 .","title":"Currency"},{"location":"reference/sdk/enums/CurrencyFormat/#financial","text":"\u2022 Financial = \"financial\" Indicates the value should be rendered as a number without a currency symbol, e.g. 2.50 .","title":"Financial"},{"location":"reference/sdk/enums/DefaultConnectionType/","text":"Enumeration: DefaultConnectionType \u00b6 Ways in which a user account can be used with a doc. Enumeration members \u00b6 ProxyActionsOnly \u00b6 \u2022 ProxyActionsOnly = 3 The account can only be used by the Coda user who set up the account, and only to take actions (i.e. push buttons). Each Coda user that uses the pack will be prompted to connect their own private (AKA proxy) account. Private accounts can't be used to retrieve data, because all users in the doc must be able to retrieve the same data. Defined in \u00b6 types.ts:129 Shared \u00b6 \u2022 Shared = 2 The account can be used by any user in the doc both to retrieve data and to take actions. Defined in \u00b6 types.ts:122 SharedDataOnly \u00b6 \u2022 SharedDataOnly = 1 The account can be used by any user in the a doc, but only to read data. The account can't be used to take actions (i.e. push buttons). Defined in \u00b6 types.ts:118","title":"Enumeration: DefaultConnectionType"},{"location":"reference/sdk/enums/DefaultConnectionType/#enumeration-defaultconnectiontype","text":"Ways in which a user account can be used with a doc.","title":"Enumeration: DefaultConnectionType"},{"location":"reference/sdk/enums/DefaultConnectionType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/DefaultConnectionType/#proxyactionsonly","text":"\u2022 ProxyActionsOnly = 3 The account can only be used by the Coda user who set up the account, and only to take actions (i.e. push buttons). Each Coda user that uses the pack will be prompted to connect their own private (AKA proxy) account. Private accounts can't be used to retrieve data, because all users in the doc must be able to retrieve the same data.","title":"ProxyActionsOnly"},{"location":"reference/sdk/enums/DefaultConnectionType/#shared","text":"\u2022 Shared = 2 The account can be used by any user in the doc both to retrieve data and to take actions.","title":"Shared"},{"location":"reference/sdk/enums/DefaultConnectionType/#shareddataonly","text":"\u2022 SharedDataOnly = 1 The account can be used by any user in the a doc, but only to read data. The account can't be used to take actions (i.e. push buttons).","title":"SharedDataOnly"},{"location":"reference/sdk/enums/DurationUnit/","text":"Enumeration: DurationUnit \u00b6 Enumeration of units supported by duration schemas. See maxUnit . Enumeration members \u00b6 Days \u00b6 \u2022 Days = \"days\" Indications a duration as a number of days. Defined in \u00b6 schema.ts:459 Hours \u00b6 \u2022 Hours = \"hours\" Indications a duration as a number of hours. Defined in \u00b6 schema.ts:463 Minutes \u00b6 \u2022 Minutes = \"minutes\" Indications a duration as a number of minutes. Defined in \u00b6 schema.ts:467 Seconds \u00b6 \u2022 Seconds = \"seconds\" Indications a duration as a number of seconds. Defined in \u00b6 schema.ts:471","title":"Enumeration: DurationUnit"},{"location":"reference/sdk/enums/DurationUnit/#enumeration-durationunit","text":"Enumeration of units supported by duration schemas. See maxUnit .","title":"Enumeration: DurationUnit"},{"location":"reference/sdk/enums/DurationUnit/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/DurationUnit/#days","text":"\u2022 Days = \"days\" Indications a duration as a number of days.","title":"Days"},{"location":"reference/sdk/enums/DurationUnit/#hours","text":"\u2022 Hours = \"hours\" Indications a duration as a number of hours.","title":"Hours"},{"location":"reference/sdk/enums/DurationUnit/#minutes","text":"\u2022 Minutes = \"minutes\" Indications a duration as a number of minutes.","title":"Minutes"},{"location":"reference/sdk/enums/DurationUnit/#seconds","text":"\u2022 Seconds = \"seconds\" Indications a duration as a number of seconds.","title":"Seconds"},{"location":"reference/sdk/enums/NetworkConnection/","text":"Enumeration: NetworkConnection \u00b6 deprecated use ConnectionRequirement instead Enumeration members \u00b6 None \u00b6 \u2022 None = \"none\" Defined in \u00b6 api_types.ts:338 Optional \u00b6 \u2022 Optional = \"optional\" Defined in \u00b6 api_types.ts:339 Required \u00b6 \u2022 Required = \"required\" Defined in \u00b6 api_types.ts:340","title":"Enumeration: NetworkConnection"},{"location":"reference/sdk/enums/NetworkConnection/#enumeration-networkconnection","text":"deprecated use ConnectionRequirement instead","title":"Enumeration: NetworkConnection"},{"location":"reference/sdk/enums/NetworkConnection/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/NetworkConnection/#none","text":"\u2022 None = \"none\"","title":"None"},{"location":"reference/sdk/enums/NetworkConnection/#optional","text":"\u2022 Optional = \"optional\"","title":"Optional"},{"location":"reference/sdk/enums/NetworkConnection/#required","text":"\u2022 Required = \"required\"","title":"Required"},{"location":"reference/sdk/enums/ParameterType/","text":"Enumeration: ParameterType \u00b6 Enumeration of types of formula parameters. These describe Coda value types (as opposed to JavaScript value types). Enumeration members \u00b6 Boolean \u00b6 \u2022 Boolean = \"boolean\" Indicates a parameter that is a Coda boolean value. Defined in \u00b6 api_types.ts:108 BooleanArray \u00b6 \u2022 BooleanArray = \"booleanArray\" Indicates a parameter that is a list of Coda boolean values. Defined in \u00b6 api_types.ts:133 Date \u00b6 \u2022 Date = \"date\" Indicates a parameter that is a Coda date value (which includes time and datetime values). Defined in \u00b6 api_types.ts:112 DateArray \u00b6 \u2022 DateArray = \"dateArray\" Indicates a parameter that is a list of Coda date values (which includes time and datetime values). Currently, when such a parameter is used with a sync table formula or an action formula ( isAction ), which will generate a builder UI for selecting parameters, a date array parameter will always render as a date range selector. A date range will always be passed to a pack formula as a list of two elements, the beginning of the range and the end of the range. Defined in \u00b6 api_types.ts:142 Html \u00b6 \u2022 Html = \"html\" Indicates a parameter that is a Coda rich text value that should be passed to the pack as HTML. Defined in \u00b6 api_types.ts:116 HtmlArray \u00b6 \u2022 HtmlArray = \"htmlArray \"` Indicates a parameter that is a list of Coda rich text values that should be passed to the pack as HTML. Defined in \u00b6 api_types.ts:146 Image \u00b6 \u2022 Image = \"image\" Indicates a parameter that is a Coda image. The pack is passed an image URL. Defined in \u00b6 api_types.ts:120 ImageArray \u00b6 \u2022 ImageArray = \"imageArray\" Indicates a parameter that is a list of Coda image values. The pack is passed a list of image URLs. Defined in \u00b6 api_types.ts:150 Number \u00b6 \u2022 Number = \"number\" Indicates a parameter that is a Coda number value. Defined in \u00b6 api_types.ts:104 NumberArray \u00b6 \u2022 NumberArray = \"numberArray\" Indicates a parameter that is a list of Coda number values. Defined in \u00b6 api_types.ts:129 String \u00b6 \u2022 String = \"string\" Indicates a parameter that is a Coda text value. Defined in \u00b6 api_types.ts:100 StringArray \u00b6 \u2022 StringArray = \"stringArray\" Indicates a parameter that is a list of Coda text values. Defined in \u00b6 api_types.ts:125","title":"Enumeration: ParameterType"},{"location":"reference/sdk/enums/ParameterType/#enumeration-parametertype","text":"Enumeration of types of formula parameters. These describe Coda value types (as opposed to JavaScript value types).","title":"Enumeration: ParameterType"},{"location":"reference/sdk/enums/ParameterType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/ParameterType/#boolean","text":"\u2022 Boolean = \"boolean\" Indicates a parameter that is a Coda boolean value.","title":"Boolean"},{"location":"reference/sdk/enums/ParameterType/#booleanarray","text":"\u2022 BooleanArray = \"booleanArray\" Indicates a parameter that is a list of Coda boolean values.","title":"BooleanArray"},{"location":"reference/sdk/enums/ParameterType/#date","text":"\u2022 Date = \"date\" Indicates a parameter that is a Coda date value (which includes time and datetime values).","title":"Date"},{"location":"reference/sdk/enums/ParameterType/#datearray","text":"\u2022 DateArray = \"dateArray\" Indicates a parameter that is a list of Coda date values (which includes time and datetime values). Currently, when such a parameter is used with a sync table formula or an action formula ( isAction ), which will generate a builder UI for selecting parameters, a date array parameter will always render as a date range selector. A date range will always be passed to a pack formula as a list of two elements, the beginning of the range and the end of the range.","title":"DateArray"},{"location":"reference/sdk/enums/ParameterType/#html","text":"\u2022 Html = \"html\" Indicates a parameter that is a Coda rich text value that should be passed to the pack as HTML.","title":"Html"},{"location":"reference/sdk/enums/ParameterType/#htmlarray","text":"\u2022 HtmlArray = \"htmlArray \"` Indicates a parameter that is a list of Coda rich text values that should be passed to the pack as HTML.","title":"HtmlArray"},{"location":"reference/sdk/enums/ParameterType/#image","text":"\u2022 Image = \"image\" Indicates a parameter that is a Coda image. The pack is passed an image URL.","title":"Image"},{"location":"reference/sdk/enums/ParameterType/#imagearray","text":"\u2022 ImageArray = \"imageArray\" Indicates a parameter that is a list of Coda image values. The pack is passed a list of image URLs.","title":"ImageArray"},{"location":"reference/sdk/enums/ParameterType/#number","text":"\u2022 Number = \"number\" Indicates a parameter that is a Coda number value.","title":"Number"},{"location":"reference/sdk/enums/ParameterType/#numberarray","text":"\u2022 NumberArray = \"numberArray\" Indicates a parameter that is a list of Coda number values.","title":"NumberArray"},{"location":"reference/sdk/enums/ParameterType/#string","text":"\u2022 String = \"string\" Indicates a parameter that is a Coda text value.","title":"String"},{"location":"reference/sdk/enums/ParameterType/#stringarray","text":"\u2022 StringArray = \"stringArray\" Indicates a parameter that is a list of Coda text values.","title":"StringArray"},{"location":"reference/sdk/enums/PostSetupType/","text":"Enumeration: PostSetupType \u00b6 Enumeration of post-account-setup step types. See {@link PostSetup}. Enumeration members \u00b6 SetEndpoint \u00b6 \u2022 SetEndpoint = \"SetEndPoint\" See SetEndpoint . Defined in \u00b6 types.ts:186","title":"Enumeration: PostSetupType"},{"location":"reference/sdk/enums/PostSetupType/#enumeration-postsetuptype","text":"Enumeration of post-account-setup step types. See {@link PostSetup}.","title":"Enumeration: PostSetupType"},{"location":"reference/sdk/enums/PostSetupType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/PostSetupType/#setendpoint","text":"\u2022 SetEndpoint = \"SetEndPoint\" See SetEndpoint .","title":"SetEndpoint"},{"location":"reference/sdk/enums/PrecannedDateRange/","text":"Enumeration: PrecannedDateRange \u00b6 Special \"live\" date range values that can be used as the defaultValue for a date array parameter. Date array parameters are meant to represent date ranges. A date range can be a fixed range, e.g. April 1, 2020 - May 15, 2020, or it can be a \"live\" range, like \"last 30 days\". At execution time, a date range will always be passed to a pack as an array of two specific dates, but for many use cases, it is necessary to provide a default value that is a \"live\" range rather than hardcoded one. For example, if your pack has a table that syncs recent emails, you might want to have a date range parameter that default to \"last 7 days\". Defaulting to a hardcoded date range would not be useful and requiring the user to always specify a date range may be inconvenient. Enumeration members \u00b6 Everything \u00b6 \u2022 Everything = \"everything\" Indicates a date range beginning in the very distant past (e.g. 1/1/1, aka 1 A.D.) and ending in the distant future (e.g. 12/31/3999). Exact dates are subject to change. Defined in \u00b6 api_types.ts:644 Last30Days \u00b6 \u2022 Last30Days = \"last_30_days\" Defined in \u00b6 api_types.ts:613 Last3Months \u00b6 \u2022 Last3Months = \"last_3_months\" Defined in \u00b6 api_types.ts:616 Last6Months \u00b6 \u2022 Last6Months = \"last_6_months\" Defined in \u00b6 api_types.ts:617 Last7Days \u00b6 \u2022 Last7Days = \"last_7_days\" Defined in \u00b6 api_types.ts:612 LastMonth \u00b6 \u2022 LastMonth = \"last_month\" Defined in \u00b6 api_types.ts:615 LastWeek \u00b6 \u2022 LastWeek = \"last_week\" Defined in \u00b6 api_types.ts:614 LastYear \u00b6 \u2022 LastYear = \"last_year\" Defined in \u00b6 api_types.ts:618 Next30Days \u00b6 \u2022 Next30Days = \"next_30_days\" Defined in \u00b6 api_types.ts:633 Next3Months \u00b6 \u2022 Next3Months = \"next_3_months\" Defined in \u00b6 api_types.ts:636 Next6Months \u00b6 \u2022 Next6Months = \"next_6_months\" Defined in \u00b6 api_types.ts:637 Next7Days \u00b6 \u2022 Next7Days = \"next_7_days\" Defined in \u00b6 api_types.ts:632 NextMonth \u00b6 \u2022 NextMonth = \"next_month\" Defined in \u00b6 api_types.ts:635 NextWeek \u00b6 \u2022 NextWeek = \"next_week\" Defined in \u00b6 api_types.ts:634 NextYear \u00b6 \u2022 NextYear = \"next_year\" Defined in \u00b6 api_types.ts:638 ThisMonth \u00b6 \u2022 ThisMonth = \"this_month\" Defined in \u00b6 api_types.ts:624 ThisMonthStart \u00b6 \u2022 ThisMonthStart = \"this_month_start\" Defined in \u00b6 api_types.ts:625 ThisWeek \u00b6 \u2022 ThisWeek = \"this_week\" Defined in \u00b6 api_types.ts:622 ThisWeekStart \u00b6 \u2022 ThisWeekStart = \"this_week_start\" Defined in \u00b6 api_types.ts:623 ThisYear \u00b6 \u2022 ThisYear = \"this_year\" Defined in \u00b6 api_types.ts:628 ThisYearStart \u00b6 \u2022 ThisYearStart = \"this_year_start\" Defined in \u00b6 api_types.ts:626 Today \u00b6 \u2022 Today = \"today\" Defined in \u00b6 api_types.ts:621 Tomorrow \u00b6 \u2022 Tomorrow = \"tomorrow\" Defined in \u00b6 api_types.ts:631 YearToDate \u00b6 \u2022 YearToDate = \"year_to_date\" Defined in \u00b6 api_types.ts:627 Yesterday \u00b6 \u2022 Yesterday = \"yesterday\" Defined in \u00b6 api_types.ts:611","title":"Enumeration: PrecannedDateRange"},{"location":"reference/sdk/enums/PrecannedDateRange/#enumeration-precanneddaterange","text":"Special \"live\" date range values that can be used as the defaultValue for a date array parameter. Date array parameters are meant to represent date ranges. A date range can be a fixed range, e.g. April 1, 2020 - May 15, 2020, or it can be a \"live\" range, like \"last 30 days\". At execution time, a date range will always be passed to a pack as an array of two specific dates, but for many use cases, it is necessary to provide a default value that is a \"live\" range rather than hardcoded one. For example, if your pack has a table that syncs recent emails, you might want to have a date range parameter that default to \"last 7 days\". Defaulting to a hardcoded date range would not be useful and requiring the user to always specify a date range may be inconvenient.","title":"Enumeration: PrecannedDateRange"},{"location":"reference/sdk/enums/PrecannedDateRange/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/PrecannedDateRange/#everything","text":"\u2022 Everything = \"everything\" Indicates a date range beginning in the very distant past (e.g. 1/1/1, aka 1 A.D.) and ending in the distant future (e.g. 12/31/3999). Exact dates are subject to change.","title":"Everything"},{"location":"reference/sdk/enums/PrecannedDateRange/#last30days","text":"\u2022 Last30Days = \"last_30_days\"","title":"Last30Days"},{"location":"reference/sdk/enums/PrecannedDateRange/#last3months","text":"\u2022 Last3Months = \"last_3_months\"","title":"Last3Months"},{"location":"reference/sdk/enums/PrecannedDateRange/#last6months","text":"\u2022 Last6Months = \"last_6_months\"","title":"Last6Months"},{"location":"reference/sdk/enums/PrecannedDateRange/#last7days","text":"\u2022 Last7Days = \"last_7_days\"","title":"Last7Days"},{"location":"reference/sdk/enums/PrecannedDateRange/#lastmonth","text":"\u2022 LastMonth = \"last_month\"","title":"LastMonth"},{"location":"reference/sdk/enums/PrecannedDateRange/#lastweek","text":"\u2022 LastWeek = \"last_week\"","title":"LastWeek"},{"location":"reference/sdk/enums/PrecannedDateRange/#lastyear","text":"\u2022 LastYear = \"last_year\"","title":"LastYear"},{"location":"reference/sdk/enums/PrecannedDateRange/#next30days","text":"\u2022 Next30Days = \"next_30_days\"","title":"Next30Days"},{"location":"reference/sdk/enums/PrecannedDateRange/#next3months","text":"\u2022 Next3Months = \"next_3_months\"","title":"Next3Months"},{"location":"reference/sdk/enums/PrecannedDateRange/#next6months","text":"\u2022 Next6Months = \"next_6_months\"","title":"Next6Months"},{"location":"reference/sdk/enums/PrecannedDateRange/#next7days","text":"\u2022 Next7Days = \"next_7_days\"","title":"Next7Days"},{"location":"reference/sdk/enums/PrecannedDateRange/#nextmonth","text":"\u2022 NextMonth = \"next_month\"","title":"NextMonth"},{"location":"reference/sdk/enums/PrecannedDateRange/#nextweek","text":"\u2022 NextWeek = \"next_week\"","title":"NextWeek"},{"location":"reference/sdk/enums/PrecannedDateRange/#nextyear","text":"\u2022 NextYear = \"next_year\"","title":"NextYear"},{"location":"reference/sdk/enums/PrecannedDateRange/#thismonth","text":"\u2022 ThisMonth = \"this_month\"","title":"ThisMonth"},{"location":"reference/sdk/enums/PrecannedDateRange/#thismonthstart","text":"\u2022 ThisMonthStart = \"this_month_start\"","title":"ThisMonthStart"},{"location":"reference/sdk/enums/PrecannedDateRange/#thisweek","text":"\u2022 ThisWeek = \"this_week\"","title":"ThisWeek"},{"location":"reference/sdk/enums/PrecannedDateRange/#thisweekstart","text":"\u2022 ThisWeekStart = \"this_week_start\"","title":"ThisWeekStart"},{"location":"reference/sdk/enums/PrecannedDateRange/#thisyear","text":"\u2022 ThisYear = \"this_year\"","title":"ThisYear"},{"location":"reference/sdk/enums/PrecannedDateRange/#thisyearstart","text":"\u2022 ThisYearStart = \"this_year_start\"","title":"ThisYearStart"},{"location":"reference/sdk/enums/PrecannedDateRange/#today","text":"\u2022 Today = \"today\"","title":"Today"},{"location":"reference/sdk/enums/PrecannedDateRange/#tomorrow","text":"\u2022 Tomorrow = \"tomorrow\"","title":"Tomorrow"},{"location":"reference/sdk/enums/PrecannedDateRange/#yeartodate","text":"\u2022 YearToDate = \"year_to_date\"","title":"YearToDate"},{"location":"reference/sdk/enums/PrecannedDateRange/#yesterday","text":"\u2022 Yesterday = \"yesterday\"","title":"Yesterday"},{"location":"reference/sdk/enums/ScaleIconSet/","text":"Enumeration: ScaleIconSet \u00b6 Icons that can be used with a ScaleSchema . For example, to render a star rating, use a ScaleSchema with icon: coda.ScaleIconSet.Star . Enumeration members \u00b6 Battery \u00b6 \u2022 Battery = \"battery\" Defined in \u00b6 schema.ts:368 Bell \u00b6 \u2022 Bell = \"bell\" Defined in \u00b6 schema.ts:359 Bug \u00b6 \u2022 Bug = \"bug\" Defined in \u00b6 schema.ts:357 Checkmark \u00b6 \u2022 Checkmark = \"checkmark\" Defined in \u00b6 schema.ts:372 Chili \u00b6 \u2022 Chili = \"chili\" Defined in \u00b6 schema.ts:362 Circle \u00b6 \u2022 Circle = \"circle\" Defined in \u00b6 schema.ts:355 Cloud \u00b6 \u2022 Cloud = \"cloud\" Defined in \u00b6 schema.ts:370 Cocktail \u00b6 \u2022 Cocktail = \"cocktail\" Defined in \u00b6 schema.ts:369 Coffee \u00b6 \u2022 Coffee = \"coffee\" Defined in \u00b6 schema.ts:366 Currency \u00b6 \u2022 Currency = \"currency\" Defined in \u00b6 schema.ts:365 Diamond \u00b6 \u2022 Diamond = \"diamond\" Defined in \u00b6 schema.ts:358 Fire \u00b6 \u2022 Fire = \"fire\" Defined in \u00b6 schema.ts:356 Heart \u00b6 \u2022 Heart = \"heart\" Defined in \u00b6 schema.ts:361 LightBulb \u00b6 \u2022 LightBulb = \"lightbulb\" Defined in \u00b6 schema.ts:373 Lightning \u00b6 \u2022 Lightning = \"lightning\" Defined in \u00b6 schema.ts:364 Person \u00b6 \u2022 Person = \"person\" Defined in \u00b6 schema.ts:367 Smiley \u00b6 \u2022 Smiley = \"smiley\" Defined in \u00b6 schema.ts:363 Star \u00b6 \u2022 Star = \"star\" Defined in \u00b6 schema.ts:354 Sun \u00b6 \u2022 Sun = \"sun\" Defined in \u00b6 schema.ts:371 ThumbsUp \u00b6 \u2022 ThumbsUp = \"thumbsup\" Defined in \u00b6 schema.ts:360","title":"Enumeration: ScaleIconSet"},{"location":"reference/sdk/enums/ScaleIconSet/#enumeration-scaleiconset","text":"Icons that can be used with a ScaleSchema . For example, to render a star rating, use a ScaleSchema with icon: coda.ScaleIconSet.Star .","title":"Enumeration: ScaleIconSet"},{"location":"reference/sdk/enums/ScaleIconSet/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/ScaleIconSet/#battery","text":"\u2022 Battery = \"battery\"","title":"Battery"},{"location":"reference/sdk/enums/ScaleIconSet/#bell","text":"\u2022 Bell = \"bell\"","title":"Bell"},{"location":"reference/sdk/enums/ScaleIconSet/#bug","text":"\u2022 Bug = \"bug\"","title":"Bug"},{"location":"reference/sdk/enums/ScaleIconSet/#checkmark","text":"\u2022 Checkmark = \"checkmark\"","title":"Checkmark"},{"location":"reference/sdk/enums/ScaleIconSet/#chili","text":"\u2022 Chili = \"chili\"","title":"Chili"},{"location":"reference/sdk/enums/ScaleIconSet/#circle","text":"\u2022 Circle = \"circle\"","title":"Circle"},{"location":"reference/sdk/enums/ScaleIconSet/#cloud","text":"\u2022 Cloud = \"cloud\"","title":"Cloud"},{"location":"reference/sdk/enums/ScaleIconSet/#cocktail","text":"\u2022 Cocktail = \"cocktail\"","title":"Cocktail"},{"location":"reference/sdk/enums/ScaleIconSet/#coffee","text":"\u2022 Coffee = \"coffee\"","title":"Coffee"},{"location":"reference/sdk/enums/ScaleIconSet/#currency","text":"\u2022 Currency = \"currency\"","title":"Currency"},{"location":"reference/sdk/enums/ScaleIconSet/#diamond","text":"\u2022 Diamond = \"diamond\"","title":"Diamond"},{"location":"reference/sdk/enums/ScaleIconSet/#fire","text":"\u2022 Fire = \"fire\"","title":"Fire"},{"location":"reference/sdk/enums/ScaleIconSet/#heart","text":"\u2022 Heart = \"heart\"","title":"Heart"},{"location":"reference/sdk/enums/ScaleIconSet/#lightbulb","text":"\u2022 LightBulb = \"lightbulb\"","title":"LightBulb"},{"location":"reference/sdk/enums/ScaleIconSet/#lightning","text":"\u2022 Lightning = \"lightning\"","title":"Lightning"},{"location":"reference/sdk/enums/ScaleIconSet/#person","text":"\u2022 Person = \"person\"","title":"Person"},{"location":"reference/sdk/enums/ScaleIconSet/#smiley","text":"\u2022 Smiley = \"smiley\"","title":"Smiley"},{"location":"reference/sdk/enums/ScaleIconSet/#star","text":"\u2022 Star = \"star\"","title":"Star"},{"location":"reference/sdk/enums/ScaleIconSet/#sun","text":"\u2022 Sun = \"sun\"","title":"Sun"},{"location":"reference/sdk/enums/ScaleIconSet/#thumbsup","text":"\u2022 ThumbsUp = \"thumbsup\"","title":"ThumbsUp"},{"location":"reference/sdk/enums/Type/","text":"Enumeration: Type \u00b6 Markers used internally to represent data types for parameters and return values. It should not be necessary to ever use these values directly. When defining a parameter, use ParameterType . When defining a formula return value, or properties within an object return value, use ValueType . Enumeration members \u00b6 boolean \u00b6 \u2022 boolean = 3 Defined in \u00b6 api_types.ts:18 date \u00b6 \u2022 date = 4 Defined in \u00b6 api_types.ts:19 html \u00b6 \u2022 html = 5 Defined in \u00b6 api_types.ts:20 image \u00b6 \u2022 image = 6 Defined in \u00b6 api_types.ts:21 number \u00b6 \u2022 number = 1 Defined in \u00b6 api_types.ts:16 object \u00b6 \u2022 object = 2 Defined in \u00b6 api_types.ts:17 string \u00b6 \u2022 string = 0 Defined in \u00b6 api_types.ts:15","title":"Enumeration: Type"},{"location":"reference/sdk/enums/Type/#enumeration-type","text":"Markers used internally to represent data types for parameters and return values. It should not be necessary to ever use these values directly. When defining a parameter, use ParameterType . When defining a formula return value, or properties within an object return value, use ValueType .","title":"Enumeration: Type"},{"location":"reference/sdk/enums/Type/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/Type/#boolean","text":"\u2022 boolean = 3","title":"boolean"},{"location":"reference/sdk/enums/Type/#date","text":"\u2022 date = 4","title":"date"},{"location":"reference/sdk/enums/Type/#html","text":"\u2022 html = 5","title":"html"},{"location":"reference/sdk/enums/Type/#image","text":"\u2022 image = 6","title":"image"},{"location":"reference/sdk/enums/Type/#number","text":"\u2022 number = 1","title":"number"},{"location":"reference/sdk/enums/Type/#object","text":"\u2022 object = 2","title":"object"},{"location":"reference/sdk/enums/Type/#string","text":"\u2022 string = 0","title":"string"},{"location":"reference/sdk/enums/ValueHintType/","text":"Enumeration: ValueHintType \u00b6 Synthetic types that instruct Coda how to coerce values from primitives at ingestion time. Enumeration members \u00b6 Attachment \u00b6 \u2022 Attachment = \"attachment\" Indicates to interpret and render a value as a file attachment. The provided value should be a URL pointing to a file of a Coda-supported type. Coda will ingest the file and host it from Coda infrastructure. Defined in \u00b6 schema.ts:146 Currency \u00b6 \u2022 Currency = \"currency\" Indicates to interpret and render the value as a currency value. Defined in \u00b6 schema.ts:85 Date \u00b6 \u2022 Date = \"date\" Indicates to interpret the value as a date (e.g. March 3, 2021). Defined in \u00b6 schema.ts:45 DateTime \u00b6 \u2022 DateTime = \"datetime\" Indicates to interpret the value as a datetime (e.g. March 3, 2021 at 5:24pm). Defined in \u00b6 schema.ts:53 Duration \u00b6 \u2022 Duration = \"duration\" Indicates to interpret the value as a duration (e.g. 3 hours). Defined in \u00b6 schema.ts:57 Embed \u00b6 \u2022 Embed = \"embed\" Indicates to interpret and render a value as an embed. The provided value should be a URL pointing to an embeddable web page. Defined in \u00b6 schema.ts:115 Html \u00b6 \u2022 Html = \"html\" Indicates to interpret a text value as HTML, which will be converted and rendered as Coda rich text. Defined in \u00b6 schema.ts:110 ImageAttachment \u00b6 \u2022 ImageAttachment = \"imageAttachment\" Indicates to interpret and render the value as an image. The provided value should be a URL that points to an image. Coda will ingest the image and host it from Coda infrastructure. Defined in \u00b6 schema.ts:98 ImageReference \u00b6 \u2022 ImageReference = \"image\" Indicates to interpret and render the value as an image. The provided value should be a URL that points to an image. Coda will hotlink to the image when rendering it a doc. Using ImageAttachment is recommended instead, so that the image is always accessible and won't appear as broken if the source image is later deleted. Defined in \u00b6 schema.ts:93 Markdown \u00b6 \u2022 Markdown = \"markdown\" Indicates to interpret a text value as Markdown, which will be converted and rendered as Coda rich text. Defined in \u00b6 schema.ts:106 Percent \u00b6 \u2022 Percent = \"percent\" Indicates to interpret and render the value as a percentage. Defined in \u00b6 schema.ts:81 Person \u00b6 \u2022 Person = \"person\" Indicates to interpret and render the value as a Coda person reference. The provided value should be an object whose id property is an email address, which Coda will try to resolve to a user and render an @-reference to the user. example makeObjectSchema({ type: ValueType.Object, codaType: ValueHintType.Person, id: 'email', primary: 'name', properties: { email: {type: ValueType.String, required: true}, name: {type: ValueType.String, required: true}, }, }); Defined in \u00b6 schema.ts:77 Reference \u00b6 \u2022 Reference = \"reference\" Indicates to interpret and render the value as a Coda @-reference to a table row. The provided value should be an object whose id value matches the id of some row in a sync table. The schema where this hint type is used must specify an identity that specifies the desired sync table. Normally a reference schema is constructed from the schema object being referenced using the helper makeReferenceSchemaFromObjectSchema . example makeObjectSchema({ type: ValueType.Object, codaType: ValueHintType.Reference, identity: { name: \"SomeSyncTableIdentity\" }, id: 'identifier', primary: 'name', properties: { identifier: {type: ValueType.Number, required: true}, name: {type: ValueType.String, required: true}, }, }); Defined in \u00b6 schema.ts:141 Scale \u00b6 \u2022 Scale = \"scale\" Indicates to render a numeric value as a scale UI component (e.g. a star rating). Defined in \u00b6 schema.ts:154 Slider \u00b6 \u2022 Slider = \"slider\" Indicates to render a numeric value as a slider UI component. Defined in \u00b6 schema.ts:150 Time \u00b6 \u2022 Time = \"time\" Indicates to interpret the value as a time (e.g. 5:24pm). Defined in \u00b6 schema.ts:49 Url \u00b6 \u2022 Url = \"url\" Indicates to interpret and render the value as a URL link. Defined in \u00b6 schema.ts:102","title":"Enumeration: ValueHintType"},{"location":"reference/sdk/enums/ValueHintType/#enumeration-valuehinttype","text":"Synthetic types that instruct Coda how to coerce values from primitives at ingestion time.","title":"Enumeration: ValueHintType"},{"location":"reference/sdk/enums/ValueHintType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/ValueHintType/#attachment","text":"\u2022 Attachment = \"attachment\" Indicates to interpret and render a value as a file attachment. The provided value should be a URL pointing to a file of a Coda-supported type. Coda will ingest the file and host it from Coda infrastructure.","title":"Attachment"},{"location":"reference/sdk/enums/ValueHintType/#currency","text":"\u2022 Currency = \"currency\" Indicates to interpret and render the value as a currency value.","title":"Currency"},{"location":"reference/sdk/enums/ValueHintType/#date","text":"\u2022 Date = \"date\" Indicates to interpret the value as a date (e.g. March 3, 2021).","title":"Date"},{"location":"reference/sdk/enums/ValueHintType/#datetime","text":"\u2022 DateTime = \"datetime\" Indicates to interpret the value as a datetime (e.g. March 3, 2021 at 5:24pm).","title":"DateTime"},{"location":"reference/sdk/enums/ValueHintType/#duration","text":"\u2022 Duration = \"duration\" Indicates to interpret the value as a duration (e.g. 3 hours).","title":"Duration"},{"location":"reference/sdk/enums/ValueHintType/#embed","text":"\u2022 Embed = \"embed\" Indicates to interpret and render a value as an embed. The provided value should be a URL pointing to an embeddable web page.","title":"Embed"},{"location":"reference/sdk/enums/ValueHintType/#html","text":"\u2022 Html = \"html\" Indicates to interpret a text value as HTML, which will be converted and rendered as Coda rich text.","title":"Html"},{"location":"reference/sdk/enums/ValueHintType/#imageattachment","text":"\u2022 ImageAttachment = \"imageAttachment\" Indicates to interpret and render the value as an image. The provided value should be a URL that points to an image. Coda will ingest the image and host it from Coda infrastructure.","title":"ImageAttachment"},{"location":"reference/sdk/enums/ValueHintType/#imagereference","text":"\u2022 ImageReference = \"image\" Indicates to interpret and render the value as an image. The provided value should be a URL that points to an image. Coda will hotlink to the image when rendering it a doc. Using ImageAttachment is recommended instead, so that the image is always accessible and won't appear as broken if the source image is later deleted.","title":"ImageReference"},{"location":"reference/sdk/enums/ValueHintType/#markdown","text":"\u2022 Markdown = \"markdown\" Indicates to interpret a text value as Markdown, which will be converted and rendered as Coda rich text.","title":"Markdown"},{"location":"reference/sdk/enums/ValueHintType/#percent","text":"\u2022 Percent = \"percent\" Indicates to interpret and render the value as a percentage.","title":"Percent"},{"location":"reference/sdk/enums/ValueHintType/#person","text":"\u2022 Person = \"person\" Indicates to interpret and render the value as a Coda person reference. The provided value should be an object whose id property is an email address, which Coda will try to resolve to a user and render an @-reference to the user. example makeObjectSchema({ type: ValueType.Object, codaType: ValueHintType.Person, id: 'email', primary: 'name', properties: { email: {type: ValueType.String, required: true}, name: {type: ValueType.String, required: true}, }, });","title":"Person"},{"location":"reference/sdk/enums/ValueHintType/#reference","text":"\u2022 Reference = \"reference\" Indicates to interpret and render the value as a Coda @-reference to a table row. The provided value should be an object whose id value matches the id of some row in a sync table. The schema where this hint type is used must specify an identity that specifies the desired sync table. Normally a reference schema is constructed from the schema object being referenced using the helper makeReferenceSchemaFromObjectSchema . example makeObjectSchema({ type: ValueType.Object, codaType: ValueHintType.Reference, identity: { name: \"SomeSyncTableIdentity\" }, id: 'identifier', primary: 'name', properties: { identifier: {type: ValueType.Number, required: true}, name: {type: ValueType.String, required: true}, }, });","title":"Reference"},{"location":"reference/sdk/enums/ValueHintType/#scale","text":"\u2022 Scale = \"scale\" Indicates to render a numeric value as a scale UI component (e.g. a star rating).","title":"Scale"},{"location":"reference/sdk/enums/ValueHintType/#slider","text":"\u2022 Slider = \"slider\" Indicates to render a numeric value as a slider UI component.","title":"Slider"},{"location":"reference/sdk/enums/ValueHintType/#time","text":"\u2022 Time = \"time\" Indicates to interpret the value as a time (e.g. 5:24pm).","title":"Time"},{"location":"reference/sdk/enums/ValueHintType/#url","text":"\u2022 Url = \"url\" Indicates to interpret and render the value as a URL link.","title":"Url"},{"location":"reference/sdk/enums/ValueType/","text":"Enumeration: ValueType \u00b6 The set of primitive value types that can be used as return values for formulas or in object schemas. Enumeration members \u00b6 Array \u00b6 \u2022 Array = \"array\" Indicates a JavaScript array should be returned. The schema of the array items must also be specified. Defined in \u00b6 schema.ts:31 Boolean \u00b6 \u2022 Boolean = \"boolean\" Indicates a JavaScript boolean (true/false) should be returned. Defined in \u00b6 schema.ts:19 Number \u00b6 \u2022 Number = \"number\" Indicates a JavaScript number should be returned. Defined in \u00b6 schema.ts:23 Object \u00b6 \u2022 Object = \"object\" Indicates a JavaScript object should be returned. The schema of each object property must also be specified. Defined in \u00b6 schema.ts:35 String \u00b6 \u2022 String = \"string\" Indicates a JavaScript string should be returned. Defined in \u00b6 schema.ts:27","title":"Enumeration: ValueType"},{"location":"reference/sdk/enums/ValueType/#enumeration-valuetype","text":"The set of primitive value types that can be used as return values for formulas or in object schemas.","title":"Enumeration: ValueType"},{"location":"reference/sdk/enums/ValueType/#enumeration-members","text":"","title":"Enumeration members"},{"location":"reference/sdk/enums/ValueType/#array","text":"\u2022 Array = \"array\" Indicates a JavaScript array should be returned. The schema of the array items must also be specified.","title":"Array"},{"location":"reference/sdk/enums/ValueType/#boolean","text":"\u2022 Boolean = \"boolean\" Indicates a JavaScript boolean (true/false) should be returned.","title":"Boolean"},{"location":"reference/sdk/enums/ValueType/#number","text":"\u2022 Number = \"number\" Indicates a JavaScript number should be returned.","title":"Number"},{"location":"reference/sdk/enums/ValueType/#object","text":"\u2022 Object = \"object\" Indicates a JavaScript object should be returned. The schema of each object property must also be specified.","title":"Object"},{"location":"reference/sdk/enums/ValueType/#string","text":"\u2022 String = \"string\" Indicates a JavaScript string should be returned.","title":"String"},{"location":"reference/sdk/functions/assertCondition/","text":"Function: assertCondition \u00b6 \u25b8 assertCondition ( condition , message? ): asserts condition Helper to apply a TypeScript assertion to subsequent code. TypeScript can infer type information from many expressions, and this helper applies those inferences to all code that follows call to this function. See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions example function foo(value: string | number) { assertCondtion(typeof value === 'string'); // TypeScript would otherwise compalin, because `value` could have been number, // but the above assertion refines the type based on the `typeof` expression. return value.toUpperCase(); } Parameters \u00b6 Name Type condition any message? string Returns \u00b6 asserts condition Defined in \u00b6 helpers/ensure.ts:79","title":"Function: assertCondition"},{"location":"reference/sdk/functions/assertCondition/#function-assertcondition","text":"\u25b8 assertCondition ( condition , message? ): asserts condition Helper to apply a TypeScript assertion to subsequent code. TypeScript can infer type information from many expressions, and this helper applies those inferences to all code that follows call to this function. See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions example function foo(value: string | number) { assertCondtion(typeof value === 'string'); // TypeScript would otherwise compalin, because `value` could have been number, // but the above assertion refines the type based on the `typeof` expression. return value.toUpperCase(); }","title":"Function: assertCondition"},{"location":"reference/sdk/functions/autocompleteSearchObjects/","text":"Function: autocompleteSearchObjects \u00b6 \u25b8 autocompleteSearchObjects < T >( search , objs , displayKey , valueKey ): Promise < MetadataFormulaObjectResultType []> A helper to search over a list of objects representing candidate search results, filtering to only those that match a search string, and converting the matching objects into the format needed for autocomplete results. A case-sensitive search is performed over each object's displayKey property. A common pattern for implementing autocomplete for a formula pattern is to make a request to an API endpoint that returns a list of all entities, and then to take the user's partial input and search over those entities for matches. The helper generalizes this use case. example coda.makeParameter({ type: ParameterType.Number, name: \"userId\", description: \"The ID of a user.\", autocomplete: async function(context, search) { // Suppose this endpoint returns a list of users that have the form // `{name: \"Jane Doe\", userId: 123, email: \"jane@doe.com\"}` const usersResponse = await context.fetcher.fetch(\"/api/users\"); // This will search over the name property of each object and filter to only // those that match. Then it will transform the matching objects into the form // `{display: \"Jane Doe\", value: 123}` which is what is required to render // autocomplete responses. return coda.autocompleteSearchObjects(search, usersResponse.body, \"name\", \"userId\"); } }); Type parameters \u00b6 Name T Parameters \u00b6 Name Type search string objs T [] displayKey keyof T valueKey keyof T Returns \u00b6 Promise < MetadataFormulaObjectResultType []> Defined in \u00b6 api.ts:883","title":"Function: autocompleteSearchObjects"},{"location":"reference/sdk/functions/autocompleteSearchObjects/#function-autocompletesearchobjects","text":"\u25b8 autocompleteSearchObjects < T >( search , objs , displayKey , valueKey ): Promise < MetadataFormulaObjectResultType []> A helper to search over a list of objects representing candidate search results, filtering to only those that match a search string, and converting the matching objects into the format needed for autocomplete results. A case-sensitive search is performed over each object's displayKey property. A common pattern for implementing autocomplete for a formula pattern is to make a request to an API endpoint that returns a list of all entities, and then to take the user's partial input and search over those entities for matches. The helper generalizes this use case. example coda.makeParameter({ type: ParameterType.Number, name: \"userId\", description: \"The ID of a user.\", autocomplete: async function(context, search) { // Suppose this endpoint returns a list of users that have the form // `{name: \"Jane Doe\", userId: 123, email: \"jane@doe.com\"}` const usersResponse = await context.fetcher.fetch(\"/api/users\"); // This will search over the name property of each object and filter to only // those that match. Then it will transform the matching objects into the form // `{display: \"Jane Doe\", value: 123}` which is what is required to render // autocomplete responses. return coda.autocompleteSearchObjects(search, usersResponse.body, \"name\", \"userId\"); } });","title":"Function: autocompleteSearchObjects"},{"location":"reference/sdk/functions/ensureExists/","text":"Function: ensureExists \u00b6 \u25b8 ensureExists < T >( value , message? ): T Helper to check that a given value is defined, that is, is neither undefined nor null . If the value is undefined or null , an error will be raised at runtime. This is typically used to inform TypeScript that you expect a given value to always exist. Calling this function refines a type that can otherwise be null or undefined. Type parameters \u00b6 Name T Parameters \u00b6 Name Type value undefined | null | T message? string Returns \u00b6 T Defined in \u00b6 helpers/ensure.ts:51","title":"Function: ensureExists"},{"location":"reference/sdk/functions/ensureExists/#function-ensureexists","text":"\u25b8 ensureExists < T >( value , message? ): T Helper to check that a given value is defined, that is, is neither undefined nor null . If the value is undefined or null , an error will be raised at runtime. This is typically used to inform TypeScript that you expect a given value to always exist. Calling this function refines a type that can otherwise be null or undefined.","title":"Function: ensureExists"},{"location":"reference/sdk/functions/ensureNonEmptyString/","text":"Function: ensureNonEmptyString \u00b6 \u25b8 ensureNonEmptyString ( value , message? ): string Helper to check that a given value is a string, and is not the empty string. If the value is not a string or is empty, an error will be raised at runtime. Parameters \u00b6 Name Type value undefined | null | string message? string Returns \u00b6 string Defined in \u00b6 helpers/ensure.ts:37","title":"Function: ensureNonEmptyString"},{"location":"reference/sdk/functions/ensureNonEmptyString/#function-ensurenonemptystring","text":"\u25b8 ensureNonEmptyString ( value , message? ): string Helper to check that a given value is a string, and is not the empty string. If the value is not a string or is empty, an error will be raised at runtime.","title":"Function: ensureNonEmptyString"},{"location":"reference/sdk/functions/ensureUnreachable/","text":"Function: ensureUnreachable \u00b6 \u25b8 ensureUnreachable ( value , message? ): never Helper for TypeScript to make sure that handling of code forks is exhaustive, most commonly with a switch statement. example enum MyEnum { Foo = 'Foo', Bar = 'Bar', } function handleEnum(value: MyEnum) { switch(value) { case MyEnum.Foo: return 'foo'; case MyEnum.Bar: return 'bar'; default: // This code is unreachable since the two cases above are exhaustive. // However, if a third value were added to MyEnum, TypeScript would flag // an error at this line, informing you that you need to update this piece of code. return ensureUnreachable(value); } } Parameters \u00b6 Name Type value never message? string Returns \u00b6 never Defined in \u00b6 helpers/ensure.ts:29","title":"Function: ensureUnreachable"},{"location":"reference/sdk/functions/ensureUnreachable/#function-ensureunreachable","text":"\u25b8 ensureUnreachable ( value , message? ): never Helper for TypeScript to make sure that handling of code forks is exhaustive, most commonly with a switch statement. example enum MyEnum { Foo = 'Foo', Bar = 'Bar', } function handleEnum(value: MyEnum) { switch(value) { case MyEnum.Foo: return 'foo'; case MyEnum.Bar: return 'bar'; default: // This code is unreachable since the two cases above are exhaustive. // However, if a third value were added to MyEnum, TypeScript would flag // an error at this line, informing you that you need to update this piece of code. return ensureUnreachable(value); } }","title":"Function: ensureUnreachable"},{"location":"reference/sdk/functions/generateSchema/","text":"Function: generateSchema \u00b6 \u25b8 generateSchema ( obj ): Schema Parameters \u00b6 Name Type obj ValidTypes Returns \u00b6 Schema Defined in \u00b6 schema.ts:699","title":"Function: generateSchema"},{"location":"reference/sdk/functions/generateSchema/#function-generateschema","text":"\u25b8 generateSchema ( obj ): Schema","title":"Function: generateSchema"},{"location":"reference/sdk/functions/getQueryParams/","text":"Function: getQueryParams \u00b6 \u25b8 getQueryParams ( url ): Object Helper to take a URL string and return the parameters (if any) as a JavaScript object. example // Returns `{token: \"asdf\", limit: \"5\"}` let params = getQueryParams(\"/someApi/someEndpoint?token=asdf&limit=5\"); Parameters \u00b6 Name Type url string Returns \u00b6 Object Defined in \u00b6 helpers/url.ts:37","title":"Function: getQueryParams"},{"location":"reference/sdk/functions/getQueryParams/#function-getqueryparams","text":"\u25b8 getQueryParams ( url ): Object Helper to take a URL string and return the parameters (if any) as a JavaScript object. example // Returns `{token: \"asdf\", limit: \"5\"}` let params = getQueryParams(\"/someApi/someEndpoint?token=asdf&limit=5\");","title":"Function: getQueryParams"},{"location":"reference/sdk/functions/joinUrl/","text":"Function: joinUrl \u00b6 \u25b8 joinUrl (... tokens ): string Joins all the tokens into a single URL string separated by '/'. Zero length tokens cause errors. Parameters \u00b6 Name Type Description ...tokens string [] Zero or more tokens to be combined. If token doesn't end with '/', one will be added as the separator Returns \u00b6 string Defined in \u00b6 helpers/url.ts:47","title":"Function: joinUrl"},{"location":"reference/sdk/functions/joinUrl/#function-joinurl","text":"\u25b8 joinUrl (... tokens ): string Joins all the tokens into a single URL string separated by '/'. Zero length tokens cause errors.","title":"Function: joinUrl"},{"location":"reference/sdk/functions/makeAttributionNode/","text":"Function: makeAttributionNode \u00b6 \u25b8 makeAttributionNode < T >( node ): T A helper for constructing attribution text, links, or images that render along with a Pack value. Many APIs have licensing requirements that ask for specific attribution to be included when using their data. For example, a stock photo API may require attribution text and a logo. Any IdentityDefinition can include one or more attribution nodes that will be rendered any time a value with that identity is rendered in a doc. Type parameters \u00b6 Name Type T extends AttributionNode Parameters \u00b6 Name Type node T Returns \u00b6 T Defined in \u00b6 schema.ts:631","title":"Function: makeAttributionNode"},{"location":"reference/sdk/functions/makeAttributionNode/#function-makeattributionnode","text":"\u25b8 makeAttributionNode < T >( node ): T A helper for constructing attribution text, links, or images that render along with a Pack value. Many APIs have licensing requirements that ask for specific attribution to be included when using their data. For example, a stock photo API may require attribution text and a logo. Any IdentityDefinition can include one or more attribution nodes that will be rendered any time a value with that identity is rendered in a doc.","title":"Function: makeAttributionNode"},{"location":"reference/sdk/functions/makeDynamicSyncTable/","text":"Function: makeDynamicSyncTable \u00b6 \u25b8 makeDynamicSyncTable < K , L , ParamDefsT >( __namedParameters ): DynamicSyncTableDef < K , L , ParamDefsT , any > Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs Parameters \u00b6 Name Type __namedParameters Object __namedParameters.connectionRequirement? ConnectionRequirement __namedParameters.entityName? string __namedParameters.formula SyncFormulaDef < K , L , ParamDefsT , any > __namedParameters.getDisplayUrl MetadataFormulaDef __namedParameters.getName MetadataFormulaDef __namedParameters.getSchema MetadataFormulaDef __namedParameters.listDynamicUrls? MetadataFormulaDef __namedParameters.name string Returns \u00b6 DynamicSyncTableDef < K , L , ParamDefsT , any > Defined in \u00b6 api.ts:1165","title":"Function: makeDynamicSyncTable"},{"location":"reference/sdk/functions/makeDynamicSyncTable/#function-makedynamicsynctable","text":"\u25b8 makeDynamicSyncTable < K , L , ParamDefsT >( __namedParameters ): DynamicSyncTableDef < K , L , ParamDefsT , any >","title":"Function: makeDynamicSyncTable"},{"location":"reference/sdk/functions/makeEmptyFormula/","text":"Function: makeEmptyFormula \u00b6 \u25b8 makeEmptyFormula < ParamDefsT >( definition ): { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < string > ; resultType : string } Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs Parameters \u00b6 Name Type definition EmptyFormulaDef < ParamDefsT > Returns \u00b6 { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < string > ; resultType : string } Defined in \u00b6 api.ts:1275","title":"Function: makeEmptyFormula"},{"location":"reference/sdk/functions/makeEmptyFormula/#function-makeemptyformula","text":"\u25b8 makeEmptyFormula < ParamDefsT >( definition ): { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < string > ; resultType : string }","title":"Function: makeEmptyFormula"},{"location":"reference/sdk/functions/makeFormula/","text":"Function: makeFormula \u00b6 \u25b8 makeFormula < ParamDefsT , ResultT , SchemaT >( fullDefinition ): Formula < ParamDefsT , ResultT , SchemaT > Creates a formula definition. You must indicate the kind of value that this formula returns (string, number, boolean, array, or object) using the resultType field. Formulas always return basic types, but you may optionally give a type hint using codaType to tell Coda how to interpret a given value. For example, you can return a string that represents a date, but use codaType: ValueType.Date to tell Coda to interpret as a date in a document. If your formula returns an object, you must provide a schema property that describes the structure of the object. See makeObjectSchema for how to construct an object schema. If your formula returns a list (array), you must provide an items property that describes what the elements of the array are. This could be a simple schema like {type: ValueType.String} indicating that the array elements are all just strings, or it could be an object schema created using makeObjectSchema if the elements are objects. example makeFormula({resultType: ValueType.String, name: 'Hello', ...}); example makeFormula({resultType: ValueType.String, codaType: ValueType.Html, name: 'HelloHtml', ...}); example makeFormula({resultType: ValueType.Array, items: {type: ValueType.String}, name: 'HelloStringArray', ...}); example makeFormula({ resultType: ValueType.Object, schema: makeObjectSchema({type: ValueType.Object, properties: {...}}), name: 'HelloObject', ... }); example makeFormula({ resultType: ValueType.Array, items: makeObjectSchema({type: ValueType.Object, properties: {...}}), name: 'HelloObjectArray', ... }); Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs ResultT extends FormulaResultValueType SchemaT extends Schema Schema Parameters \u00b6 Name Type fullDefinition FormulaDefinitionV2 < ParamDefsT , ResultT , SchemaT > Returns \u00b6 Formula < ParamDefsT , ResultT , SchemaT > Defined in \u00b6 api.ts:598","title":"Function: makeFormula"},{"location":"reference/sdk/functions/makeFormula/#function-makeformula","text":"\u25b8 makeFormula < ParamDefsT , ResultT , SchemaT >( fullDefinition ): Formula < ParamDefsT , ResultT , SchemaT > Creates a formula definition. You must indicate the kind of value that this formula returns (string, number, boolean, array, or object) using the resultType field. Formulas always return basic types, but you may optionally give a type hint using codaType to tell Coda how to interpret a given value. For example, you can return a string that represents a date, but use codaType: ValueType.Date to tell Coda to interpret as a date in a document. If your formula returns an object, you must provide a schema property that describes the structure of the object. See makeObjectSchema for how to construct an object schema. If your formula returns a list (array), you must provide an items property that describes what the elements of the array are. This could be a simple schema like {type: ValueType.String} indicating that the array elements are all just strings, or it could be an object schema created using makeObjectSchema if the elements are objects. example makeFormula({resultType: ValueType.String, name: 'Hello', ...}); example makeFormula({resultType: ValueType.String, codaType: ValueType.Html, name: 'HelloHtml', ...}); example makeFormula({resultType: ValueType.Array, items: {type: ValueType.String}, name: 'HelloStringArray', ...}); example makeFormula({ resultType: ValueType.Object, schema: makeObjectSchema({type: ValueType.Object, properties: {...}}), name: 'HelloObject', ... }); example makeFormula({ resultType: ValueType.Array, items: makeObjectSchema({type: ValueType.Object, properties: {...}}), name: 'HelloObjectArray', ... });","title":"Function: makeFormula"},{"location":"reference/sdk/functions/makeMetadataFormula/","text":"Function: makeMetadataFormula \u00b6 \u25b8 makeMetadataFormula ( execute , options? ): MetadataFormula Parameters \u00b6 Name Type execute MetadataFunction options? Object options.connectionRequirement? ConnectionRequirement Returns \u00b6 MetadataFormula Defined in \u00b6 api.ts:794","title":"Function: makeMetadataFormula"},{"location":"reference/sdk/functions/makeMetadataFormula/#function-makemetadataformula","text":"\u25b8 makeMetadataFormula ( execute , options? ): MetadataFormula","title":"Function: makeMetadataFormula"},{"location":"reference/sdk/functions/makeObjectSchema/","text":"Function: makeObjectSchema \u00b6 \u25b8 makeObjectSchema < K , L , T >( schemaDef ): T & { identity? : Identity } Type parameters \u00b6 Name Type K extends string L extends string T extends ObjectSchemaDefinition < K , L , T > Parameters \u00b6 Name Type schemaDef T Returns \u00b6 T & { identity? : Identity } Defined in \u00b6 schema.ts:735","title":"Function: makeObjectSchema"},{"location":"reference/sdk/functions/makeObjectSchema/#function-makeobjectschema","text":"\u25b8 makeObjectSchema < K , L , T >( schemaDef ): T & { identity? : Identity }","title":"Function: makeObjectSchema"},{"location":"reference/sdk/functions/makeParameter/","text":"Function: makeParameter \u00b6 \u25b8 makeParameter < T >( paramDefinition ): ParamDef < ParameterTypeMap [ T ]> Create a definition for a parameter for a formula or sync. example makeParameter({type: ParameterType.String, name: 'myParam', description: 'My description'}); example makeParameter({type: ParameterType.StringArray, name: 'myArrayParam', description: 'My description'}); Type parameters \u00b6 Name Type T extends ParameterType Parameters \u00b6 Name Type paramDefinition ParameterOptions < T > Returns \u00b6 ParamDef < ParameterTypeMap [ T ]> Defined in \u00b6 api.ts:270","title":"Function: makeParameter"},{"location":"reference/sdk/functions/makeParameter/#function-makeparameter","text":"\u25b8 makeParameter < T >( paramDefinition ): ParamDef < ParameterTypeMap [ T ]> Create a definition for a parameter for a formula or sync. example makeParameter({type: ParameterType.String, name: 'myParam', description: 'My description'}); example makeParameter({type: ParameterType.StringArray, name: 'myArrayParam', description: 'My description'});","title":"Function: makeParameter"},{"location":"reference/sdk/functions/makeReferenceSchemaFromObjectSchema/","text":"Function: makeReferenceSchemaFromObjectSchema \u00b6 \u25b8 makeReferenceSchemaFromObjectSchema ( schema , identityName? ): GenericObjectSchema Convenience for creating a reference object schema from an existing schema for the object. Copies over the identity, id, and primary from the schema, and the subset of properties indicated by the id and primary. A reference schema can always be defined directly, but if you already have an object schema it provides better code reuse to derive a reference schema instead. Parameters \u00b6 Name Type schema GenericObjectSchema identityName? string Returns \u00b6 GenericObjectSchema Defined in \u00b6 schema.ts:835","title":"Function: makeReferenceSchemaFromObjectSchema"},{"location":"reference/sdk/functions/makeReferenceSchemaFromObjectSchema/#function-makereferenceschemafromobjectschema","text":"\u25b8 makeReferenceSchemaFromObjectSchema ( schema , identityName? ): GenericObjectSchema Convenience for creating a reference object schema from an existing schema for the object. Copies over the identity, id, and primary from the schema, and the subset of properties indicated by the id and primary. A reference schema can always be defined directly, but if you already have an object schema it provides better code reuse to derive a reference schema instead.","title":"Function: makeReferenceSchemaFromObjectSchema"},{"location":"reference/sdk/functions/makeSchema/","text":"Function: makeSchema \u00b6 \u25b8 makeSchema < T >( schema ): T Type parameters \u00b6 Name Type T extends Schema Parameters \u00b6 Name Type schema T Returns \u00b6 T Defined in \u00b6 schema.ts:729","title":"Function: makeSchema"},{"location":"reference/sdk/functions/makeSchema/#function-makeschema","text":"\u25b8 makeSchema < T >( schema ): T","title":"Function: makeSchema"},{"location":"reference/sdk/functions/makeSimpleAutocompleteMetadataFormula/","text":"Function: makeSimpleAutocompleteMetadataFormula \u00b6 \u25b8 makeSimpleAutocompleteMetadataFormula ( options ): MetadataFormula deprecated If you have a hardcoded array of autocomplete options, simply include that array as the value of the autocomplete property in your parameter definition. There is no longer any needed to wrap a value with this formula. Parameters \u00b6 Name Type options ( string | number | SimpleAutocompleteOption )[] Returns \u00b6 MetadataFormula Defined in \u00b6 api.ts:905","title":"Function: makeSimpleAutocompleteMetadataFormula"},{"location":"reference/sdk/functions/makeSimpleAutocompleteMetadataFormula/#function-makesimpleautocompletemetadataformula","text":"\u25b8 makeSimpleAutocompleteMetadataFormula ( options ): MetadataFormula deprecated If you have a hardcoded array of autocomplete options, simply include that array as the value of the autocomplete property in your parameter definition. There is no longer any needed to wrap a value with this formula.","title":"Function: makeSimpleAutocompleteMetadataFormula"},{"location":"reference/sdk/functions/makeSyncTable/","text":"Function: makeSyncTable \u00b6 \u25b8 makeSyncTable < K , L , ParamDefsT , SchemaDefT , SchemaT >( __namedParameters ): SyncTableDef < K , L , ParamDefsT , SchemaT > Wrapper to produce a sync table definition. All (non-dynamic) sync tables should be created using this wrapper rather than declaring a sync table definition object directly. This wrapper does a variety of helpful things, including * Doing basic validation of the provided definition. * Normalizing the schema definition to conform to Coda-recommended syntax. * Wrapping the execute formula to normalize return values to match the normalized schema. See Normalization for more information about schema normalization. Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaDefT extends ObjectSchemaDefinition < K , L , SchemaDefT > SchemaT extends ObjectSchemaDefinition < K , L , SchemaT > & { identity? : Identity } Parameters \u00b6 Name Type __namedParameters SyncTableOptions < K , L , ParamDefsT , SchemaDefT > Returns \u00b6 SyncTableDef < K , L , ParamDefsT , SchemaT > Defined in \u00b6 api.ts:1084","title":"Function: makeSyncTable"},{"location":"reference/sdk/functions/makeSyncTable/#function-makesynctable","text":"\u25b8 makeSyncTable < K , L , ParamDefsT , SchemaDefT , SchemaT >( __namedParameters ): SyncTableDef < K , L , ParamDefsT , SchemaT > Wrapper to produce a sync table definition. All (non-dynamic) sync tables should be created using this wrapper rather than declaring a sync table definition object directly. This wrapper does a variety of helpful things, including * Doing basic validation of the provided definition. * Normalizing the schema definition to conform to Coda-recommended syntax. * Wrapping the execute formula to normalize return values to match the normalized schema. See Normalization for more information about schema normalization.","title":"Function: makeSyncTable"},{"location":"reference/sdk/functions/makeTranslateObjectFormula/","text":"Function: makeTranslateObjectFormula \u00b6 \u25b8 makeTranslateObjectFormula < ParamDefsT , ResultT >( __namedParameters ): { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < SchemaType < ResultT >> ; resultType : object ; schema : undefined | ResultT = response.schema } Helper to generate a formula that fetches a list of entities from a given URL and returns them. One of the simplest but most common use cases for a pack formula is to make a request to an API endpoint that returns a list of objects, and then return those objects either as-is or with slight transformations. The can be accomplished with an execute function that does exactly that, but alternatively you could use makeTranslateObjectFormula and an execute implementation will be generated for you. example `` makeTranslateObjectFormula({ name: \"Users\", description: \"Returns a list of users.\" // This will generate an execute function that makes a GET request to the given URL. request: { method: 'GET', url: 'https://api.example.com/users', }, response: { // Suppose the response body has the form , { ...user2 }]} . // This \"projection\" key tells the execute function that the list of results to return // can be found in the object property users`. If omitted, the response body itself // should be the list of results. projectKey: 'users', schema: UserSchema, }, }); Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs ResultT extends Schema Parameters \u00b6 Name Type __namedParameters ObjectArrayFormulaDef < ParamDefsT , ResultT > Returns \u00b6 { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < SchemaType < ResultT >> ; resultType : object ; schema : undefined | ResultT = response.schema } Defined in \u00b6 api.ts:1245","title":"Function: makeTranslateObjectFormula"},{"location":"reference/sdk/functions/makeTranslateObjectFormula/#function-maketranslateobjectformula","text":"\u25b8 makeTranslateObjectFormula < ParamDefsT , ResultT >( __namedParameters ): { cacheTtlSecs? : number ; connectionRequirement? : ConnectionRequirement ; description : string ; examples? : { params : PackFormulaValue [] ; result : PackFormulaResult }[] ; extraOAuthScopes? : string [] ; isAction? : boolean ; isExperimental? : boolean ; isSystem? : boolean ; name : string ; network? : Network ; parameters : ParamDefsT ; varargParameters? : ParamDefs } & { execute : ( params : ParamValues < ParamDefsT >, context : ExecutionContext ) => Promise < SchemaType < ResultT >> ; resultType : object ; schema : undefined | ResultT = response.schema } Helper to generate a formula that fetches a list of entities from a given URL and returns them. One of the simplest but most common use cases for a pack formula is to make a request to an API endpoint that returns a list of objects, and then return those objects either as-is or with slight transformations. The can be accomplished with an execute function that does exactly that, but alternatively you could use makeTranslateObjectFormula and an execute implementation will be generated for you. example `` makeTranslateObjectFormula({ name: \"Users\", description: \"Returns a list of users.\" // This will generate an execute function that makes a GET request to the given URL. request: { method: 'GET', url: 'https://api.example.com/users', }, response: { // Suppose the response body has the form , { ...user2 }]} . // This \"projection\" key tells the execute function that the list of results to return // can be found in the object property users`. If omitted, the response body itself // should be the list of results. projectKey: 'users', schema: UserSchema, }, });","title":"Function: makeTranslateObjectFormula"},{"location":"reference/sdk/functions/newPack/","text":"Function: newPack \u00b6 \u25b8 newPack ( definition? ): PackDefinitionBuilder Creates a new skeleton pack definition that can be added to. example export const pack = newPack(); pack.addFormula({resultType: ValueType.String, name: 'MyFormula', ...}); pack.addSyncTable('MyTable', ...); pack.setUserAuthentication({type: AuthenticationType.HeaderBearerToken}); Parameters \u00b6 Name Type definition? Partial < PackVersionDefinition > Returns \u00b6 PackDefinitionBuilder Defined in \u00b6 builder.ts:38","title":"Function: newPack"},{"location":"reference/sdk/functions/newPack/#function-newpack","text":"\u25b8 newPack ( definition? ): PackDefinitionBuilder Creates a new skeleton pack definition that can be added to. example export const pack = newPack(); pack.addFormula({resultType: ValueType.String, name: 'MyFormula', ...}); pack.addSyncTable('MyTable', ...); pack.setUserAuthentication({type: AuthenticationType.HeaderBearerToken});","title":"Function: newPack"},{"location":"reference/sdk/functions/simpleAutocomplete/","text":"Function: simpleAutocomplete \u00b6 \u25b8 simpleAutocomplete ( search , options ): Promise < MetadataFormulaObjectResultType []> Parameters \u00b6 Name Type search undefined | string options ( string | number | SimpleAutocompleteOption )[] Returns \u00b6 Promise < MetadataFormulaObjectResultType []> Defined in \u00b6 api.ts:826","title":"Function: simpleAutocomplete"},{"location":"reference/sdk/functions/simpleAutocomplete/#function-simpleautocomplete","text":"\u25b8 simpleAutocomplete ( search , options ): Promise < MetadataFormulaObjectResultType []>","title":"Function: simpleAutocomplete"},{"location":"reference/sdk/functions/withQueryParams/","text":"Function: withQueryParams \u00b6 \u25b8 withQueryParams ( url , params? ): string Helper to create a new URL by appending parameters to a base URL. The input URL may or may not having existing parameters. example // Returns `\"/someApi/someEndpoint?token=asdf&limit=5\"` let url = withQueryParams(\"/someApi/someEndpoint\", {token: \"asdf\", limit: 5}); Parameters \u00b6 Name Type url string params? Object Returns \u00b6 string Defined in \u00b6 helpers/url.ts:16","title":"Function: withQueryParams"},{"location":"reference/sdk/functions/withQueryParams/#function-withqueryparams","text":"\u25b8 withQueryParams ( url , params? ): string Helper to create a new URL by appending parameters to a base URL. The input URL may or may not having existing parameters. example // Returns `\"/someApi/someEndpoint?token=asdf&limit=5\"` let url = withQueryParams(\"/someApi/someEndpoint\", {token: \"asdf\", limit: 5});","title":"Function: withQueryParams"},{"location":"reference/sdk/interfaces/ArraySchema/","text":"Interface: ArraySchema<T> \u00b6 A schema representing a return value or object property that is an array (list) of items. The items are themselves schema definitions, which may refer to scalars or other objects. Type parameters \u00b6 Name Type T extends Schema Schema Hierarchy \u00b6 BaseSchema \u21b3 ArraySchema Properties \u00b6 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseSchema.description Defined in \u00b6 schema.ts:192 items \u00b6 \u2022 items : T A schema for the items of this array. Defined in \u00b6 schema.ts:530 type \u00b6 \u2022 type : Array Identifies this schema as an array. Defined in \u00b6 schema.ts:528","title":"Interface: ArraySchema<T\\>"},{"location":"reference/sdk/interfaces/ArraySchema/#interface-arrayschemat","text":"A schema representing a return value or object property that is an array (list) of items. The items are themselves schema definitions, which may refer to scalars or other objects.","title":"Interface: ArraySchema&lt;T>"},{"location":"reference/sdk/interfaces/ArraySchema/#type-parameters","text":"Name Type T extends Schema Schema","title":"Type parameters"},{"location":"reference/sdk/interfaces/ArraySchema/#hierarchy","text":"BaseSchema \u21b3 ArraySchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/ArraySchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ArraySchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/ArraySchema/#items","text":"\u2022 items : T A schema for the items of this array.","title":"items"},{"location":"reference/sdk/interfaces/ArraySchema/#type","text":"\u2022 type : Array Identifies this schema as an array.","title":"type"},{"location":"reference/sdk/interfaces/ArrayType/","text":"Interface: ArrayType<T> \u00b6 Type parameters \u00b6 Name Type T extends Type Properties \u00b6 items \u00b6 \u2022 items : T Defined in \u00b6 api_types.ts:28 type \u00b6 \u2022 type : \"array\" Defined in \u00b6 api_types.ts:27","title":"Interface: ArrayType<T\\>"},{"location":"reference/sdk/interfaces/ArrayType/#interface-arraytypet","text":"","title":"Interface: ArrayType&lt;T>"},{"location":"reference/sdk/interfaces/ArrayType/#type-parameters","text":"Name Type T extends Type","title":"Type parameters"},{"location":"reference/sdk/interfaces/ArrayType/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ArrayType/#items","text":"\u2022 items : T","title":"items"},{"location":"reference/sdk/interfaces/ArrayType/#type","text":"\u2022 type : \"array\"","title":"type"},{"location":"reference/sdk/interfaces/BooleanSchema/","text":"Interface: BooleanSchema \u00b6 A schema representing a return value or object property that is a boolean. Hierarchy \u00b6 BaseSchema \u21b3 BooleanSchema Properties \u00b6 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseSchema.description Defined in \u00b6 schema.ts:192 type \u00b6 \u2022 type : Boolean Identifies this schema as relating to a boolean value. Defined in \u00b6 schema.ts:200","title":"Interface: BooleanSchema"},{"location":"reference/sdk/interfaces/BooleanSchema/#interface-booleanschema","text":"A schema representing a return value or object property that is a boolean.","title":"Interface: BooleanSchema"},{"location":"reference/sdk/interfaces/BooleanSchema/#hierarchy","text":"BaseSchema \u21b3 BooleanSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/BooleanSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/BooleanSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/BooleanSchema/#type","text":"\u2022 type : Boolean Identifies this schema as relating to a boolean value.","title":"type"},{"location":"reference/sdk/interfaces/Continuation/","text":"Interface: Continuation \u00b6 Container for arbitrary data about which page of data to retrieve in this sync invocation. Sync formulas fetch one reasonable size \"page\" of data per invocation such that the formula can be invoked quickly. The end result of a sync is the concatenation of the results from each individual invocation. To instruct the syncer to fetch a subsequent result page, return a Continuation that describes which page of results to fetch next. The continuation will be passed verbatim as an input to the subsequent invocation of the sync formula. The contents of this object are entirely up to the pack author. Examples: {nextPage: 3} {nextPageUrl: 'https://someapi.com/api/items?pageToken=asdf123'} Indexable \u00b6 \u25aa [key: string ]: string | number","title":"Interface: Continuation"},{"location":"reference/sdk/interfaces/Continuation/#interface-continuation","text":"Container for arbitrary data about which page of data to retrieve in this sync invocation. Sync formulas fetch one reasonable size \"page\" of data per invocation such that the formula can be invoked quickly. The end result of a sync is the concatenation of the results from each individual invocation. To instruct the syncer to fetch a subsequent result page, return a Continuation that describes which page of results to fetch next. The continuation will be passed verbatim as an input to the subsequent invocation of the sync formula. The contents of this object are entirely up to the pack author. Examples: {nextPage: 3} {nextPageUrl: 'https://someapi.com/api/items?pageToken=asdf123'}","title":"Interface: Continuation"},{"location":"reference/sdk/interfaces/Continuation/#indexable","text":"\u25aa [key: string ]: string | number","title":"Indexable"},{"location":"reference/sdk/interfaces/CurrencySchema/","text":"Interface: CurrencySchema \u00b6 A schema representing a return value or object property that is an amount of currency. Hierarchy \u00b6 BaseNumberSchema < Currency > \u21b3 CurrencySchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Currency Instructs Coda to render this value as a currency amount. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:321 currencyCode \u00b6 \u2022 Optional currencyCode : string A three-letter ISO 4217 currency code, e.g. USD or EUR. If the currency code is not supported by Coda, the value will be rendered using USD. Defined in \u00b6 schema.ts:328 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 format \u00b6 \u2022 Optional format : CurrencyFormat A render format for further refining how the value is rendered. Defined in \u00b6 schema.ts:330 precision \u00b6 \u2022 Optional precision : number The decimal precision. The value is rounded to this precision when rendered. Defined in \u00b6 schema.ts:323 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: CurrencySchema"},{"location":"reference/sdk/interfaces/CurrencySchema/#interface-currencyschema","text":"A schema representing a return value or object property that is an amount of currency.","title":"Interface: CurrencySchema"},{"location":"reference/sdk/interfaces/CurrencySchema/#hierarchy","text":"BaseNumberSchema < Currency > \u21b3 CurrencySchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/CurrencySchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/CurrencySchema/#codatype","text":"\u2022 codaType : Currency Instructs Coda to render this value as a currency amount.","title":"codaType"},{"location":"reference/sdk/interfaces/CurrencySchema/#currencycode","text":"\u2022 Optional currencyCode : string A three-letter ISO 4217 currency code, e.g. USD or EUR. If the currency code is not supported by Coda, the value will be rendered using USD.","title":"currencyCode"},{"location":"reference/sdk/interfaces/CurrencySchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/CurrencySchema/#format","text":"\u2022 Optional format : CurrencyFormat A render format for further refining how the value is rendered.","title":"format"},{"location":"reference/sdk/interfaces/CurrencySchema/#precision","text":"\u2022 Optional precision : number The decimal precision. The value is rounded to this precision when rendered.","title":"precision"},{"location":"reference/sdk/interfaces/CurrencySchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/DurationSchema/","text":"Interface: DurationSchema \u00b6 A schema representing a return value or object property that represents a duration. The value should be provided as a string like \"3 days\" or \"40 minutes 30 seconds\". Hierarchy \u00b6 BaseStringSchema < Duration > \u21b3 DurationSchema Properties \u00b6 codaType \u00b6 \u2022 Optional codaType : Duration An optional type hint instructing Coda about how to interpret or render this value. Inherited from \u00b6 BaseStringSchema.codaType Defined in \u00b6 schema.ts:495 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseStringSchema.description Defined in \u00b6 schema.ts:192 maxUnit \u00b6 \u2022 Optional maxUnit : DurationUnit The unit to use for rounding the duration when rendering. For example, if using DurationUnit.Days , and a value of \"3 days 4 hours\" is provided, it will be rendered as \"3 days\". Defined in \u00b6 schema.ts:488 precision \u00b6 \u2022 Optional precision : number A refinement of maxUnit to use for rounding the duration when rendering. Currently only 1 is supported, which is the same as omitting a value. Defined in \u00b6 schema.ts:483 type \u00b6 \u2022 type : String Identifies this schema as a string. Inherited from \u00b6 BaseStringSchema.type Defined in \u00b6 schema.ts:493","title":"Interface: DurationSchema"},{"location":"reference/sdk/interfaces/DurationSchema/#interface-durationschema","text":"A schema representing a return value or object property that represents a duration. The value should be provided as a string like \"3 days\" or \"40 minutes 30 seconds\".","title":"Interface: DurationSchema"},{"location":"reference/sdk/interfaces/DurationSchema/#hierarchy","text":"BaseStringSchema < Duration > \u21b3 DurationSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/DurationSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/DurationSchema/#codatype","text":"\u2022 Optional codaType : Duration An optional type hint instructing Coda about how to interpret or render this value.","title":"codaType"},{"location":"reference/sdk/interfaces/DurationSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/DurationSchema/#maxunit","text":"\u2022 Optional maxUnit : DurationUnit The unit to use for rounding the duration when rendering. For example, if using DurationUnit.Days , and a value of \"3 days 4 hours\" is provided, it will be rendered as \"3 days\".","title":"maxUnit"},{"location":"reference/sdk/interfaces/DurationSchema/#precision","text":"\u2022 Optional precision : number A refinement of maxUnit to use for rounding the duration when rendering. Currently only 1 is supported, which is the same as omitting a value.","title":"precision"},{"location":"reference/sdk/interfaces/DurationSchema/#type","text":"\u2022 type : String Identifies this schema as a string.","title":"type"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/","text":"Interface: DynamicSyncTableDef<K, L, ParamDefsT, SchemaT> \u00b6 Type definition for a Dynamic Sync Table. Should not be necessary to use directly, instead, define dynamic sync tables using makeDynamicSyncTable . Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchema < K , L > Hierarchy \u00b6 SyncTableDef < K , L , ParamDefsT , SchemaT > \u21b3 DynamicSyncTableDef Properties \u00b6 entityName \u00b6 \u2022 Optional entityName : string Inherited from \u00b6 SyncTableDef . entityName Defined in \u00b6 api.ts:155 getDisplayUrl \u00b6 \u2022 getDisplayUrl : MetadataFormula Defined in \u00b6 api.ts:171 getName \u00b6 \u2022 getName : MetadataFormula Defined in \u00b6 api.ts:170 getSchema \u00b6 \u2022 getSchema : MetadataFormula Overrides \u00b6 SyncTableDef . getSchema Defined in \u00b6 api.ts:169 getter \u00b6 \u2022 getter : SyncFormula < K , L , ParamDefsT , SchemaT > Inherited from \u00b6 SyncTableDef . getter Defined in \u00b6 api.ts:153 isDynamic \u00b6 \u2022 isDynamic : true Defined in \u00b6 api.ts:168 listDynamicUrls \u00b6 \u2022 Optional listDynamicUrls : MetadataFormula Defined in \u00b6 api.ts:172 name \u00b6 \u2022 name : string Inherited from \u00b6 SyncTableDef . name Defined in \u00b6 api.ts:151 schema \u00b6 \u2022 schema : SchemaT Inherited from \u00b6 SyncTableDef . schema Defined in \u00b6 api.ts:152","title":"Interface: DynamicSyncTableDef<K, L, ParamDefsT, SchemaT\\>"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#interface-dynamicsynctabledefk-l-paramdefst-schemat","text":"Type definition for a Dynamic Sync Table. Should not be necessary to use directly, instead, define dynamic sync tables using makeDynamicSyncTable .","title":"Interface: DynamicSyncTableDef&lt;K, L, ParamDefsT, SchemaT>"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#type-parameters","text":"Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchema < K , L >","title":"Type parameters"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#hierarchy","text":"SyncTableDef < K , L , ParamDefsT , SchemaT > \u21b3 DynamicSyncTableDef","title":"Hierarchy"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#entityname","text":"\u2022 Optional entityName : string","title":"entityName"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#getdisplayurl","text":"\u2022 getDisplayUrl : MetadataFormula","title":"getDisplayUrl"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#getname","text":"\u2022 getName : MetadataFormula","title":"getName"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#getschema","text":"\u2022 getSchema : MetadataFormula","title":"getSchema"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#getter","text":"\u2022 getter : SyncFormula < K , L , ParamDefsT , SchemaT >","title":"getter"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#isdynamic","text":"\u2022 isDynamic : true","title":"isDynamic"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#listdynamicurls","text":"\u2022 Optional listDynamicUrls : MetadataFormula","title":"listDynamicUrls"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#name","text":"\u2022 name : string","title":"name"},{"location":"reference/sdk/interfaces/DynamicSyncTableDef/#schema","text":"\u2022 schema : SchemaT","title":"schema"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/","text":"Interface: EmptyFormulaDef<ParamsT> \u00b6 Type parameters \u00b6 Name Type ParamsT extends ParamDefs Hierarchy \u00b6 Omit < PackFormulaDef < ParamsT , string >, \"execute\" > \u21b3 EmptyFormulaDef Properties \u00b6 cacheTtlSecs \u00b6 \u2022 Optional Readonly cacheTtlSecs : number How long formulas running with the same values should cache their results for. Inherited from \u00b6 Omit.cacheTtlSecs Defined in \u00b6 api_types.ts:286 connectionRequirement \u00b6 \u2022 Optional Readonly connectionRequirement : ConnectionRequirement Does this formula require a connection (aka an account)? Inherited from \u00b6 Omit.connectionRequirement Defined in \u00b6 api_types.ts:278 description \u00b6 \u2022 Readonly description : string A brief description of what the formula does. Inherited from \u00b6 Omit.description Defined in \u00b6 api_types.ts:252 examples \u00b6 \u2022 Optional Readonly examples : { params : PackFormulaValue [] ; result : PackFormulaResult }[] Sample inputs and outputs demonstrating usage of this formula. Inherited from \u00b6 Omit.examples Defined in \u00b6 api_types.ts:267 extraOAuthScopes \u00b6 \u2022 Optional Readonly extraOAuthScopes : string [] OAuth scopes that the formula needs that weren't requested in the pack's overall authentication config. For example, a Slack pack can have one formula that needs admin privileges, but non-admins can use the bulk of the pack without those privileges. Coda will give users help in understanding that they need additional authentication to use a formula with extra OAuth scopes. Note that these scopes will always be requested in addition to the default scopes for the pack, so an end user must have both sets of permissions. Inherited from \u00b6 Omit.extraOAuthScopes Defined in \u00b6 api_types.ts:308 isAction \u00b6 \u2022 Optional Readonly isAction : boolean Does this formula take an action (vs retrieve data or make a calculation)? Actions are presented as buttons in the Coda UI. Inherited from \u00b6 Omit.isAction Defined in \u00b6 api_types.ts:273 isExperimental \u00b6 \u2022 Optional Readonly isExperimental : boolean If specified, the formula will not be suggested to users in Coda's formula autocomplete. The formula can still be invoked by manually typing its full name. Inherited from \u00b6 Omit.isExperimental Defined in \u00b6 api_types.ts:292 isSystem \u00b6 \u2022 Optional Readonly isSystem : boolean Whether this is a formula that will be used by Coda internally and not exposed directly to users. Not for use by packs that are not authored by Coda. Inherited from \u00b6 Omit.isSystem Defined in \u00b6 api_types.ts:298 name \u00b6 \u2022 Readonly name : string The name of the formula, used to invoke it. Inherited from \u00b6 Omit.name Defined in \u00b6 api_types.ts:247 network \u00b6 \u2022 Optional Readonly network : Network deprecated use isAction and connectionRequirement instead Inherited from \u00b6 Omit.network Defined in \u00b6 api_types.ts:281 parameters \u00b6 \u2022 Readonly parameters : ParamsT The parameter inputs to the formula, if any. Inherited from \u00b6 Omit.parameters Defined in \u00b6 api_types.ts:257 request \u00b6 \u2022 request : RequestHandlerTemplate Defined in \u00b6 api.ts:420 varargParameters \u00b6 \u2022 Optional Readonly varargParameters : ParamDefs Variable argument parameters, used if this formula should accept arbitrary numbers of inputs. Inherited from \u00b6 Omit.varargParameters Defined in \u00b6 api_types.ts:262","title":"Interface: EmptyFormulaDef<ParamsT\\>"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#interface-emptyformuladefparamst","text":"","title":"Interface: EmptyFormulaDef&lt;ParamsT>"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#type-parameters","text":"Name Type ParamsT extends ParamDefs","title":"Type parameters"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#hierarchy","text":"Omit < PackFormulaDef < ParamsT , string >, \"execute\" > \u21b3 EmptyFormulaDef","title":"Hierarchy"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#cachettlsecs","text":"\u2022 Optional Readonly cacheTtlSecs : number How long formulas running with the same values should cache their results for.","title":"cacheTtlSecs"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#connectionrequirement","text":"\u2022 Optional Readonly connectionRequirement : ConnectionRequirement Does this formula require a connection (aka an account)?","title":"connectionRequirement"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#description","text":"\u2022 Readonly description : string A brief description of what the formula does.","title":"description"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#examples","text":"\u2022 Optional Readonly examples : { params : PackFormulaValue [] ; result : PackFormulaResult }[] Sample inputs and outputs demonstrating usage of this formula.","title":"examples"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#extraoauthscopes","text":"\u2022 Optional Readonly extraOAuthScopes : string [] OAuth scopes that the formula needs that weren't requested in the pack's overall authentication config. For example, a Slack pack can have one formula that needs admin privileges, but non-admins can use the bulk of the pack without those privileges. Coda will give users help in understanding that they need additional authentication to use a formula with extra OAuth scopes. Note that these scopes will always be requested in addition to the default scopes for the pack, so an end user must have both sets of permissions.","title":"extraOAuthScopes"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#isaction","text":"\u2022 Optional Readonly isAction : boolean Does this formula take an action (vs retrieve data or make a calculation)? Actions are presented as buttons in the Coda UI.","title":"isAction"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#isexperimental","text":"\u2022 Optional Readonly isExperimental : boolean If specified, the formula will not be suggested to users in Coda's formula autocomplete. The formula can still be invoked by manually typing its full name.","title":"isExperimental"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#issystem","text":"\u2022 Optional Readonly isSystem : boolean Whether this is a formula that will be used by Coda internally and not exposed directly to users. Not for use by packs that are not authored by Coda.","title":"isSystem"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#name","text":"\u2022 Readonly name : string The name of the formula, used to invoke it.","title":"name"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#network","text":"\u2022 Optional Readonly network : Network deprecated use isAction and connectionRequirement instead","title":"network"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#parameters","text":"\u2022 Readonly parameters : ParamsT The parameter inputs to the formula, if any.","title":"parameters"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#request","text":"\u2022 request : RequestHandlerTemplate","title":"request"},{"location":"reference/sdk/interfaces/EmptyFormulaDef/#varargparameters","text":"\u2022 Optional Readonly varargParameters : ParamDefs Variable argument parameters, used if this formula should accept arbitrary numbers of inputs.","title":"varargParameters"},{"location":"reference/sdk/interfaces/ExecutionContext/","text":"Interface: ExecutionContext \u00b6 An object passed to the execute function of every formula invocation with information and utilities for handling the invocation. In particular, this contains the Fetcher , which is used for making HTTP requests. Hierarchy \u00b6 ExecutionContext \u21b3 SyncExecutionContext Properties \u00b6 endpoint \u00b6 \u2022 Optional Readonly endpoint : string The base endpoint URL for the user's account, only if applicable. See requiresEndpointUrl . If the API URLs are variable based on the user account, you will need this endpoint to construct URLs to use with the fetcher. Alternatively, you can use relative URLs (e.g. \"/api/entity\") and Coda will include the endpoint for you automatically. Defined in \u00b6 api_types.ts:557 fetcher \u00b6 \u2022 Readonly fetcher : Fetcher The Fetcher used for making HTTP requests. Defined in \u00b6 api_types.ts:544 invocationLocation \u00b6 \u2022 Readonly invocationLocation : InvocationLocation Information about the Coda environment and doc this formula was invoked from. This is mostly for Coda internal use and we do not recommend relying on it. Defined in \u00b6 api_types.ts:562 invocationToken \u00b6 \u2022 Readonly invocationToken : string A random token scoped to only this request invocation. This is a unique identifier for the invocation, and in particular used with {@link AuthenticationType.Custom} for naming template parameters that will be replaced by the fetcher in secure way. Defined in \u00b6 api_types.ts:573 sync \u00b6 \u2022 Optional Readonly sync : Sync Information about state of the current sync. Only populated if this is a sync table formula. Defined in \u00b6 api_types.ts:577 temporaryBlobStorage \u00b6 \u2022 Readonly temporaryBlobStorage : TemporaryBlobStorage A utility to fetch and store files and images that either require the pack user's authentication or are too large to return inline. See TemporaryBlobStorage . Defined in \u00b6 api_types.ts:549 timezone \u00b6 \u2022 Readonly timezone : string The timezone of the doc from which this formula was invoked. Defined in \u00b6 api_types.ts:566","title":"Interface: ExecutionContext"},{"location":"reference/sdk/interfaces/ExecutionContext/#interface-executioncontext","text":"An object passed to the execute function of every formula invocation with information and utilities for handling the invocation. In particular, this contains the Fetcher , which is used for making HTTP requests.","title":"Interface: ExecutionContext"},{"location":"reference/sdk/interfaces/ExecutionContext/#hierarchy","text":"ExecutionContext \u21b3 SyncExecutionContext","title":"Hierarchy"},{"location":"reference/sdk/interfaces/ExecutionContext/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ExecutionContext/#endpoint","text":"\u2022 Optional Readonly endpoint : string The base endpoint URL for the user's account, only if applicable. See requiresEndpointUrl . If the API URLs are variable based on the user account, you will need this endpoint to construct URLs to use with the fetcher. Alternatively, you can use relative URLs (e.g. \"/api/entity\") and Coda will include the endpoint for you automatically.","title":"endpoint"},{"location":"reference/sdk/interfaces/ExecutionContext/#fetcher","text":"\u2022 Readonly fetcher : Fetcher The Fetcher used for making HTTP requests.","title":"fetcher"},{"location":"reference/sdk/interfaces/ExecutionContext/#invocationlocation","text":"\u2022 Readonly invocationLocation : InvocationLocation Information about the Coda environment and doc this formula was invoked from. This is mostly for Coda internal use and we do not recommend relying on it.","title":"invocationLocation"},{"location":"reference/sdk/interfaces/ExecutionContext/#invocationtoken","text":"\u2022 Readonly invocationToken : string A random token scoped to only this request invocation. This is a unique identifier for the invocation, and in particular used with {@link AuthenticationType.Custom} for naming template parameters that will be replaced by the fetcher in secure way.","title":"invocationToken"},{"location":"reference/sdk/interfaces/ExecutionContext/#sync","text":"\u2022 Optional Readonly sync : Sync Information about state of the current sync. Only populated if this is a sync table formula.","title":"sync"},{"location":"reference/sdk/interfaces/ExecutionContext/#temporaryblobstorage","text":"\u2022 Readonly temporaryBlobStorage : TemporaryBlobStorage A utility to fetch and store files and images that either require the pack user's authentication or are too large to return inline. See TemporaryBlobStorage .","title":"temporaryBlobStorage"},{"location":"reference/sdk/interfaces/ExecutionContext/#timezone","text":"\u2022 Readonly timezone : string The timezone of the doc from which this formula was invoked.","title":"timezone"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/","text":"Interface: ExternalPackVersionMetadata \u00b6 Further stripped-down version of PackVersionMetadata that contains only what the browser needs. Hierarchy \u00b6 BasePackVersionMetadata \u21b3 ExternalPackVersionMetadata Properties \u00b6 authentication \u00b6 \u2022 authentication : Object Type declaration \u00b6 Name Type deferConnectionSetup? boolean endpointDomain? string params? { description : string ; name : string }[] postSetup? PostSetupMetadata [] requiresEndpointUrl boolean shouldAutoAuthSetup? boolean type AuthenticationType Defined in \u00b6 compiled_types.ts:96 formats \u00b6 \u2022 Optional formats : Format [] Defined in \u00b6 compiled_types.ts:109 formulaNamespace \u00b6 \u2022 Optional formulaNamespace : string deprecated Inherited from \u00b6 BasePackVersionMetadata.formulaNamespace Defined in \u00b6 types.ts:706 formulas \u00b6 \u2022 Optional formulas : ExternalPackFormulas Defined in \u00b6 compiled_types.ts:108 instructionsUrl \u00b6 \u2022 Optional instructionsUrl : string Defined in \u00b6 compiled_types.ts:105 networkDomains \u00b6 \u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval. Inherited from \u00b6 BasePackVersionMetadata.networkDomains Defined in \u00b6 types.ts:699 syncTables \u00b6 \u2022 Optional syncTables : PackSyncTable [] Defined in \u00b6 compiled_types.ts:110 version \u00b6 \u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version. Inherited from \u00b6 BasePackVersionMetadata.version Defined in \u00b6 types.ts:680","title":"Interface: ExternalPackVersionMetadata"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#interface-externalpackversionmetadata","text":"Further stripped-down version of PackVersionMetadata that contains only what the browser needs.","title":"Interface: ExternalPackVersionMetadata"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#hierarchy","text":"BasePackVersionMetadata \u21b3 ExternalPackVersionMetadata","title":"Hierarchy"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#authentication","text":"\u2022 authentication : Object","title":"authentication"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#formats","text":"\u2022 Optional formats : Format []","title":"formats"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#formulanamespace","text":"\u2022 Optional formulaNamespace : string deprecated","title":"formulaNamespace"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#formulas","text":"\u2022 Optional formulas : ExternalPackFormulas","title":"formulas"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#instructionsurl","text":"\u2022 Optional instructionsUrl : string","title":"instructionsUrl"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#networkdomains","text":"\u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval.","title":"networkDomains"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#synctables","text":"\u2022 Optional syncTables : PackSyncTable []","title":"syncTables"},{"location":"reference/sdk/interfaces/ExternalPackVersionMetadata/#version","text":"\u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version.","title":"version"},{"location":"reference/sdk/interfaces/FetchRequest/","text":"Interface: FetchRequest \u00b6 An HTTP request used with the Fetcher . The structure largely follows https://developer.mozilla.org/en-US/docs/Web/API/Request Properties \u00b6 body \u00b6 \u2022 Optional body : string The body of the HTTP request, if any. If you are sending a JSON payload, make sure to call JSON.stringify() on the object payload. Defined in \u00b6 api_types.ts:374 cacheTtlSecs \u00b6 \u2022 Optional cacheTtlSecs : number A time in seconds that Coda should cache the result of this HTTP request. Any time that this pack makes the same FetchRequest, a cached value can be returned instead of making the HTTP request. If left unspecified, Coda will automatically cache all GET requests for approximately 5 minutes. To disable the default caching, set this value to 0 . Defined in \u00b6 api_types.ts:391 disableAuthentication \u00b6 \u2022 Optional disableAuthentication : boolean If true, Coda will not apply authentication credentials even if this pack is configured to use authentication. This is very rare, but sometimes you may wish to make an unauthenticated supporting request as part of a formula implementation. Defined in \u00b6 api_types.ts:404 form \u00b6 \u2022 Optional form : Object Key-value form fields, if submitting to an endpoint expecting a URL-encoded form payload. Index signature \u00b6 \u25aa [key: string ]: string Defined in \u00b6 api_types.ts:378 headers \u00b6 \u2022 Optional headers : Object HTTP headers. You should NOT include authentication headers, as Coda will add them for you. Index signature \u00b6 \u25aa [header: string ]: string Defined in \u00b6 api_types.ts:382 isBinaryResponse \u00b6 \u2022 Optional isBinaryResponse : boolean Indicates that you expect the response to be binary data, instructing Coda not to attempt to parse the response in any way. Otherwise, Coda may attempt to parse the response as a JSON object. If true, FetchResponse.body will be a NodeJS Buffer. Defined in \u00b6 api_types.ts:398 method \u00b6 \u2022 method : \"GET\" | \"PATCH\" | \"POST\" | \"PUT\" | \"DELETE\" The HTTP method/verb (e.g. GET or POST). Defined in \u00b6 api_types.ts:361 url \u00b6 \u2022 url : string The URL to connect to. This is typically an absolute URL, but if your pack uses authentication and requiresEndpointUrl and so has a unique endpoint per user account, you may also use a relative URL and Coda will apply the user's endpoint automatically. Defined in \u00b6 api_types.ts:368","title":"Interface: FetchRequest"},{"location":"reference/sdk/interfaces/FetchRequest/#interface-fetchrequest","text":"An HTTP request used with the Fetcher . The structure largely follows https://developer.mozilla.org/en-US/docs/Web/API/Request","title":"Interface: FetchRequest"},{"location":"reference/sdk/interfaces/FetchRequest/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/FetchRequest/#body","text":"\u2022 Optional body : string The body of the HTTP request, if any. If you are sending a JSON payload, make sure to call JSON.stringify() on the object payload.","title":"body"},{"location":"reference/sdk/interfaces/FetchRequest/#cachettlsecs","text":"\u2022 Optional cacheTtlSecs : number A time in seconds that Coda should cache the result of this HTTP request. Any time that this pack makes the same FetchRequest, a cached value can be returned instead of making the HTTP request. If left unspecified, Coda will automatically cache all GET requests for approximately 5 minutes. To disable the default caching, set this value to 0 .","title":"cacheTtlSecs"},{"location":"reference/sdk/interfaces/FetchRequest/#disableauthentication","text":"\u2022 Optional disableAuthentication : boolean If true, Coda will not apply authentication credentials even if this pack is configured to use authentication. This is very rare, but sometimes you may wish to make an unauthenticated supporting request as part of a formula implementation.","title":"disableAuthentication"},{"location":"reference/sdk/interfaces/FetchRequest/#form","text":"\u2022 Optional form : Object Key-value form fields, if submitting to an endpoint expecting a URL-encoded form payload.","title":"form"},{"location":"reference/sdk/interfaces/FetchRequest/#headers","text":"\u2022 Optional headers : Object HTTP headers. You should NOT include authentication headers, as Coda will add them for you.","title":"headers"},{"location":"reference/sdk/interfaces/FetchRequest/#isbinaryresponse","text":"\u2022 Optional isBinaryResponse : boolean Indicates that you expect the response to be binary data, instructing Coda not to attempt to parse the response in any way. Otherwise, Coda may attempt to parse the response as a JSON object. If true, FetchResponse.body will be a NodeJS Buffer.","title":"isBinaryResponse"},{"location":"reference/sdk/interfaces/FetchRequest/#method","text":"\u2022 method : \"GET\" | \"PATCH\" | \"POST\" | \"PUT\" | \"DELETE\" The HTTP method/verb (e.g. GET or POST).","title":"method"},{"location":"reference/sdk/interfaces/FetchRequest/#url","text":"\u2022 url : string The URL to connect to. This is typically an absolute URL, but if your pack uses authentication and requiresEndpointUrl and so has a unique endpoint per user account, you may also use a relative URL and Coda will apply the user's endpoint automatically.","title":"url"},{"location":"reference/sdk/interfaces/FetchResponse/","text":"Interface: FetchResponse<T> \u00b6 The response of a call to Fetcher.fetch . The structure largely follows https://developer.mozilla.org/en-US/docs/Web/API/Response Type parameters \u00b6 Name Type T extends any``any Properties \u00b6 body \u00b6 \u2022 Optional body : T The body of the response. If the response contains JSON data, either because the Content-Type header is application/json or if the data is JSON-parseable, this will be a parsed JavaScript object. Similarly, if the response headers are text/xml or application/xml, this will be a parsed JavaScript object using the xml2js library. If implicit parsing is undesirable, you may consider using isBinaryResponse on the request to disable any parsing. Note however that this will result in the body being a NodeJS Buffer. Defined in \u00b6 api_types.ts:426 headers \u00b6 \u2022 headers : Object HTTP response headers. The contents of many headers will be redacted for security reasons. Index signature \u00b6 \u25aa [header: string ]: string | string [] | undefined Defined in \u00b6 api_types.ts:430 status \u00b6 \u2022 status : number The HTTP status code, e.g. 200 . Defined in \u00b6 api_types.ts:414","title":"Interface: FetchResponse<T\\>"},{"location":"reference/sdk/interfaces/FetchResponse/#interface-fetchresponset","text":"The response of a call to Fetcher.fetch . The structure largely follows https://developer.mozilla.org/en-US/docs/Web/API/Response","title":"Interface: FetchResponse&lt;T>"},{"location":"reference/sdk/interfaces/FetchResponse/#type-parameters","text":"Name Type T extends any``any","title":"Type parameters"},{"location":"reference/sdk/interfaces/FetchResponse/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/FetchResponse/#body","text":"\u2022 Optional body : T The body of the response. If the response contains JSON data, either because the Content-Type header is application/json or if the data is JSON-parseable, this will be a parsed JavaScript object. Similarly, if the response headers are text/xml or application/xml, this will be a parsed JavaScript object using the xml2js library. If implicit parsing is undesirable, you may consider using isBinaryResponse on the request to disable any parsing. Note however that this will result in the body being a NodeJS Buffer.","title":"body"},{"location":"reference/sdk/interfaces/FetchResponse/#headers","text":"\u2022 headers : Object HTTP response headers. The contents of many headers will be redacted for security reasons.","title":"headers"},{"location":"reference/sdk/interfaces/FetchResponse/#status","text":"\u2022 status : number The HTTP status code, e.g. 200 .","title":"status"},{"location":"reference/sdk/interfaces/Fetcher/","text":"Interface: Fetcher \u00b6 A utility that allows you to make HTTP requests from a pack. The fetcher also handles applying user authentication credentials to each request, if applicable. This is only way a pack is able to make HTTP requests, as using other libraries is unsupported. Methods \u00b6 fetch \u00b6 \u25b8 fetch < T >( request ): Promise < FetchResponse < T >> Makes an HTTP request. If authentication is used with this pack, the user's secret credentials will be automatically applied to the request (whether in the HTTP headers, as a URL parameter, or whatever the authentication type dictates). Your invocation of fetch() need not deal with authentication in any way, Coda will handle that entirely on your behalf. Type parameters \u00b6 Name Type T any Parameters \u00b6 Name Type request FetchRequest Returns \u00b6 Promise < FetchResponse < T >> Defined in \u00b6 api_types.ts:448","title":"Interface: Fetcher"},{"location":"reference/sdk/interfaces/Fetcher/#interface-fetcher","text":"A utility that allows you to make HTTP requests from a pack. The fetcher also handles applying user authentication credentials to each request, if applicable. This is only way a pack is able to make HTTP requests, as using other libraries is unsupported.","title":"Interface: Fetcher"},{"location":"reference/sdk/interfaces/Fetcher/#methods","text":"","title":"Methods"},{"location":"reference/sdk/interfaces/Fetcher/#fetch","text":"\u25b8 fetch < T >( request ): Promise < FetchResponse < T >> Makes an HTTP request. If authentication is used with this pack, the user's secret credentials will be automatically applied to the request (whether in the HTTP headers, as a URL parameter, or whatever the authentication type dictates). Your invocation of fetch() need not deal with authentication in any way, Coda will handle that entirely on your behalf.","title":"fetch"},{"location":"reference/sdk/interfaces/Format/","text":"Interface: Format \u00b6 Definition for a custom column type that users can apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a formula using that value, typically looking up data related to that value from a third-party API. For example, the Weather pack has a column format \"Current Weather\"; when applied to a column, if you type a city or address into a cell in that column, that location will be used as the input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell. A column format is just a wrapper around a formula defined in the formulas section of your pack definition. It tells Coda to execute that particular formula using the value of the cell as input. The formula referenced by a format must have exactly one required parameter. You may optionally specify one or more matchers , which are regular expressions that can be matched against values that users paste into table cells, to determine if this Format is applicable to that value. Matchers help users realize that there is a pack format that may augment their experience of working with such values. For example, if you're building a Wikipedia pack, you may write a matcher regular expression that looks for Wikipedia article URLs, if you have a formula that can fetch structured data given an article URL. This would help users discover that there is a pack that can fetch structured data given only a url. At present, matchers will only be run on URLs and not other text values. Properties \u00b6 formulaName \u00b6 \u2022 formulaName : string The name of the formula to invoke for values in columns using this format. This must correspond to the name of a regular, public formula defined in this pack. Defined in \u00b6 types.ts:580 formulaNamespace \u00b6 \u2022 formulaNamespace : string deprecated Namespaces are being removed from the product. Defined in \u00b6 types.ts:575 hasNoConnection \u00b6 \u2022 Optional hasNoConnection : boolean deprecated No longer needed, will be inferred from the referenced formula. Defined in \u00b6 types.ts:582 instructions \u00b6 \u2022 Optional instructions : string A brief, optional explanation of how users should use this format, for example, what kinds of values they should put in columns using this format. Defined in \u00b6 types.ts:587 matchers \u00b6 \u2022 Optional matchers : RegExp [] A list of regular expressions that match URLs that the formula implementing this format is capable of handling. As described in Format , this is a discovery mechanism. Defined in \u00b6 types.ts:592 name \u00b6 \u2022 name : string The name of this column format. This will show to users in the column type chooser. Defined in \u00b6 types.ts:573 placeholder \u00b6 \u2022 Optional placeholder : string deprecated Currently unused. Defined in \u00b6 types.ts:596","title":"Interface: Format"},{"location":"reference/sdk/interfaces/Format/#interface-format","text":"Definition for a custom column type that users can apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a formula using that value, typically looking up data related to that value from a third-party API. For example, the Weather pack has a column format \"Current Weather\"; when applied to a column, if you type a city or address into a cell in that column, that location will be used as the input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell. A column format is just a wrapper around a formula defined in the formulas section of your pack definition. It tells Coda to execute that particular formula using the value of the cell as input. The formula referenced by a format must have exactly one required parameter. You may optionally specify one or more matchers , which are regular expressions that can be matched against values that users paste into table cells, to determine if this Format is applicable to that value. Matchers help users realize that there is a pack format that may augment their experience of working with such values. For example, if you're building a Wikipedia pack, you may write a matcher regular expression that looks for Wikipedia article URLs, if you have a formula that can fetch structured data given an article URL. This would help users discover that there is a pack that can fetch structured data given only a url. At present, matchers will only be run on URLs and not other text values.","title":"Interface: Format"},{"location":"reference/sdk/interfaces/Format/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/Format/#formulaname","text":"\u2022 formulaName : string The name of the formula to invoke for values in columns using this format. This must correspond to the name of a regular, public formula defined in this pack.","title":"formulaName"},{"location":"reference/sdk/interfaces/Format/#formulanamespace","text":"\u2022 formulaNamespace : string deprecated Namespaces are being removed from the product.","title":"formulaNamespace"},{"location":"reference/sdk/interfaces/Format/#hasnoconnection","text":"\u2022 Optional hasNoConnection : boolean deprecated No longer needed, will be inferred from the referenced formula.","title":"hasNoConnection"},{"location":"reference/sdk/interfaces/Format/#instructions","text":"\u2022 Optional instructions : string A brief, optional explanation of how users should use this format, for example, what kinds of values they should put in columns using this format.","title":"instructions"},{"location":"reference/sdk/interfaces/Format/#matchers","text":"\u2022 Optional matchers : RegExp [] A list of regular expressions that match URLs that the formula implementing this format is capable of handling. As described in Format , this is a discovery mechanism.","title":"matchers"},{"location":"reference/sdk/interfaces/Format/#name","text":"\u2022 name : string The name of this column format. This will show to users in the column type chooser.","title":"name"},{"location":"reference/sdk/interfaces/Format/#placeholder","text":"\u2022 Optional placeholder : string deprecated Currently unused.","title":"placeholder"},{"location":"reference/sdk/interfaces/Identity/","text":"Interface: Identity \u00b6 Hierarchy \u00b6 IdentityDefinition \u21b3 Identity Properties \u00b6 attribution \u00b6 \u2022 Optional attribution : AttributionNode [] Attribution text, images, and/or links that should be rendered along with this value. See makeAttributionNode . Inherited from \u00b6 IdentityDefinition . attribution Defined in \u00b6 schema.ts:552 dynamicUrl \u00b6 \u2022 Optional dynamicUrl : string Inherited from \u00b6 IdentityDefinition . dynamicUrl Defined in \u00b6 schema.ts:546 name \u00b6 \u2022 name : string Inherited from \u00b6 IdentityDefinition . name Defined in \u00b6 schema.ts:545 packId \u00b6 \u2022 packId : number Overrides \u00b6 IdentityDefinition . packId Defined in \u00b6 schema.ts:558","title":"Interface: Identity"},{"location":"reference/sdk/interfaces/Identity/#interface-identity","text":"","title":"Interface: Identity"},{"location":"reference/sdk/interfaces/Identity/#hierarchy","text":"IdentityDefinition \u21b3 Identity","title":"Hierarchy"},{"location":"reference/sdk/interfaces/Identity/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/Identity/#attribution","text":"\u2022 Optional attribution : AttributionNode [] Attribution text, images, and/or links that should be rendered along with this value. See makeAttributionNode .","title":"attribution"},{"location":"reference/sdk/interfaces/Identity/#dynamicurl","text":"\u2022 Optional dynamicUrl : string","title":"dynamicUrl"},{"location":"reference/sdk/interfaces/Identity/#name","text":"\u2022 name : string","title":"name"},{"location":"reference/sdk/interfaces/Identity/#packid","text":"\u2022 packId : number","title":"packId"},{"location":"reference/sdk/interfaces/IdentityDefinition/","text":"Interface: IdentityDefinition \u00b6 Hierarchy \u00b6 IdentityDefinition \u21b3 Identity Properties \u00b6 attribution \u00b6 \u2022 Optional attribution : AttributionNode [] Attribution text, images, and/or links that should be rendered along with this value. See makeAttributionNode . Defined in \u00b6 schema.ts:552 dynamicUrl \u00b6 \u2022 Optional dynamicUrl : string Defined in \u00b6 schema.ts:546 name \u00b6 \u2022 name : string Defined in \u00b6 schema.ts:545 packId \u00b6 \u2022 Optional packId : number Defined in \u00b6 schema.ts:554","title":"Interface: IdentityDefinition"},{"location":"reference/sdk/interfaces/IdentityDefinition/#interface-identitydefinition","text":"","title":"Interface: IdentityDefinition"},{"location":"reference/sdk/interfaces/IdentityDefinition/#hierarchy","text":"IdentityDefinition \u21b3 Identity","title":"Hierarchy"},{"location":"reference/sdk/interfaces/IdentityDefinition/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/IdentityDefinition/#attribution","text":"\u2022 Optional attribution : AttributionNode [] Attribution text, images, and/or links that should be rendered along with this value. See makeAttributionNode .","title":"attribution"},{"location":"reference/sdk/interfaces/IdentityDefinition/#dynamicurl","text":"\u2022 Optional dynamicUrl : string","title":"dynamicUrl"},{"location":"reference/sdk/interfaces/IdentityDefinition/#name","text":"\u2022 name : string","title":"name"},{"location":"reference/sdk/interfaces/IdentityDefinition/#packid","text":"\u2022 Optional packId : number","title":"packId"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/","text":"Interface: MetadataFormulaObjectResultType \u00b6 The return type for a metadata formula that should return a different display to the user than is used internally. Properties \u00b6 display \u00b6 \u2022 display : string Defined in \u00b6 api.ts:769 hasChildren \u00b6 \u2022 Optional hasChildren : boolean Defined in \u00b6 api.ts:771 value \u00b6 \u2022 value : string | number Defined in \u00b6 api.ts:770","title":"Interface: MetadataFormulaObjectResultType"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/#interface-metadataformulaobjectresulttype","text":"The return type for a metadata formula that should return a different display to the user than is used internally.","title":"Interface: MetadataFormulaObjectResultType"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/#display","text":"\u2022 display : string","title":"display"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/#haschildren","text":"\u2022 Optional hasChildren : boolean","title":"hasChildren"},{"location":"reference/sdk/interfaces/MetadataFormulaObjectResultType/#value","text":"\u2022 value : string | number","title":"value"},{"location":"reference/sdk/interfaces/Network/","text":"Interface: Network \u00b6 deprecated use isAction and connectionRequirement on the formula definition instead. Properties \u00b6 connection \u00b6 \u2022 Optional Readonly connection : NetworkConnection Defined in \u00b6 api_types.ts:347 hasSideEffect \u00b6 \u2022 Optional Readonly hasSideEffect : boolean Defined in \u00b6 api_types.ts:345 requiresConnection \u00b6 \u2022 Optional Readonly requiresConnection : boolean Defined in \u00b6 api_types.ts:346","title":"Interface: Network"},{"location":"reference/sdk/interfaces/Network/#interface-network","text":"deprecated use isAction and connectionRequirement on the formula definition instead.","title":"Interface: Network"},{"location":"reference/sdk/interfaces/Network/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/Network/#connection","text":"\u2022 Optional Readonly connection : NetworkConnection","title":"connection"},{"location":"reference/sdk/interfaces/Network/#hassideeffect","text":"\u2022 Optional Readonly hasSideEffect : boolean","title":"hasSideEffect"},{"location":"reference/sdk/interfaces/Network/#requiresconnection","text":"\u2022 Optional Readonly requiresConnection : boolean","title":"requiresConnection"},{"location":"reference/sdk/interfaces/NumericDateSchema/","text":"Interface: NumericDateSchema \u00b6 A schema representing a return value or object property that is provided as a number, which Coda should interpret as a date. The given number should be in seconds since the Unix epoch. Hierarchy \u00b6 BaseNumberSchema < Date > \u21b3 NumericDateSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Date Instructs Coda to render this value as a date. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:241 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 format \u00b6 \u2022 Optional format : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:248 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: NumericDateSchema"},{"location":"reference/sdk/interfaces/NumericDateSchema/#interface-numericdateschema","text":"A schema representing a return value or object property that is provided as a number, which Coda should interpret as a date. The given number should be in seconds since the Unix epoch.","title":"Interface: NumericDateSchema"},{"location":"reference/sdk/interfaces/NumericDateSchema/#hierarchy","text":"BaseNumberSchema < Date > \u21b3 NumericDateSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/NumericDateSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/NumericDateSchema/#codatype","text":"\u2022 codaType : Date Instructs Coda to render this value as a date.","title":"codaType"},{"location":"reference/sdk/interfaces/NumericDateSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/NumericDateSchema/#format","text":"\u2022 Optional format : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"format"},{"location":"reference/sdk/interfaces/NumericDateSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/","text":"Interface: NumericDateTimeSchema \u00b6 A schema representing a return value or object property that is provided as a number, which Coda should interpret as a datetime. The given number should be in seconds since the Unix epoch. Hierarchy \u00b6 BaseNumberSchema < DateTime > \u21b3 NumericDateTimeSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : DateTime Instructs Coda to render this value as a datetime. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:274 dateFormat \u00b6 \u2022 Optional dateFormat : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:280 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 timeFormat \u00b6 \u2022 Optional timeFormat : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:287 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: NumericDateTimeSchema"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#interface-numericdatetimeschema","text":"A schema representing a return value or object property that is provided as a number, which Coda should interpret as a datetime. The given number should be in seconds since the Unix epoch.","title":"Interface: NumericDateTimeSchema"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#hierarchy","text":"BaseNumberSchema < DateTime > \u21b3 NumericDateTimeSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#codatype","text":"\u2022 codaType : DateTime Instructs Coda to render this value as a datetime.","title":"codaType"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#dateformat","text":"\u2022 Optional dateFormat : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format. Only applies when this is used as a sync table property.","title":"dateFormat"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#timeformat","text":"\u2022 Optional timeFormat : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"timeFormat"},{"location":"reference/sdk/interfaces/NumericDateTimeSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/NumericSchema/","text":"Interface: NumericSchema \u00b6 A schema representing a return value or object property that is a numeric value, i.e. a raw number with an optional decimal precision. Hierarchy \u00b6 BaseNumberSchema \u21b3 NumericSchema Properties \u00b6 codaType \u00b6 \u2022 Optional codaType : Percent If specified, instructs Coda to render this value as a percentage. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:228 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 precision \u00b6 \u2022 Optional precision : number The decimal precision. The number will be rounded to this precision when rendered. Defined in \u00b6 schema.ts:230 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217 useThousandsSeparator \u00b6 \u2022 Optional useThousandsSeparator : boolean If specified, will render thousands separators for large numbers, e.g. 1,234,567.89 . Defined in \u00b6 schema.ts:232","title":"Interface: NumericSchema"},{"location":"reference/sdk/interfaces/NumericSchema/#interface-numericschema","text":"A schema representing a return value or object property that is a numeric value, i.e. a raw number with an optional decimal precision.","title":"Interface: NumericSchema"},{"location":"reference/sdk/interfaces/NumericSchema/#hierarchy","text":"BaseNumberSchema \u21b3 NumericSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/NumericSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/NumericSchema/#codatype","text":"\u2022 Optional codaType : Percent If specified, instructs Coda to render this value as a percentage.","title":"codaType"},{"location":"reference/sdk/interfaces/NumericSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/NumericSchema/#precision","text":"\u2022 Optional precision : number The decimal precision. The number will be rounded to this precision when rendered.","title":"precision"},{"location":"reference/sdk/interfaces/NumericSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/NumericSchema/#usethousandsseparator","text":"\u2022 Optional useThousandsSeparator : boolean If specified, will render thousands separators for large numbers, e.g. 1,234,567.89 .","title":"useThousandsSeparator"},{"location":"reference/sdk/interfaces/NumericTimeSchema/","text":"Interface: NumericTimeSchema \u00b6 A schema representing a return value or object property that is provided as a number, which Coda should interpret as a time. The given number should be in seconds since the Unix epoch. While this is a full datetime, only the time component will be rendered, so the date used is irrelevant. Hierarchy \u00b6 BaseNumberSchema < Time > \u21b3 NumericTimeSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Time Instructs Coda to render this value as a time. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:258 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 format \u00b6 \u2022 Optional format : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:265 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: NumericTimeSchema"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#interface-numerictimeschema","text":"A schema representing a return value or object property that is provided as a number, which Coda should interpret as a time. The given number should be in seconds since the Unix epoch. While this is a full datetime, only the time component will be rendered, so the date used is irrelevant.","title":"Interface: NumericTimeSchema"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#hierarchy","text":"BaseNumberSchema < Time > \u21b3 NumericTimeSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#codatype","text":"\u2022 codaType : Time Instructs Coda to render this value as a time.","title":"codaType"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#format","text":"\u2022 Optional format : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"format"},{"location":"reference/sdk/interfaces/NumericTimeSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/OAuth2Authentication/","text":"Interface: OAuth2Authentication \u00b6 Authenticate using OAuth2. You must specify the authorization URL, token exchange URL, and scopes here as part of the pack definition. You'll provide the application's client ID and client secret in the pack management UI, so that these can be stored securely. The API must use a (largely) standards-compliant implementation of OAuth2. Hierarchy \u00b6 BaseAuthentication \u21b3 OAuth2Authentication Properties \u00b6 additionalParams \u00b6 \u2022 Optional additionalParams : Object Option custom URL parameters and values that should be included when redirecting the user to the authorizationUrl . Index signature \u00b6 \u25aa [key: string ]: any Defined in \u00b6 types.ts:367 authorizationUrl \u00b6 \u2022 authorizationUrl : string The URL to which the user will be redirected in order to authorize this pack. This is typically just a base url with no parameters. Coda will append the scope parameter automatically. If the authorization flow requires additional parameters, they may be specified using additionalParams . Defined in \u00b6 types.ts:342 defaultConnectionType \u00b6 \u2022 Optional defaultConnectionType : DefaultConnectionType Indicates the defualt manner in which a user's account is expected to be used by this pack, e.g. is this account used for retrieving data, taking actions, or both. See https://help.coda.io/en/articles/4587167-what-can-coda-access-with-packs#h_40472431f0 Inherited from \u00b6 BaseAuthentication.defaultConnectionType Defined in \u00b6 types.ts:207 endpointDomain \u00b6 \u2022 Optional endpointDomain : string When requiresEndpointUrl is set to true this should be the root domain that all endpoints share. For example, this value would be \"example.com\" if specific endpoints looked like {custom-subdomain}.example.com. For packs that make requests to multiple domains (uncommon), this should be the domain within networkDomains that this configuration applies to. Inherited from \u00b6 BaseAuthentication.endpointDomain Defined in \u00b6 types.ts:229 endpointKey \u00b6 \u2022 Optional endpointKey : string In rare cases, OAuth providers will return the specific API endpoint domain for the user as part of the OAuth token exchange response. If so, this is the property in the OAuth token exchange response JSON body that points to the endpoint. The endpoint will be saved along with the account and will be available during execution as ExecutionContext.endpoint . Defined in \u00b6 types.ts:377 getConnectionName \u00b6 \u2022 Optional getConnectionName : MetadataFormula Inherited from \u00b6 BaseAuthentication.getConnectionName Defined in \u00b6 types.ts:199 getConnectionUserId \u00b6 \u2022 Optional getConnectionUserId : MetadataFormula Inherited from \u00b6 BaseAuthentication.getConnectionUserId Defined in \u00b6 types.ts:200 instructionsUrl \u00b6 \u2022 Optional instructionsUrl : string A link to a help article or other page with more instructions about how to set up an account for this pack. Inherited from \u00b6 BaseAuthentication.instructionsUrl Defined in \u00b6 types.ts:212 postSetup \u00b6 \u2022 Optional postSetup : SetEndpoint [] One or more setup steps to run after the user has set up the account, before completing installation of the pack. This is not common. Inherited from \u00b6 BaseAuthentication.postSetup Defined in \u00b6 types.ts:235 requiresEndpointUrl \u00b6 \u2022 Optional requiresEndpointUrl : boolean If true, indicates this has pack has a specific endpoint domain for each account, that is used as the basis of HTTP requests. For example, API requests are made to .example.com rather than example.com. If true, the user will be prompted to provide their specific endpoint domain when creating a new account. Inherited from \u00b6 BaseAuthentication.requiresEndpointUrl Defined in \u00b6 types.ts:220 scopes \u00b6 \u2022 Optional scopes : string [] Scopes that are required to use this pack. Each API defines its own list of scopes, or none at all. You should consult the documentation for the API you are connecting to. Defined in \u00b6 types.ts:354 tokenPrefix \u00b6 \u2022 Optional tokenPrefix : string A custom prefix to be used when passing the access token in the HTTP Authorization header when making requests. Typically this prefix is Bearer which is what will be used if this value is omitted. However, some services require a different prefix. When sending authenticated requests, a HTTP header of the form Authorization: <tokenPrefix> <token> will be used. Defined in \u00b6 types.ts:362 tokenQueryParam \u00b6 \u2022 Optional tokenQueryParam : string In rare cases, OAuth providers ask that a token is passed as a URL parameter rather than an HTTP header. If so, this is the name of the URL query parameter that should contain the token. Defined in \u00b6 types.ts:384 tokenUrl \u00b6 \u2022 tokenUrl : string The URL that Coda will hit in order to exchange the temporary code for an access token at the end of the OAuth handshake flow. Defined in \u00b6 types.ts:347 type \u00b6 \u2022 type : OAuth2 Defined in \u00b6 types.ts:335","title":"Interface: OAuth2Authentication"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#interface-oauth2authentication","text":"Authenticate using OAuth2. You must specify the authorization URL, token exchange URL, and scopes here as part of the pack definition. You'll provide the application's client ID and client secret in the pack management UI, so that these can be stored securely. The API must use a (largely) standards-compliant implementation of OAuth2.","title":"Interface: OAuth2Authentication"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#hierarchy","text":"BaseAuthentication \u21b3 OAuth2Authentication","title":"Hierarchy"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#additionalparams","text":"\u2022 Optional additionalParams : Object Option custom URL parameters and values that should be included when redirecting the user to the authorizationUrl .","title":"additionalParams"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#authorizationurl","text":"\u2022 authorizationUrl : string The URL to which the user will be redirected in order to authorize this pack. This is typically just a base url with no parameters. Coda will append the scope parameter automatically. If the authorization flow requires additional parameters, they may be specified using additionalParams .","title":"authorizationUrl"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#defaultconnectiontype","text":"\u2022 Optional defaultConnectionType : DefaultConnectionType Indicates the defualt manner in which a user's account is expected to be used by this pack, e.g. is this account used for retrieving data, taking actions, or both. See https://help.coda.io/en/articles/4587167-what-can-coda-access-with-packs#h_40472431f0","title":"defaultConnectionType"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#endpointdomain","text":"\u2022 Optional endpointDomain : string When requiresEndpointUrl is set to true this should be the root domain that all endpoints share. For example, this value would be \"example.com\" if specific endpoints looked like {custom-subdomain}.example.com. For packs that make requests to multiple domains (uncommon), this should be the domain within networkDomains that this configuration applies to.","title":"endpointDomain"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#endpointkey","text":"\u2022 Optional endpointKey : string In rare cases, OAuth providers will return the specific API endpoint domain for the user as part of the OAuth token exchange response. If so, this is the property in the OAuth token exchange response JSON body that points to the endpoint. The endpoint will be saved along with the account and will be available during execution as ExecutionContext.endpoint .","title":"endpointKey"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#getconnectionname","text":"\u2022 Optional getConnectionName : MetadataFormula","title":"getConnectionName"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#getconnectionuserid","text":"\u2022 Optional getConnectionUserId : MetadataFormula","title":"getConnectionUserId"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#instructionsurl","text":"\u2022 Optional instructionsUrl : string A link to a help article or other page with more instructions about how to set up an account for this pack.","title":"instructionsUrl"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#postsetup","text":"\u2022 Optional postSetup : SetEndpoint [] One or more setup steps to run after the user has set up the account, before completing installation of the pack. This is not common.","title":"postSetup"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#requiresendpointurl","text":"\u2022 Optional requiresEndpointUrl : boolean If true, indicates this has pack has a specific endpoint domain for each account, that is used as the basis of HTTP requests. For example, API requests are made to .example.com rather than example.com. If true, the user will be prompted to provide their specific endpoint domain when creating a new account.","title":"requiresEndpointUrl"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#scopes","text":"\u2022 Optional scopes : string [] Scopes that are required to use this pack. Each API defines its own list of scopes, or none at all. You should consult the documentation for the API you are connecting to.","title":"scopes"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#tokenprefix","text":"\u2022 Optional tokenPrefix : string A custom prefix to be used when passing the access token in the HTTP Authorization header when making requests. Typically this prefix is Bearer which is what will be used if this value is omitted. However, some services require a different prefix. When sending authenticated requests, a HTTP header of the form Authorization: <tokenPrefix> <token> will be used.","title":"tokenPrefix"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#tokenqueryparam","text":"\u2022 Optional tokenQueryParam : string In rare cases, OAuth providers ask that a token is passed as a URL parameter rather than an HTTP header. If so, this is the name of the URL query parameter that should contain the token.","title":"tokenQueryParam"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#tokenurl","text":"\u2022 tokenUrl : string The URL that Coda will hit in order to exchange the temporary code for an access token at the end of the OAuth handshake flow.","title":"tokenUrl"},{"location":"reference/sdk/interfaces/OAuth2Authentication/#type","text":"\u2022 type : OAuth2","title":"type"},{"location":"reference/sdk/interfaces/ObjectSchema/","text":"Interface: ObjectSchema<K, L> \u00b6 Type parameters \u00b6 Name Type K extends string L extends string Hierarchy \u00b6 ObjectSchemaDefinition < K , L > \u21b3 ObjectSchema Properties \u00b6 codaType \u00b6 \u2022 Optional codaType : Person | Reference Inherited from \u00b6 ObjectSchemaDefinition.codaType Defined in \u00b6 schema.ts:566 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 ObjectSchemaDefinition.description Defined in \u00b6 schema.ts:192 featured \u00b6 \u2022 Optional featured : L [] Inherited from \u00b6 ObjectSchemaDefinition.featured Defined in \u00b6 schema.ts:567 id \u00b6 \u2022 Optional id : K Inherited from \u00b6 ObjectSchemaDefinition.id Defined in \u00b6 schema.ts:564 identity \u00b6 \u2022 Optional identity : Identity Overrides \u00b6 ObjectSchemaDefinition.identity Defined in \u00b6 schema.ts:578 primary \u00b6 \u2022 Optional primary : K Inherited from \u00b6 ObjectSchemaDefinition.primary Defined in \u00b6 schema.ts:565 properties \u00b6 \u2022 properties : ObjectSchemaProperties < K | L > Inherited from \u00b6 ObjectSchemaDefinition.properties Defined in \u00b6 schema.ts:563 type \u00b6 \u2022 type : Object Inherited from \u00b6 ObjectSchemaDefinition.type Defined in \u00b6 schema.ts:562","title":"Interface: ObjectSchema<K, L\\>"},{"location":"reference/sdk/interfaces/ObjectSchema/#interface-objectschemak-l","text":"","title":"Interface: ObjectSchema&lt;K, L>"},{"location":"reference/sdk/interfaces/ObjectSchema/#type-parameters","text":"Name Type K extends string L extends string","title":"Type parameters"},{"location":"reference/sdk/interfaces/ObjectSchema/#hierarchy","text":"ObjectSchemaDefinition < K , L > \u21b3 ObjectSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/ObjectSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ObjectSchema/#codatype","text":"\u2022 Optional codaType : Person | Reference","title":"codaType"},{"location":"reference/sdk/interfaces/ObjectSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/ObjectSchema/#featured","text":"\u2022 Optional featured : L []","title":"featured"},{"location":"reference/sdk/interfaces/ObjectSchema/#id","text":"\u2022 Optional id : K","title":"id"},{"location":"reference/sdk/interfaces/ObjectSchema/#identity","text":"\u2022 Optional identity : Identity","title":"identity"},{"location":"reference/sdk/interfaces/ObjectSchema/#primary","text":"\u2022 Optional primary : K","title":"primary"},{"location":"reference/sdk/interfaces/ObjectSchema/#properties_1","text":"\u2022 properties : ObjectSchemaProperties < K | L >","title":"properties"},{"location":"reference/sdk/interfaces/ObjectSchema/#type","text":"\u2022 type : Object","title":"type"},{"location":"reference/sdk/interfaces/ObjectSchemaProperty/","text":"Interface: ObjectSchemaProperty \u00b6 Properties \u00b6 fromKey \u00b6 \u2022 Optional fromKey : string Defined in \u00b6 schema.ts:534 required \u00b6 \u2022 Optional required : boolean Defined in \u00b6 schema.ts:535","title":"Interface: ObjectSchemaProperty"},{"location":"reference/sdk/interfaces/ObjectSchemaProperty/#interface-objectschemaproperty","text":"","title":"Interface: ObjectSchemaProperty"},{"location":"reference/sdk/interfaces/ObjectSchemaProperty/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ObjectSchemaProperty/#fromkey","text":"\u2022 Optional fromKey : string","title":"fromKey"},{"location":"reference/sdk/interfaces/ObjectSchemaProperty/#required","text":"\u2022 Optional required : boolean","title":"required"},{"location":"reference/sdk/interfaces/PackDefinition/","text":"Interface: PackDefinition \u00b6 deprecated use #PackVersionDefinition The legacy complete definition of a Pack including un-versioned metadata. This should only be used by legacy Coda pack implementations. Hierarchy \u00b6 PackVersionDefinition \u21b3 PackDefinition Properties \u00b6 category \u00b6 \u2022 Optional category : PackCategory Defined in \u00b6 types.ts:739 defaultAuthentication \u00b6 \u2022 Optional defaultAuthentication : Authentication If specified, the user must provide personal authentication credentials before using the pack. Inherited from \u00b6 PackVersionDefinition . defaultAuthentication Defined in \u00b6 types.ts:684 description \u00b6 \u2022 description : string Defined in \u00b6 types.ts:737 enabledConfigName \u00b6 \u2022 Optional enabledConfigName : string Defined in \u00b6 types.ts:741 exampleImages \u00b6 \u2022 Optional exampleImages : string [] Defined in \u00b6 types.ts:742 exampleVideoIds \u00b6 \u2022 Optional exampleVideoIds : string [] Defined in \u00b6 types.ts:743 formats \u00b6 \u2022 Optional formats : Format [] Definitions of this pack's column formats. See Format . Inherited from \u00b6 PackVersionDefinition . formats Defined in \u00b6 types.ts:720 formulaNamespace \u00b6 \u2022 Optional formulaNamespace : string deprecated Inherited from \u00b6 PackVersionDefinition . formulaNamespace Defined in \u00b6 types.ts:706 formulas \u00b6 \u2022 Optional formulas : PackFormulas | ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] Definitions of this pack's formulas. See Formula . Note that button actions are also defind here. Buttons are simply formulas with isAction: true . Note also, this should always be an array of Formulas. The PackFormulas object structure is deprecated and will be removed shortly. Inherited from \u00b6 PackVersionDefinition . formulas Defined in \u00b6 types.ts:716 id \u00b6 \u2022 id : number Defined in \u00b6 types.ts:734 isSystem \u00b6 \u2022 Optional isSystem : boolean Whether this is a pack that will be used by Coda internally and not exposed directly to users. Defined in \u00b6 types.ts:750 logoPath \u00b6 \u2022 logoPath : string Defined in \u00b6 types.ts:740 minimumFeatureSet \u00b6 \u2022 Optional minimumFeatureSet : FeatureSet Defined in \u00b6 types.ts:744 name \u00b6 \u2022 name : string Defined in \u00b6 types.ts:735 networkDomains \u00b6 \u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval. Inherited from \u00b6 PackVersionDefinition . networkDomains Defined in \u00b6 types.ts:699 permissionsDescription \u00b6 \u2022 Optional permissionsDescription : string Defined in \u00b6 types.ts:738 quotas \u00b6 \u2022 Optional quotas : Partial < Object > Defined in \u00b6 types.ts:745 rateLimits \u00b6 \u2022 Optional rateLimits : RateLimits Defined in \u00b6 types.ts:746 shortDescription \u00b6 \u2022 shortDescription : string Defined in \u00b6 types.ts:736 syncTables \u00b6 \u2022 Optional syncTables : SyncTable [] Definitions of this pack's sync tables. See {@link SyncTable}. Inherited from \u00b6 PackVersionDefinition . syncTables Defined in \u00b6 types.ts:724 systemConnectionAuthentication \u00b6 \u2022 Optional systemConnectionAuthentication : SystemAuthentication If specified, this pack requires system credentials to be set up via Coda's admin console in order to work when no explicit connection is specified by the user. Inherited from \u00b6 PackVersionDefinition . systemConnectionAuthentication Defined in \u00b6 types.ts:689 version \u00b6 \u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version. Inherited from \u00b6 PackVersionDefinition . version Defined in \u00b6 types.ts:680","title":"Interface: PackDefinition"},{"location":"reference/sdk/interfaces/PackDefinition/#interface-packdefinition","text":"deprecated use #PackVersionDefinition The legacy complete definition of a Pack including un-versioned metadata. This should only be used by legacy Coda pack implementations.","title":"Interface: PackDefinition"},{"location":"reference/sdk/interfaces/PackDefinition/#hierarchy","text":"PackVersionDefinition \u21b3 PackDefinition","title":"Hierarchy"},{"location":"reference/sdk/interfaces/PackDefinition/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/PackDefinition/#category","text":"\u2022 Optional category : PackCategory","title":"category"},{"location":"reference/sdk/interfaces/PackDefinition/#defaultauthentication","text":"\u2022 Optional defaultAuthentication : Authentication If specified, the user must provide personal authentication credentials before using the pack.","title":"defaultAuthentication"},{"location":"reference/sdk/interfaces/PackDefinition/#description","text":"\u2022 description : string","title":"description"},{"location":"reference/sdk/interfaces/PackDefinition/#enabledconfigname","text":"\u2022 Optional enabledConfigName : string","title":"enabledConfigName"},{"location":"reference/sdk/interfaces/PackDefinition/#exampleimages","text":"\u2022 Optional exampleImages : string []","title":"exampleImages"},{"location":"reference/sdk/interfaces/PackDefinition/#examplevideoids","text":"\u2022 Optional exampleVideoIds : string []","title":"exampleVideoIds"},{"location":"reference/sdk/interfaces/PackDefinition/#formats","text":"\u2022 Optional formats : Format [] Definitions of this pack's column formats. See Format .","title":"formats"},{"location":"reference/sdk/interfaces/PackDefinition/#formulanamespace","text":"\u2022 Optional formulaNamespace : string deprecated","title":"formulaNamespace"},{"location":"reference/sdk/interfaces/PackDefinition/#formulas","text":"\u2022 Optional formulas : PackFormulas | ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] Definitions of this pack's formulas. See Formula . Note that button actions are also defind here. Buttons are simply formulas with isAction: true . Note also, this should always be an array of Formulas. The PackFormulas object structure is deprecated and will be removed shortly.","title":"formulas"},{"location":"reference/sdk/interfaces/PackDefinition/#id","text":"\u2022 id : number","title":"id"},{"location":"reference/sdk/interfaces/PackDefinition/#issystem","text":"\u2022 Optional isSystem : boolean Whether this is a pack that will be used by Coda internally and not exposed directly to users.","title":"isSystem"},{"location":"reference/sdk/interfaces/PackDefinition/#logopath","text":"\u2022 logoPath : string","title":"logoPath"},{"location":"reference/sdk/interfaces/PackDefinition/#minimumfeatureset","text":"\u2022 Optional minimumFeatureSet : FeatureSet","title":"minimumFeatureSet"},{"location":"reference/sdk/interfaces/PackDefinition/#name","text":"\u2022 name : string","title":"name"},{"location":"reference/sdk/interfaces/PackDefinition/#networkdomains","text":"\u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval.","title":"networkDomains"},{"location":"reference/sdk/interfaces/PackDefinition/#permissionsdescription","text":"\u2022 Optional permissionsDescription : string","title":"permissionsDescription"},{"location":"reference/sdk/interfaces/PackDefinition/#quotas","text":"\u2022 Optional quotas : Partial < Object >","title":"quotas"},{"location":"reference/sdk/interfaces/PackDefinition/#ratelimits","text":"\u2022 Optional rateLimits : RateLimits","title":"rateLimits"},{"location":"reference/sdk/interfaces/PackDefinition/#shortdescription","text":"\u2022 shortDescription : string","title":"shortDescription"},{"location":"reference/sdk/interfaces/PackDefinition/#synctables","text":"\u2022 Optional syncTables : SyncTable [] Definitions of this pack's sync tables. See {@link SyncTable}.","title":"syncTables"},{"location":"reference/sdk/interfaces/PackDefinition/#systemconnectionauthentication","text":"\u2022 Optional systemConnectionAuthentication : SystemAuthentication If specified, this pack requires system credentials to be set up via Coda's admin console in order to work when no explicit connection is specified by the user.","title":"systemConnectionAuthentication"},{"location":"reference/sdk/interfaces/PackDefinition/#version","text":"\u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version.","title":"version"},{"location":"reference/sdk/interfaces/PackFormatMetadata/","text":"Interface: PackFormatMetadata \u00b6 Hierarchy \u00b6 Omit < Format , \"matchers\" > \u21b3 PackFormatMetadata Properties \u00b6 formulaName \u00b6 \u2022 formulaName : string The name of the formula to invoke for values in columns using this format. This must correspond to the name of a regular, public formula defined in this pack. Inherited from \u00b6 Omit.formulaName Defined in \u00b6 types.ts:580 formulaNamespace \u00b6 \u2022 formulaNamespace : string deprecated Namespaces are being removed from the product. Inherited from \u00b6 Omit.formulaNamespace Defined in \u00b6 types.ts:575 hasNoConnection \u00b6 \u2022 Optional hasNoConnection : boolean deprecated No longer needed, will be inferred from the referenced formula. Inherited from \u00b6 Omit.hasNoConnection Defined in \u00b6 types.ts:582 instructions \u00b6 \u2022 Optional instructions : string A brief, optional explanation of how users should use this format, for example, what kinds of values they should put in columns using this format. Inherited from \u00b6 Omit.instructions Defined in \u00b6 types.ts:587 matchers \u00b6 \u2022 matchers : string [] Defined in \u00b6 compiled_types.ts:27 name \u00b6 \u2022 name : string The name of this column format. This will show to users in the column type chooser. Inherited from \u00b6 Omit.name Defined in \u00b6 types.ts:573 placeholder \u00b6 \u2022 Optional placeholder : string deprecated Currently unused. Inherited from \u00b6 Omit.placeholder Defined in \u00b6 types.ts:596","title":"Interface: PackFormatMetadata"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#interface-packformatmetadata","text":"","title":"Interface: PackFormatMetadata"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#hierarchy","text":"Omit < Format , \"matchers\" > \u21b3 PackFormatMetadata","title":"Hierarchy"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#formulaname","text":"\u2022 formulaName : string The name of the formula to invoke for values in columns using this format. This must correspond to the name of a regular, public formula defined in this pack.","title":"formulaName"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#formulanamespace","text":"\u2022 formulaNamespace : string deprecated Namespaces are being removed from the product.","title":"formulaNamespace"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#hasnoconnection","text":"\u2022 Optional hasNoConnection : boolean deprecated No longer needed, will be inferred from the referenced formula.","title":"hasNoConnection"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#instructions","text":"\u2022 Optional instructions : string A brief, optional explanation of how users should use this format, for example, what kinds of values they should put in columns using this format.","title":"instructions"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#matchers","text":"\u2022 matchers : string []","title":"matchers"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#name","text":"\u2022 name : string The name of this column format. This will show to users in the column type chooser.","title":"name"},{"location":"reference/sdk/interfaces/PackFormatMetadata/#placeholder","text":"\u2022 Optional placeholder : string deprecated Currently unused.","title":"placeholder"},{"location":"reference/sdk/interfaces/PackFormulaDef/","text":"Interface: PackFormulaDef<ParamsT, ResultT> \u00b6 Type parameters \u00b6 Name Type ParamsT extends ParamDefs ResultT extends PackFormulaResult Hierarchy \u00b6 CommonPackFormulaDef < ParamsT > \u21b3 PackFormulaDef Properties \u00b6 cacheTtlSecs \u00b6 \u2022 Optional Readonly cacheTtlSecs : number How long formulas running with the same values should cache their results for. Inherited from \u00b6 CommonPackFormulaDef.cacheTtlSecs Defined in \u00b6 api_types.ts:286 connectionRequirement \u00b6 \u2022 Optional Readonly connectionRequirement : ConnectionRequirement Does this formula require a connection (aka an account)? Inherited from \u00b6 CommonPackFormulaDef.connectionRequirement Defined in \u00b6 api_types.ts:278 description \u00b6 \u2022 Readonly description : string A brief description of what the formula does. Inherited from \u00b6 CommonPackFormulaDef.description Defined in \u00b6 api_types.ts:252 examples \u00b6 \u2022 Optional Readonly examples : { params : PackFormulaValue [] ; result : PackFormulaResult }[] Sample inputs and outputs demonstrating usage of this formula. Inherited from \u00b6 CommonPackFormulaDef.examples Defined in \u00b6 api_types.ts:267 extraOAuthScopes \u00b6 \u2022 Optional Readonly extraOAuthScopes : string [] OAuth scopes that the formula needs that weren't requested in the pack's overall authentication config. For example, a Slack pack can have one formula that needs admin privileges, but non-admins can use the bulk of the pack without those privileges. Coda will give users help in understanding that they need additional authentication to use a formula with extra OAuth scopes. Note that these scopes will always be requested in addition to the default scopes for the pack, so an end user must have both sets of permissions. Inherited from \u00b6 CommonPackFormulaDef.extraOAuthScopes Defined in \u00b6 api_types.ts:308 isAction \u00b6 \u2022 Optional Readonly isAction : boolean Does this formula take an action (vs retrieve data or make a calculation)? Actions are presented as buttons in the Coda UI. Inherited from \u00b6 CommonPackFormulaDef.isAction Defined in \u00b6 api_types.ts:273 isExperimental \u00b6 \u2022 Optional Readonly isExperimental : boolean If specified, the formula will not be suggested to users in Coda's formula autocomplete. The formula can still be invoked by manually typing its full name. Inherited from \u00b6 CommonPackFormulaDef.isExperimental Defined in \u00b6 api_types.ts:292 isSystem \u00b6 \u2022 Optional Readonly isSystem : boolean Whether this is a formula that will be used by Coda internally and not exposed directly to users. Not for use by packs that are not authored by Coda. Inherited from \u00b6 CommonPackFormulaDef.isSystem Defined in \u00b6 api_types.ts:298 name \u00b6 \u2022 Readonly name : string The name of the formula, used to invoke it. Inherited from \u00b6 CommonPackFormulaDef.name Defined in \u00b6 api_types.ts:247 network \u00b6 \u2022 Optional Readonly network : Network deprecated use isAction and connectionRequirement instead Inherited from \u00b6 CommonPackFormulaDef.network Defined in \u00b6 api_types.ts:281 parameters \u00b6 \u2022 Readonly parameters : ParamsT The parameter inputs to the formula, if any. Inherited from \u00b6 CommonPackFormulaDef.parameters Defined in \u00b6 api_types.ts:257 varargParameters \u00b6 \u2022 Optional Readonly varargParameters : ParamDefs Variable argument parameters, used if this formula should accept arbitrary numbers of inputs. Inherited from \u00b6 CommonPackFormulaDef.varargParameters Defined in \u00b6 api_types.ts:262 Methods \u00b6 execute \u00b6 \u25b8 execute ( params , context ): ResultT | Promise < ResultT > Parameters \u00b6 Name Type params ParamValues < ParamsT > context ExecutionContext Returns \u00b6 ResultT | Promise < ResultT > Defined in \u00b6 api.ts:397","title":"Interface: PackFormulaDef<ParamsT, ResultT\\>"},{"location":"reference/sdk/interfaces/PackFormulaDef/#interface-packformuladefparamst-resultt","text":"","title":"Interface: PackFormulaDef&lt;ParamsT, ResultT>"},{"location":"reference/sdk/interfaces/PackFormulaDef/#type-parameters","text":"Name Type ParamsT extends ParamDefs ResultT extends PackFormulaResult","title":"Type parameters"},{"location":"reference/sdk/interfaces/PackFormulaDef/#hierarchy","text":"CommonPackFormulaDef < ParamsT > \u21b3 PackFormulaDef","title":"Hierarchy"},{"location":"reference/sdk/interfaces/PackFormulaDef/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/PackFormulaDef/#cachettlsecs","text":"\u2022 Optional Readonly cacheTtlSecs : number How long formulas running with the same values should cache their results for.","title":"cacheTtlSecs"},{"location":"reference/sdk/interfaces/PackFormulaDef/#connectionrequirement","text":"\u2022 Optional Readonly connectionRequirement : ConnectionRequirement Does this formula require a connection (aka an account)?","title":"connectionRequirement"},{"location":"reference/sdk/interfaces/PackFormulaDef/#description","text":"\u2022 Readonly description : string A brief description of what the formula does.","title":"description"},{"location":"reference/sdk/interfaces/PackFormulaDef/#examples","text":"\u2022 Optional Readonly examples : { params : PackFormulaValue [] ; result : PackFormulaResult }[] Sample inputs and outputs demonstrating usage of this formula.","title":"examples"},{"location":"reference/sdk/interfaces/PackFormulaDef/#extraoauthscopes","text":"\u2022 Optional Readonly extraOAuthScopes : string [] OAuth scopes that the formula needs that weren't requested in the pack's overall authentication config. For example, a Slack pack can have one formula that needs admin privileges, but non-admins can use the bulk of the pack without those privileges. Coda will give users help in understanding that they need additional authentication to use a formula with extra OAuth scopes. Note that these scopes will always be requested in addition to the default scopes for the pack, so an end user must have both sets of permissions.","title":"extraOAuthScopes"},{"location":"reference/sdk/interfaces/PackFormulaDef/#isaction","text":"\u2022 Optional Readonly isAction : boolean Does this formula take an action (vs retrieve data or make a calculation)? Actions are presented as buttons in the Coda UI.","title":"isAction"},{"location":"reference/sdk/interfaces/PackFormulaDef/#isexperimental","text":"\u2022 Optional Readonly isExperimental : boolean If specified, the formula will not be suggested to users in Coda's formula autocomplete. The formula can still be invoked by manually typing its full name.","title":"isExperimental"},{"location":"reference/sdk/interfaces/PackFormulaDef/#issystem","text":"\u2022 Optional Readonly isSystem : boolean Whether this is a formula that will be used by Coda internally and not exposed directly to users. Not for use by packs that are not authored by Coda.","title":"isSystem"},{"location":"reference/sdk/interfaces/PackFormulaDef/#name","text":"\u2022 Readonly name : string The name of the formula, used to invoke it.","title":"name"},{"location":"reference/sdk/interfaces/PackFormulaDef/#network","text":"\u2022 Optional Readonly network : Network deprecated use isAction and connectionRequirement instead","title":"network"},{"location":"reference/sdk/interfaces/PackFormulaDef/#parameters","text":"\u2022 Readonly parameters : ParamsT The parameter inputs to the formula, if any.","title":"parameters"},{"location":"reference/sdk/interfaces/PackFormulaDef/#varargparameters","text":"\u2022 Optional Readonly varargParameters : ParamDefs Variable argument parameters, used if this formula should accept arbitrary numbers of inputs.","title":"varargParameters"},{"location":"reference/sdk/interfaces/PackFormulaDef/#methods","text":"","title":"Methods"},{"location":"reference/sdk/interfaces/PackFormulaDef/#execute","text":"\u25b8 execute ( params , context ): ResultT | Promise < ResultT >","title":"execute"},{"location":"reference/sdk/interfaces/PackFormulas/","text":"Interface: PackFormulas \u00b6 Indexable \u00b6 \u25aa [namespace: string ]: Formula []","title":"Interface: PackFormulas"},{"location":"reference/sdk/interfaces/PackFormulas/#interface-packformulas","text":"","title":"Interface: PackFormulas"},{"location":"reference/sdk/interfaces/PackFormulas/#indexable","text":"\u25aa [namespace: string ]: Formula []","title":"Indexable"},{"location":"reference/sdk/interfaces/PackFormulasMetadata/","text":"Interface: PackFormulasMetadata \u00b6 Indexable \u00b6 \u25aa [namespace: string ]: PackFormulaMetadata []","title":"Interface: PackFormulasMetadata"},{"location":"reference/sdk/interfaces/PackFormulasMetadata/#interface-packformulasmetadata","text":"","title":"Interface: PackFormulasMetadata"},{"location":"reference/sdk/interfaces/PackFormulasMetadata/#indexable","text":"\u25aa [namespace: string ]: PackFormulaMetadata []","title":"Indexable"},{"location":"reference/sdk/interfaces/PackVersionDefinition/","text":"Interface: PackVersionDefinition \u00b6 The definition of the contents of a Pack at a specific version. This is the heart of the implementation of a Pack. Hierarchy \u00b6 PackVersionDefinition \u21b3 PackDefinition Properties \u00b6 defaultAuthentication \u00b6 \u2022 Optional defaultAuthentication : Authentication If specified, the user must provide personal authentication credentials before using the pack. Defined in \u00b6 types.ts:684 formats \u00b6 \u2022 Optional formats : Format [] Definitions of this pack's column formats. See Format . Defined in \u00b6 types.ts:720 formulaNamespace \u00b6 \u2022 Optional formulaNamespace : string deprecated Defined in \u00b6 types.ts:706 formulas \u00b6 \u2022 Optional formulas : PackFormulas | ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] Definitions of this pack's formulas. See Formula . Note that button actions are also defind here. Buttons are simply formulas with isAction: true . Note also, this should always be an array of Formulas. The PackFormulas object structure is deprecated and will be removed shortly. Defined in \u00b6 types.ts:716 networkDomains \u00b6 \u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval. Defined in \u00b6 types.ts:699 syncTables \u00b6 \u2022 Optional syncTables : SyncTable [] Definitions of this pack's sync tables. See {@link SyncTable}. Defined in \u00b6 types.ts:724 systemConnectionAuthentication \u00b6 \u2022 Optional systemConnectionAuthentication : SystemAuthentication If specified, this pack requires system credentials to be set up via Coda's admin console in order to work when no explicit connection is specified by the user. Defined in \u00b6 types.ts:689 version \u00b6 \u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version. Defined in \u00b6 types.ts:680","title":"Interface: PackVersionDefinition"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#interface-packversiondefinition","text":"The definition of the contents of a Pack at a specific version. This is the heart of the implementation of a Pack.","title":"Interface: PackVersionDefinition"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#hierarchy","text":"PackVersionDefinition \u21b3 PackDefinition","title":"Hierarchy"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#defaultauthentication","text":"\u2022 Optional defaultAuthentication : Authentication If specified, the user must provide personal authentication credentials before using the pack.","title":"defaultAuthentication"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#formats","text":"\u2022 Optional formats : Format [] Definitions of this pack's column formats. See Format .","title":"formats"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#formulanamespace","text":"\u2022 Optional formulaNamespace : string deprecated","title":"formulaNamespace"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#formulas","text":"\u2022 Optional formulas : PackFormulas | ( BooleanPackFormula < ParamDefs > | NumericPackFormula < ParamDefs > | StringPackFormula < ParamDefs > | ObjectPackFormula < ParamDefs , ArraySchema < Schema >> | ObjectPackFormula < ParamDefs , Schema >)[] Definitions of this pack's formulas. See Formula . Note that button actions are also defind here. Buttons are simply formulas with isAction: true . Note also, this should always be an array of Formulas. The PackFormulas object structure is deprecated and will be removed shortly.","title":"formulas"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#networkdomains","text":"\u2022 Optional networkDomains : string [] Any domain(s) to which this pack makes fetcher requests. The domains this pack connects to must be declared up front here, both to clearly communicate to users what a pack is capable of connecting to, and for security reasons. These network domains are enforced at execution time: any fetcher request to a domain not listed here will be rejected. Only one network domain is allowed by default. If your pack has needs to connect to multiple domains contact Coda support for approval.","title":"networkDomains"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#synctables","text":"\u2022 Optional syncTables : SyncTable [] Definitions of this pack's sync tables. See {@link SyncTable}.","title":"syncTables"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#systemconnectionauthentication","text":"\u2022 Optional systemConnectionAuthentication : SystemAuthentication If specified, this pack requires system credentials to be set up via Coda's admin console in order to work when no explicit connection is specified by the user.","title":"systemConnectionAuthentication"},{"location":"reference/sdk/interfaces/PackVersionDefinition/#version","text":"\u2022 version : string The semantic version of the pack. This must be valid semantic version of the form 1 , 1.2 , or 1.2.3 . When uploading a pack version, the semantic version must be greater than any previously uploaded version.","title":"version"},{"location":"reference/sdk/interfaces/ParamDef/","text":"Interface: ParamDef<T> \u00b6 Type parameters \u00b6 Name Type T extends UnionType Properties \u00b6 autocomplete \u00b6 \u2022 Optional autocomplete : MetadataFormula A MetadataFormula that returns valid values for this parameter, optionally matching a search query. This can be useful both if there are a fixed number of valid values for the parameter, or if the valid values from the parameter can be looked up from some API. Use makeMetadataFormula to wrap a function that implements your autocomplete logic. Typically once you have fetched the list of matching values, you'll use autocompleteSearchObjects to handle searching over those values. If you have a hardcoded list of valid values, you would only need to use makeSimpleAutocompleteMetadataFormula . Defined in \u00b6 api_types.ts:216 defaultValue \u00b6 \u2022 Optional defaultValue : DefaultValueType < T > The default value to be used for this parameter if it is not specified by the user. Defined in \u00b6 api_types.ts:220 description \u00b6 \u2022 description : string A brief description of what this parameter is used for, shown to the user when invoking the formula. Defined in \u00b6 api_types.ts:197 hidden \u00b6 \u2022 Optional hidden : boolean Defined in \u00b6 api_types.ts:203 name \u00b6 \u2022 name : string The name of the parameter, which will be shown to the user when invoking this formula. Defined in \u00b6 api_types.ts:189 optional \u00b6 \u2022 Optional optional : boolean Whether this parameter can be omitted when invoking the formula. All optional parameters must come after all non-optional parameters. Defined in \u00b6 api_types.ts:202 type \u00b6 \u2022 type : T The data type of this parameter (string, number, etc). Defined in \u00b6 api_types.ts:193","title":"Interface: ParamDef<T\\>"},{"location":"reference/sdk/interfaces/ParamDef/#interface-paramdeft","text":"","title":"Interface: ParamDef&lt;T>"},{"location":"reference/sdk/interfaces/ParamDef/#type-parameters","text":"Name Type T extends UnionType","title":"Type parameters"},{"location":"reference/sdk/interfaces/ParamDef/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ParamDef/#autocomplete","text":"\u2022 Optional autocomplete : MetadataFormula A MetadataFormula that returns valid values for this parameter, optionally matching a search query. This can be useful both if there are a fixed number of valid values for the parameter, or if the valid values from the parameter can be looked up from some API. Use makeMetadataFormula to wrap a function that implements your autocomplete logic. Typically once you have fetched the list of matching values, you'll use autocompleteSearchObjects to handle searching over those values. If you have a hardcoded list of valid values, you would only need to use makeSimpleAutocompleteMetadataFormula .","title":"autocomplete"},{"location":"reference/sdk/interfaces/ParamDef/#defaultvalue","text":"\u2022 Optional defaultValue : DefaultValueType < T > The default value to be used for this parameter if it is not specified by the user.","title":"defaultValue"},{"location":"reference/sdk/interfaces/ParamDef/#description","text":"\u2022 description : string A brief description of what this parameter is used for, shown to the user when invoking the formula.","title":"description"},{"location":"reference/sdk/interfaces/ParamDef/#hidden","text":"\u2022 Optional hidden : boolean","title":"hidden"},{"location":"reference/sdk/interfaces/ParamDef/#name","text":"\u2022 name : string The name of the parameter, which will be shown to the user when invoking this formula.","title":"name"},{"location":"reference/sdk/interfaces/ParamDef/#optional","text":"\u2022 Optional optional : boolean Whether this parameter can be omitted when invoking the formula. All optional parameters must come after all non-optional parameters.","title":"optional"},{"location":"reference/sdk/interfaces/ParamDef/#type","text":"\u2022 type : T The data type of this parameter (string, number, etc).","title":"type"},{"location":"reference/sdk/interfaces/ScaleSchema/","text":"Interface: ScaleSchema \u00b6 A schema representing a return value or object property that is a number that should be rendered as a scale. A scale is a widget with a repeated set of icons, where the number of shaded represents a numeric value. The canonical example of a scale is a star rating, which might show 5 star icons, with 3 of them shaded, indicating a value of 3. Hierarchy \u00b6 BaseNumberSchema < Scale > \u21b3 ScaleSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Scale Instructs Coda to render this value as a scale. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:386 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 icon \u00b6 \u2022 Optional icon : ScaleIconSet The icon to render. Defined in \u00b6 schema.ts:390 maximum \u00b6 \u2022 Optional maximum : number The number of icons to render. Defined in \u00b6 schema.ts:388 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: ScaleSchema"},{"location":"reference/sdk/interfaces/ScaleSchema/#interface-scaleschema","text":"A schema representing a return value or object property that is a number that should be rendered as a scale. A scale is a widget with a repeated set of icons, where the number of shaded represents a numeric value. The canonical example of a scale is a star rating, which might show 5 star icons, with 3 of them shaded, indicating a value of 3.","title":"Interface: ScaleSchema"},{"location":"reference/sdk/interfaces/ScaleSchema/#hierarchy","text":"BaseNumberSchema < Scale > \u21b3 ScaleSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/ScaleSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/ScaleSchema/#codatype","text":"\u2022 codaType : Scale Instructs Coda to render this value as a scale.","title":"codaType"},{"location":"reference/sdk/interfaces/ScaleSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/ScaleSchema/#icon","text":"\u2022 Optional icon : ScaleIconSet The icon to render.","title":"icon"},{"location":"reference/sdk/interfaces/ScaleSchema/#maximum","text":"\u2022 Optional maximum : number The number of icons to render.","title":"maximum"},{"location":"reference/sdk/interfaces/ScaleSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/SimpleAutocompleteOption/","text":"Interface: SimpleAutocompleteOption \u00b6 Properties \u00b6 display \u00b6 \u2022 display : string Defined in \u00b6 api.ts:822 value \u00b6 \u2022 value : string | number Defined in \u00b6 api.ts:823","title":"Interface: SimpleAutocompleteOption"},{"location":"reference/sdk/interfaces/SimpleAutocompleteOption/#interface-simpleautocompleteoption","text":"","title":"Interface: SimpleAutocompleteOption"},{"location":"reference/sdk/interfaces/SimpleAutocompleteOption/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SimpleAutocompleteOption/#display","text":"\u2022 display : string","title":"display"},{"location":"reference/sdk/interfaces/SimpleAutocompleteOption/#value","text":"\u2022 value : string | number","title":"value"},{"location":"reference/sdk/interfaces/SimpleStringSchema/","text":"Interface: SimpleStringSchema<T> \u00b6 Type parameters \u00b6 Name Type T extends SimpleStringHintTypes``SimpleStringHintTypes Hierarchy \u00b6 BaseStringSchema < T > \u21b3 SimpleStringSchema Properties \u00b6 codaType \u00b6 \u2022 Optional codaType : T An optional type hint instructing Coda about how to interpret or render this value. Inherited from \u00b6 BaseStringSchema.codaType Defined in \u00b6 schema.ts:495 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseStringSchema.description Defined in \u00b6 schema.ts:192 type \u00b6 \u2022 type : String Identifies this schema as a string. Inherited from \u00b6 BaseStringSchema.type Defined in \u00b6 schema.ts:493","title":"Interface: SimpleStringSchema<T\\>"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#interface-simplestringschemat","text":"","title":"Interface: SimpleStringSchema&lt;T>"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#type-parameters","text":"Name Type T extends SimpleStringHintTypes``SimpleStringHintTypes","title":"Type parameters"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#hierarchy","text":"BaseStringSchema < T > \u21b3 SimpleStringSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#codatype","text":"\u2022 Optional codaType : T An optional type hint instructing Coda about how to interpret or render this value.","title":"codaType"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/SimpleStringSchema/#type","text":"\u2022 type : String Identifies this schema as a string.","title":"type"},{"location":"reference/sdk/interfaces/SliderSchema/","text":"Interface: SliderSchema \u00b6 A schema representing a return value or object property that is a number that should be rendered as a slider. Hierarchy \u00b6 BaseNumberSchema < Slider > \u21b3 SliderSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Slider Instructs Coda to render this value as a slider. Overrides \u00b6 BaseNumberSchema.codaType Defined in \u00b6 schema.ts:339 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseNumberSchema.description Defined in \u00b6 schema.ts:192 maximum \u00b6 \u2022 Optional maximum : string | number The maximum value selectable by this slider. Defined in \u00b6 schema.ts:343 minimum \u00b6 \u2022 Optional minimum : string | number The minimum value selectable by this slider. Defined in \u00b6 schema.ts:341 step \u00b6 \u2022 Optional step : string | number The minimum amount the slider can be moved when dragged. Defined in \u00b6 schema.ts:345 type \u00b6 \u2022 type : Number Identifies this schema as relating to a number value. Inherited from \u00b6 BaseNumberSchema.type Defined in \u00b6 schema.ts:217","title":"Interface: SliderSchema"},{"location":"reference/sdk/interfaces/SliderSchema/#interface-sliderschema","text":"A schema representing a return value or object property that is a number that should be rendered as a slider.","title":"Interface: SliderSchema"},{"location":"reference/sdk/interfaces/SliderSchema/#hierarchy","text":"BaseNumberSchema < Slider > \u21b3 SliderSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/SliderSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SliderSchema/#codatype","text":"\u2022 codaType : Slider Instructs Coda to render this value as a slider.","title":"codaType"},{"location":"reference/sdk/interfaces/SliderSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/SliderSchema/#maximum","text":"\u2022 Optional maximum : string | number The maximum value selectable by this slider.","title":"maximum"},{"location":"reference/sdk/interfaces/SliderSchema/#minimum","text":"\u2022 Optional minimum : string | number The minimum value selectable by this slider.","title":"minimum"},{"location":"reference/sdk/interfaces/SliderSchema/#step","text":"\u2022 Optional step : string | number The minimum amount the slider can be moved when dragged.","title":"step"},{"location":"reference/sdk/interfaces/SliderSchema/#type","text":"\u2022 type : Number Identifies this schema as relating to a number value.","title":"type"},{"location":"reference/sdk/interfaces/StringDateSchema/","text":"Interface: StringDateSchema \u00b6 A schema representing a return value or object property that is provided as a string, which Coda should interpret as a date. Coda is able to flexibly a parse number of formal and informal string representations of dates. For maximum accuracy, consider using an ISO 8601 date string (e.g. 2021-10-29): https://en.wikipedia.org/wiki/ISO_8601. Hierarchy \u00b6 BaseStringSchema < Date > \u21b3 StringDateSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Date Instructs Coda to render this value as a date. Overrides \u00b6 BaseStringSchema.codaType Defined in \u00b6 schema.ts:401 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseStringSchema.description Defined in \u00b6 schema.ts:192 format \u00b6 \u2022 Optional format : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:408 type \u00b6 \u2022 type : String Identifies this schema as a string. Inherited from \u00b6 BaseStringSchema.type Defined in \u00b6 schema.ts:493","title":"Interface: StringDateSchema"},{"location":"reference/sdk/interfaces/StringDateSchema/#interface-stringdateschema","text":"A schema representing a return value or object property that is provided as a string, which Coda should interpret as a date. Coda is able to flexibly a parse number of formal and informal string representations of dates. For maximum accuracy, consider using an ISO 8601 date string (e.g. 2021-10-29): https://en.wikipedia.org/wiki/ISO_8601.","title":"Interface: StringDateSchema"},{"location":"reference/sdk/interfaces/StringDateSchema/#hierarchy","text":"BaseStringSchema < Date > \u21b3 StringDateSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/StringDateSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/StringDateSchema/#codatype","text":"\u2022 codaType : Date Instructs Coda to render this value as a date.","title":"codaType"},{"location":"reference/sdk/interfaces/StringDateSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/StringDateSchema/#format","text":"\u2022 Optional format : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"format"},{"location":"reference/sdk/interfaces/StringDateSchema/#type","text":"\u2022 type : String Identifies this schema as a string.","title":"type"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/","text":"Interface: StringDateTimeSchema \u00b6 A schema representing a return value or object property that is provided as a string, which Coda should interpret as a datetime. Coda is able to flexibly a parse number of formal and informal string representations of dates. For maximum accuracy, consider using an ISO 8601 datetime string (e.g. 2021-11-03T19:43:58): https://en.wikipedia.org/wiki/ISO_8601. Hierarchy \u00b6 BaseStringSchema < DateTime > \u21b3 StringDateTimeSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : DateTime Instructs Coda to render this value as a date. Overrides \u00b6 BaseStringSchema.codaType Defined in \u00b6 schema.ts:435 dateFormat \u00b6 \u2022 Optional dateFormat : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:442 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseStringSchema.description Defined in \u00b6 schema.ts:192 timeFormat \u00b6 \u2022 Optional timeFormat : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:449 type \u00b6 \u2022 type : String Identifies this schema as a string. Inherited from \u00b6 BaseStringSchema.type Defined in \u00b6 schema.ts:493","title":"Interface: StringDateTimeSchema"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#interface-stringdatetimeschema","text":"A schema representing a return value or object property that is provided as a string, which Coda should interpret as a datetime. Coda is able to flexibly a parse number of formal and informal string representations of dates. For maximum accuracy, consider using an ISO 8601 datetime string (e.g. 2021-11-03T19:43:58): https://en.wikipedia.org/wiki/ISO_8601.","title":"Interface: StringDateTimeSchema"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#hierarchy","text":"BaseStringSchema < DateTime > \u21b3 StringDateTimeSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#codatype","text":"\u2022 codaType : DateTime Instructs Coda to render this value as a date.","title":"codaType"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#dateformat","text":"\u2022 Optional dateFormat : string A Moment date format string, such as 'MMM D, YYYY', that corresponds to a supported Coda date column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"dateFormat"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#timeformat","text":"\u2022 Optional timeFormat : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"timeFormat"},{"location":"reference/sdk/interfaces/StringDateTimeSchema/#type","text":"\u2022 type : String Identifies this schema as a string.","title":"type"},{"location":"reference/sdk/interfaces/StringTimeSchema/","text":"Interface: StringTimeSchema \u00b6 A schema representing a return value or object property that is provided as a string, which Coda should interpret as a time. Hierarchy \u00b6 BaseStringSchema < Time > \u21b3 StringTimeSchema Properties \u00b6 codaType \u00b6 \u2022 codaType : Time Instructs Coda to render this value as a date. Overrides \u00b6 BaseStringSchema.codaType Defined in \u00b6 schema.ts:417 description \u00b6 \u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident. Inherited from \u00b6 BaseStringSchema.description Defined in \u00b6 schema.ts:192 format \u00b6 \u2022 Optional format : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property. Defined in \u00b6 schema.ts:424 type \u00b6 \u2022 type : String Identifies this schema as a string. Inherited from \u00b6 BaseStringSchema.type Defined in \u00b6 schema.ts:493","title":"Interface: StringTimeSchema"},{"location":"reference/sdk/interfaces/StringTimeSchema/#interface-stringtimeschema","text":"A schema representing a return value or object property that is provided as a string, which Coda should interpret as a time.","title":"Interface: StringTimeSchema"},{"location":"reference/sdk/interfaces/StringTimeSchema/#hierarchy","text":"BaseStringSchema < Time > \u21b3 StringTimeSchema","title":"Hierarchy"},{"location":"reference/sdk/interfaces/StringTimeSchema/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/StringTimeSchema/#codatype","text":"\u2022 codaType : Time Instructs Coda to render this value as a date.","title":"codaType"},{"location":"reference/sdk/interfaces/StringTimeSchema/#description","text":"\u2022 Optional description : string A explanation of this object schema property shown to the user in the UI. If your pack has an object schema with many properties, it may be useful to explain the purpose or contents of any property that is not self-evident.","title":"description"},{"location":"reference/sdk/interfaces/StringTimeSchema/#format","text":"\u2022 Optional format : string A Moment time format string, such as 'HH ss', that corresponds to a supported Coda time column format, used when rendering the value. Only applies when this is used as a sync table property.","title":"format"},{"location":"reference/sdk/interfaces/StringTimeSchema/#type","text":"\u2022 type : String Identifies this schema as a string.","title":"type"},{"location":"reference/sdk/interfaces/SyncExecutionContext/","text":"Interface: SyncExecutionContext \u00b6 Sub-class of ExecutionContext that is passed to the execute function of every sync formula invocation. The only different is that the presence of the sync property Hierarchy \u00b6 ExecutionContext \u21b3 SyncExecutionContext Properties \u00b6 endpoint \u00b6 \u2022 Optional Readonly endpoint : string The base endpoint URL for the user's account, only if applicable. See requiresEndpointUrl . If the API URLs are variable based on the user account, you will need this endpoint to construct URLs to use with the fetcher. Alternatively, you can use relative URLs (e.g. \"/api/entity\") and Coda will include the endpoint for you automatically. Inherited from \u00b6 ExecutionContext . endpoint Defined in \u00b6 api_types.ts:557 fetcher \u00b6 \u2022 Readonly fetcher : Fetcher The Fetcher used for making HTTP requests. Inherited from \u00b6 ExecutionContext . fetcher Defined in \u00b6 api_types.ts:544 invocationLocation \u00b6 \u2022 Readonly invocationLocation : InvocationLocation Information about the Coda environment and doc this formula was invoked from. This is mostly for Coda internal use and we do not recommend relying on it. Inherited from \u00b6 ExecutionContext . invocationLocation Defined in \u00b6 api_types.ts:562 invocationToken \u00b6 \u2022 Readonly invocationToken : string A random token scoped to only this request invocation. This is a unique identifier for the invocation, and in particular used with {@link AuthenticationType.Custom} for naming template parameters that will be replaced by the fetcher in secure way. Inherited from \u00b6 ExecutionContext . invocationToken Defined in \u00b6 api_types.ts:573 sync \u00b6 \u2022 Readonly sync : Sync Information about state of the current sync. Overrides \u00b6 ExecutionContext . sync Defined in \u00b6 api_types.ts:588 temporaryBlobStorage \u00b6 \u2022 Readonly temporaryBlobStorage : TemporaryBlobStorage A utility to fetch and store files and images that either require the pack user's authentication or are too large to return inline. See TemporaryBlobStorage . Inherited from \u00b6 ExecutionContext . temporaryBlobStorage Defined in \u00b6 api_types.ts:549 timezone \u00b6 \u2022 Readonly timezone : string The timezone of the doc from which this formula was invoked. Inherited from \u00b6 ExecutionContext . timezone Defined in \u00b6 api_types.ts:566","title":"Interface: SyncExecutionContext"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#interface-syncexecutioncontext","text":"Sub-class of ExecutionContext that is passed to the execute function of every sync formula invocation. The only different is that the presence of the sync property","title":"Interface: SyncExecutionContext"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#hierarchy","text":"ExecutionContext \u21b3 SyncExecutionContext","title":"Hierarchy"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#endpoint","text":"\u2022 Optional Readonly endpoint : string The base endpoint URL for the user's account, only if applicable. See requiresEndpointUrl . If the API URLs are variable based on the user account, you will need this endpoint to construct URLs to use with the fetcher. Alternatively, you can use relative URLs (e.g. \"/api/entity\") and Coda will include the endpoint for you automatically.","title":"endpoint"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#fetcher","text":"\u2022 Readonly fetcher : Fetcher The Fetcher used for making HTTP requests.","title":"fetcher"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#invocationlocation","text":"\u2022 Readonly invocationLocation : InvocationLocation Information about the Coda environment and doc this formula was invoked from. This is mostly for Coda internal use and we do not recommend relying on it.","title":"invocationLocation"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#invocationtoken","text":"\u2022 Readonly invocationToken : string A random token scoped to only this request invocation. This is a unique identifier for the invocation, and in particular used with {@link AuthenticationType.Custom} for naming template parameters that will be replaced by the fetcher in secure way.","title":"invocationToken"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#sync","text":"\u2022 Readonly sync : Sync Information about state of the current sync.","title":"sync"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#temporaryblobstorage","text":"\u2022 Readonly temporaryBlobStorage : TemporaryBlobStorage A utility to fetch and store files and images that either require the pack user's authentication or are too large to return inline. See TemporaryBlobStorage .","title":"temporaryBlobStorage"},{"location":"reference/sdk/interfaces/SyncExecutionContext/#timezone","text":"\u2022 Readonly timezone : string The timezone of the doc from which this formula was invoked.","title":"timezone"},{"location":"reference/sdk/interfaces/SyncFormulaResult/","text":"Interface: SyncFormulaResult<K, L, SchemaT> \u00b6 Type parameters \u00b6 Name Type K extends string L extends string SchemaT extends ObjectSchemaDefinition < K , L > Properties \u00b6 continuation \u00b6 \u2022 Optional continuation : Continuation Defined in \u00b6 api.ts:493 result \u00b6 \u2022 result : ObjectSchemaDefinitionType < K , L , SchemaT >[] Defined in \u00b6 api.ts:492","title":"Interface: SyncFormulaResult<K, L, SchemaT\\>"},{"location":"reference/sdk/interfaces/SyncFormulaResult/#interface-syncformularesultk-l-schemat","text":"","title":"Interface: SyncFormulaResult&lt;K, L, SchemaT>"},{"location":"reference/sdk/interfaces/SyncFormulaResult/#type-parameters","text":"Name Type K extends string L extends string SchemaT extends ObjectSchemaDefinition < K , L >","title":"Type parameters"},{"location":"reference/sdk/interfaces/SyncFormulaResult/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SyncFormulaResult/#continuation","text":"\u2022 Optional continuation : Continuation","title":"continuation"},{"location":"reference/sdk/interfaces/SyncFormulaResult/#result","text":"\u2022 result : ObjectSchemaDefinitionType < K , L , SchemaT >[]","title":"result"},{"location":"reference/sdk/interfaces/SyncTableDef/","text":"Interface: SyncTableDef<K, L, ParamDefsT, SchemaT> \u00b6 Type definition for a Sync Table. Should not be necessary to use directly, instead, define sync tables using makeSyncTable . Type parameters \u00b6 Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchema < K , L > Hierarchy \u00b6 SyncTableDef \u21b3 DynamicSyncTableDef Properties \u00b6 entityName \u00b6 \u2022 Optional entityName : string Defined in \u00b6 api.ts:155 getSchema \u00b6 \u2022 Optional getSchema : MetadataFormula Defined in \u00b6 api.ts:154 getter \u00b6 \u2022 getter : SyncFormula < K , L , ParamDefsT , SchemaT > Defined in \u00b6 api.ts:153 name \u00b6 \u2022 name : string Defined in \u00b6 api.ts:151 schema \u00b6 \u2022 schema : SchemaT Defined in \u00b6 api.ts:152","title":"Interface: SyncTableDef<K, L, ParamDefsT, SchemaT\\>"},{"location":"reference/sdk/interfaces/SyncTableDef/#interface-synctabledefk-l-paramdefst-schemat","text":"Type definition for a Sync Table. Should not be necessary to use directly, instead, define sync tables using makeSyncTable .","title":"Interface: SyncTableDef&lt;K, L, ParamDefsT, SchemaT>"},{"location":"reference/sdk/interfaces/SyncTableDef/#type-parameters","text":"Name Type K extends string L extends string ParamDefsT extends ParamDefs SchemaT extends ObjectSchema < K , L >","title":"Type parameters"},{"location":"reference/sdk/interfaces/SyncTableDef/#hierarchy","text":"SyncTableDef \u21b3 DynamicSyncTableDef","title":"Hierarchy"},{"location":"reference/sdk/interfaces/SyncTableDef/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/SyncTableDef/#entityname","text":"\u2022 Optional entityName : string","title":"entityName"},{"location":"reference/sdk/interfaces/SyncTableDef/#getschema","text":"\u2022 Optional getSchema : MetadataFormula","title":"getSchema"},{"location":"reference/sdk/interfaces/SyncTableDef/#getter","text":"\u2022 getter : SyncFormula < K , L , ParamDefsT , SchemaT >","title":"getter"},{"location":"reference/sdk/interfaces/SyncTableDef/#name","text":"\u2022 name : string","title":"name"},{"location":"reference/sdk/interfaces/SyncTableDef/#schema","text":"\u2022 schema : SchemaT","title":"schema"},{"location":"reference/sdk/interfaces/TemporaryBlobStorage/","text":"Interface: TemporaryBlobStorage \u00b6 A utility for temporarily storing files and images that either require authentication or are too large to return inline. When syncing data from certain APIs, a response object may include the URL of a file or image that can only be downloaded with the user's authentication credentials. Normally, you can just return an image or file URL from a formula invocation, and if the schema indicates that the value represents an attachment, Coda will ingest the data at that URL and host it from Coda. However, if the URL requires authentication, Coda will be unable to download the data since this ingestion does not happen within the packs execution environment. The solution is for your pack code to fetch the data at the URL, since the pack execution environment will apply the user's authentication, and then you can stash the downloaded value in TemporaryBlobStorage , which will return a temporary URL that you can return from the pack. Coda will be able to ingest the data from that temporary URL. Similarly, suppose your formula generates a very large value like a dynamically-generated image that you wish to return and have Coda render. Pack return values are meant to be fairly small, representing human-readable data. Large values like images are meant to be returned as URLs referencing that data. So rather than return the raw image data, your pack should use storeBlob to upload that large data to temporary storage. You will be returned a URL that you can then return with your formula response, and Coda will ingest the data from that URL into permanent storage. Methods \u00b6 storeBlob \u00b6 \u25b8 storeBlob ( blobData , contentType , opts? ): Promise < string > Stores the given data as a file with the given content type in Coda-hosted temporary storage. Returns a URL for the temporary file that you should return in your formula response. The URL expires after 15 minutes by default, but you may pass a custom expiry, however Coda reserves the right to ignore long expirations. Parameters \u00b6 Name Type blobData Buffer contentType string opts? Object opts.expiryMs? number Returns \u00b6 Promise < string > Defined in \u00b6 api_types.ts:494 storeUrl \u00b6 \u25b8 storeUrl ( url , opts? ): Promise < string > Fetches the data at the given URL, applying user authentication credentials as appropriate, and stores it in Coda-hosted temporary storage. Returns a URL for the temporary file that you should return in your formula response. The URL expires after 15 minutes by default, but you may pass a custom expiry, however Coda reserves the right to ignore long expirations. Parameters \u00b6 Name Type url string opts? Object opts.expiryMs? number Returns \u00b6 Promise < string > Defined in \u00b6 api_types.ts:486","title":"Interface: TemporaryBlobStorage"},{"location":"reference/sdk/interfaces/TemporaryBlobStorage/#interface-temporaryblobstorage","text":"A utility for temporarily storing files and images that either require authentication or are too large to return inline. When syncing data from certain APIs, a response object may include the URL of a file or image that can only be downloaded with the user's authentication credentials. Normally, you can just return an image or file URL from a formula invocation, and if the schema indicates that the value represents an attachment, Coda will ingest the data at that URL and host it from Coda. However, if the URL requires authentication, Coda will be unable to download the data since this ingestion does not happen within the packs execution environment. The solution is for your pack code to fetch the data at the URL, since the pack execution environment will apply the user's authentication, and then you can stash the downloaded value in TemporaryBlobStorage , which will return a temporary URL that you can return from the pack. Coda will be able to ingest the data from that temporary URL. Similarly, suppose your formula generates a very large value like a dynamically-generated image that you wish to return and have Coda render. Pack return values are meant to be fairly small, representing human-readable data. Large values like images are meant to be returned as URLs referencing that data. So rather than return the raw image data, your pack should use storeBlob to upload that large data to temporary storage. You will be returned a URL that you can then return with your formula response, and Coda will ingest the data from that URL into permanent storage.","title":"Interface: TemporaryBlobStorage"},{"location":"reference/sdk/interfaces/TemporaryBlobStorage/#methods","text":"","title":"Methods"},{"location":"reference/sdk/interfaces/TemporaryBlobStorage/#storeblob","text":"\u25b8 storeBlob ( blobData , contentType , opts? ): Promise < string > Stores the given data as a file with the given content type in Coda-hosted temporary storage. Returns a URL for the temporary file that you should return in your formula response. The URL expires after 15 minutes by default, but you may pass a custom expiry, however Coda reserves the right to ignore long expirations.","title":"storeBlob"},{"location":"reference/sdk/interfaces/TemporaryBlobStorage/#storeurl","text":"\u25b8 storeUrl ( url , opts? ): Promise < string > Fetches the data at the given URL, applying user authentication credentials as appropriate, and stores it in Coda-hosted temporary storage. Returns a URL for the temporary file that you should return in your formula response. The URL expires after 15 minutes by default, but you may pass a custom expiry, however Coda reserves the right to ignore long expirations.","title":"storeUrl"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/","text":"Interface: WebBasicAuthentication \u00b6 Authenticate using HTTP Basic authorization. The user provides a username and password (sometimes optional) which are included as an HTTP header according to the Basic auth standard. See https://en.wikipedia.org/wiki/Basic_access_authentication Hierarchy \u00b6 BaseAuthentication \u21b3 WebBasicAuthentication Properties \u00b6 defaultConnectionType \u00b6 \u2022 Optional defaultConnectionType : DefaultConnectionType Indicates the defualt manner in which a user's account is expected to be used by this pack, e.g. is this account used for retrieving data, taking actions, or both. See https://help.coda.io/en/articles/4587167-what-can-coda-access-with-packs#h_40472431f0 Inherited from \u00b6 BaseAuthentication.defaultConnectionType Defined in \u00b6 types.ts:207 endpointDomain \u00b6 \u2022 Optional endpointDomain : string When requiresEndpointUrl is set to true this should be the root domain that all endpoints share. For example, this value would be \"example.com\" if specific endpoints looked like {custom-subdomain}.example.com. For packs that make requests to multiple domains (uncommon), this should be the domain within networkDomains that this configuration applies to. Inherited from \u00b6 BaseAuthentication.endpointDomain Defined in \u00b6 types.ts:229 getConnectionName \u00b6 \u2022 Optional getConnectionName : MetadataFormula Inherited from \u00b6 BaseAuthentication.getConnectionName Defined in \u00b6 types.ts:199 getConnectionUserId \u00b6 \u2022 Optional getConnectionUserId : MetadataFormula Inherited from \u00b6 BaseAuthentication.getConnectionUserId Defined in \u00b6 types.ts:200 instructionsUrl \u00b6 \u2022 Optional instructionsUrl : string A link to a help article or other page with more instructions about how to set up an account for this pack. Inherited from \u00b6 BaseAuthentication.instructionsUrl Defined in \u00b6 types.ts:212 postSetup \u00b6 \u2022 Optional postSetup : SetEndpoint [] One or more setup steps to run after the user has set up the account, before completing installation of the pack. This is not common. Inherited from \u00b6 BaseAuthentication.postSetup Defined in \u00b6 types.ts:235 requiresEndpointUrl \u00b6 \u2022 Optional requiresEndpointUrl : boolean If true, indicates this has pack has a specific endpoint domain for each account, that is used as the basis of HTTP requests. For example, API requests are made to .example.com rather than example.com. If true, the user will be prompted to provide their specific endpoint domain when creating a new account. Inherited from \u00b6 BaseAuthentication.requiresEndpointUrl Defined in \u00b6 types.ts:220 type \u00b6 \u2022 type : WebBasic Defined in \u00b6 types.ts:394 uxConfig \u00b6 \u2022 Optional uxConfig : Object Configuration for labels to show in the UI when the user sets up a new acount. Type declaration \u00b6 Name Type Description placeholderPassword? string A placeholder value for the text input where the user will enter a password. placeholderUsername? string A placeholder value for the text input where the user will enter a username. usernameOnly? boolean If true, only a username input will be shown to the user. Some services pass API keys in the username field and do not require a password. Defined in \u00b6 types.ts:398","title":"Interface: WebBasicAuthentication"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#interface-webbasicauthentication","text":"Authenticate using HTTP Basic authorization. The user provides a username and password (sometimes optional) which are included as an HTTP header according to the Basic auth standard. See https://en.wikipedia.org/wiki/Basic_access_authentication","title":"Interface: WebBasicAuthentication"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#hierarchy","text":"BaseAuthentication \u21b3 WebBasicAuthentication","title":"Hierarchy"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#properties","text":"","title":"Properties"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#defaultconnectiontype","text":"\u2022 Optional defaultConnectionType : DefaultConnectionType Indicates the defualt manner in which a user's account is expected to be used by this pack, e.g. is this account used for retrieving data, taking actions, or both. See https://help.coda.io/en/articles/4587167-what-can-coda-access-with-packs#h_40472431f0","title":"defaultConnectionType"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#endpointdomain","text":"\u2022 Optional endpointDomain : string When requiresEndpointUrl is set to true this should be the root domain that all endpoints share. For example, this value would be \"example.com\" if specific endpoints looked like {custom-subdomain}.example.com. For packs that make requests to multiple domains (uncommon), this should be the domain within networkDomains that this configuration applies to.","title":"endpointDomain"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#getconnectionname","text":"\u2022 Optional getConnectionName : MetadataFormula","title":"getConnectionName"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#getconnectionuserid","text":"\u2022 Optional getConnectionUserId : MetadataFormula","title":"getConnectionUserId"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#instructionsurl","text":"\u2022 Optional instructionsUrl : string A link to a help article or other page with more instructions about how to set up an account for this pack.","title":"instructionsUrl"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#postsetup","text":"\u2022 Optional postSetup : SetEndpoint [] One or more setup steps to run after the user has set up the account, before completing installation of the pack. This is not common.","title":"postSetup"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#requiresendpointurl","text":"\u2022 Optional requiresEndpointUrl : boolean If true, indicates this has pack has a specific endpoint domain for each account, that is used as the basis of HTTP requests. For example, API requests are made to .example.com rather than example.com. If true, the user will be prompted to provide their specific endpoint domain when creating a new account.","title":"requiresEndpointUrl"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#type","text":"\u2022 type : WebBasic","title":"type"},{"location":"reference/sdk/interfaces/WebBasicAuthentication/#uxconfig","text":"\u2022 Optional uxConfig : Object Configuration for labels to show in the UI when the user sets up a new acount.","title":"uxConfig"},{"location":"reference/sdk/types/Authentication/","text":"Type alias: Authentication \u00b6 \u01ac Authentication : NoAuthentication | VariousAuthentication | HeaderBearerTokenAuthentication | CodaApiBearerTokenAuthentication | CustomHeaderTokenAuthentication | QueryParamTokenAuthentication | MultiQueryParamTokenAuthentication | OAuth2Authentication | WebBasicAuthentication | AWSSignature4Authentication The union of supported authentication methods. Defined in \u00b6 types.ts:441","title":"Type alias: Authentication"},{"location":"reference/sdk/types/Authentication/#type-alias-authentication","text":"\u01ac Authentication : NoAuthentication | VariousAuthentication | HeaderBearerTokenAuthentication | CodaApiBearerTokenAuthentication | CustomHeaderTokenAuthentication | QueryParamTokenAuthentication | MultiQueryParamTokenAuthentication | OAuth2Authentication | WebBasicAuthentication | AWSSignature4Authentication The union of supported authentication methods.","title":"Type alias: Authentication"},{"location":"reference/sdk/types/BasicPackDefinition/","text":"Type alias: BasicPackDefinition \u00b6 \u01ac BasicPackDefinition : Omit < PackVersionDefinition , \"version\" > A pack definition without an author-defined semantic version, for use in the web editor where Coda will manage versioning on behalf of the pack author. Defined in \u00b6 types.ts:669","title":"Type alias: BasicPackDefinition"},{"location":"reference/sdk/types/BasicPackDefinition/#type-alias-basicpackdefinition","text":"\u01ac BasicPackDefinition : Omit < PackVersionDefinition , \"version\" > A pack definition without an author-defined semantic version, for use in the web editor where Coda will manage versioning on behalf of the pack author.","title":"Type alias: BasicPackDefinition"},{"location":"reference/sdk/types/DefaultValueType/","text":"Type alias: DefaultValueType<T> \u00b6 \u01ac DefaultValueType < T >: T extends ArrayType < date > ? TypeOfMap < T > | PrecannedDateRange : TypeOfMap < T > Type parameters \u00b6 Name Type T extends UnionType Defined in \u00b6 api_types.ts:239","title":"Type alias: DefaultValueType<T\\>"},{"location":"reference/sdk/types/DefaultValueType/#type-alias-defaultvaluetypet","text":"\u01ac DefaultValueType < T >: T extends ArrayType < date > ? TypeOfMap < T > | PrecannedDateRange : TypeOfMap < T >","title":"Type alias: DefaultValueType&lt;T>"},{"location":"reference/sdk/types/ExternalObjectPackFormula/","text":"Type alias: ExternalObjectPackFormula \u00b6 \u01ac ExternalObjectPackFormula : ObjectPackFormulaMetadata Defined in \u00b6 compiled_types.ts:83","title":"Type alias: ExternalObjectPackFormula"},{"location":"reference/sdk/types/ExternalObjectPackFormula/#type-alias-externalobjectpackformula","text":"\u01ac ExternalObjectPackFormula : ObjectPackFormulaMetadata","title":"Type alias: ExternalObjectPackFormula"},{"location":"reference/sdk/types/ExternalPackFormat/","text":"Type alias: ExternalPackFormat \u00b6 \u01ac ExternalPackFormat : Format Defined in \u00b6 compiled_types.ts:85","title":"Type alias: ExternalPackFormat"},{"location":"reference/sdk/types/ExternalPackFormat/#type-alias-externalpackformat","text":"\u01ac ExternalPackFormat : Format","title":"Type alias: ExternalPackFormat"},{"location":"reference/sdk/types/ExternalPackFormatMetadata/","text":"Type alias: ExternalPackFormatMetadata \u00b6 \u01ac ExternalPackFormatMetadata : PackFormatMetadata Defined in \u00b6 compiled_types.ts:86","title":"Type alias: ExternalPackFormatMetadata"},{"location":"reference/sdk/types/ExternalPackFormatMetadata/#type-alias-externalpackformatmetadata","text":"\u01ac ExternalPackFormatMetadata : PackFormatMetadata","title":"Type alias: ExternalPackFormatMetadata"},{"location":"reference/sdk/types/ExternalPackFormula/","text":"Type alias: ExternalPackFormula \u00b6 \u01ac ExternalPackFormula : PackFormulaMetadata Defined in \u00b6 compiled_types.ts:84","title":"Type alias: ExternalPackFormula"},{"location":"reference/sdk/types/ExternalPackFormula/#type-alias-externalpackformula","text":"\u01ac ExternalPackFormula : PackFormulaMetadata","title":"Type alias: ExternalPackFormula"},{"location":"reference/sdk/types/ExternalPackFormulas/","text":"Type alias: ExternalPackFormulas \u00b6 \u01ac ExternalPackFormulas : PackFormulasMetadata | PackFormulaMetadata [] Defined in \u00b6 compiled_types.ts:82","title":"Type alias: ExternalPackFormulas"},{"location":"reference/sdk/types/ExternalPackFormulas/#type-alias-externalpackformulas","text":"\u01ac ExternalPackFormulas : PackFormulasMetadata | PackFormulaMetadata []","title":"Type alias: ExternalPackFormulas"},{"location":"reference/sdk/types/ExternalPackMetadata/","text":"Type alias: ExternalPackMetadata \u00b6 \u01ac ExternalPackMetadata : ExternalPackVersionMetadata & Pick < PackMetadata , \"id\" | \"name\" | \"shortDescription\" | \"description\" | \"permissionsDescription\" | \"category\" | \"logoPath\" | \"exampleImages\" | \"exampleVideoIds\" | \"minimumFeatureSet\" | \"quotas\" | \"rateLimits\" | \"isSystem\" > Further stripped-down version of PackMetadata that contains only what the browser needs. Defined in \u00b6 compiled_types.ts:114","title":"Type alias: ExternalPackMetadata"},{"location":"reference/sdk/types/ExternalPackMetadata/#type-alias-externalpackmetadata","text":"\u01ac ExternalPackMetadata : ExternalPackVersionMetadata & Pick < PackMetadata , \"id\" | \"name\" | \"shortDescription\" | \"description\" | \"permissionsDescription\" | \"category\" | \"logoPath\" | \"exampleImages\" | \"exampleVideoIds\" | \"minimumFeatureSet\" | \"quotas\" | \"rateLimits\" | \"isSystem\" > Further stripped-down version of PackMetadata that contains only what the browser needs.","title":"Type alias: ExternalPackMetadata"},{"location":"reference/sdk/types/ExternalSyncTable/","text":"Type alias: ExternalSyncTable \u00b6 \u01ac ExternalSyncTable : PackSyncTable Defined in \u00b6 compiled_types.ts:87","title":"Type alias: ExternalSyncTable"},{"location":"reference/sdk/types/ExternalSyncTable/#type-alias-externalsynctable","text":"\u01ac ExternalSyncTable : PackSyncTable","title":"Type alias: ExternalSyncTable"},{"location":"reference/sdk/types/FetchMethodType/","text":"Type alias: FetchMethodType \u00b6 \u01ac FetchMethodType : typeof ValidFetchMethods [ number ] Defined in \u00b6 api_types.ts:352","title":"Type alias: FetchMethodType"},{"location":"reference/sdk/types/FetchMethodType/#type-alias-fetchmethodtype","text":"\u01ac FetchMethodType : typeof ValidFetchMethods [ number ]","title":"Type alias: FetchMethodType"},{"location":"reference/sdk/types/Formula/","text":"Type alias: Formula<ParamDefsT, ResultT, SchemaT> \u00b6 \u01ac Formula < ParamDefsT , ResultT , SchemaT >: ResultT extends String ? StringPackFormula < ParamDefsT > : ResultT extends Number ? NumericPackFormula < ParamDefsT > : ResultT extends Boolean ? BooleanPackFormula < ParamDefsT > : ResultT extends Array ? ObjectPackFormula < ParamDefsT , ArraySchema < SchemaT >> : ObjectPackFormula < ParamDefsT , SchemaT > Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs ParamDefs ResultT extends FormulaResultValueType``FormulaResultValueType SchemaT extends Schema Schema Defined in \u00b6 api.ts:453","title":"Type alias: Formula<ParamDefsT, ResultT, SchemaT\\>"},{"location":"reference/sdk/types/Formula/#type-alias-formulaparamdefst-resultt-schemat","text":"\u01ac Formula < ParamDefsT , ResultT , SchemaT >: ResultT extends String ? StringPackFormula < ParamDefsT > : ResultT extends Number ? NumericPackFormula < ParamDefsT > : ResultT extends Boolean ? BooleanPackFormula < ParamDefsT > : ResultT extends Array ? ObjectPackFormula < ParamDefsT , ArraySchema < SchemaT >> : ObjectPackFormula < ParamDefsT , SchemaT >","title":"Type alias: Formula&lt;ParamDefsT, ResultT, SchemaT>"},{"location":"reference/sdk/types/GenericDynamicSyncTable/","text":"Type alias: GenericDynamicSyncTable \u00b6 \u01ac GenericDynamicSyncTable : DynamicSyncTableDef < any , any , ParamDefs , any > Type definition for a dynamic sync table. Should not be necessary to use directly, see makeDynamicSyncTable for defining a sync table. Defined in \u00b6 api.ts:225","title":"Type alias: GenericDynamicSyncTable"},{"location":"reference/sdk/types/GenericDynamicSyncTable/#type-alias-genericdynamicsynctable","text":"\u01ac GenericDynamicSyncTable : DynamicSyncTableDef < any , any , ParamDefs , any > Type definition for a dynamic sync table. Should not be necessary to use directly, see makeDynamicSyncTable for defining a sync table.","title":"Type alias: GenericDynamicSyncTable"},{"location":"reference/sdk/types/GenericObjectSchema/","text":"Type alias: GenericObjectSchema \u00b6 \u01ac GenericObjectSchema : ObjectSchema < string , string > Defined in \u00b6 schema.ts:542","title":"Type alias: GenericObjectSchema"},{"location":"reference/sdk/types/GenericObjectSchema/#type-alias-genericobjectschema","text":"\u01ac GenericObjectSchema : ObjectSchema < string , string >","title":"Type alias: GenericObjectSchema"},{"location":"reference/sdk/types/GenericSyncFormula/","text":"Type alias: GenericSyncFormula \u00b6 \u01ac GenericSyncFormula : SyncFormula < any , any , ParamDefs , any > Type definition for the formula that implements a sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table. Defined in \u00b6 api.ts:207","title":"Type alias: GenericSyncFormula"},{"location":"reference/sdk/types/GenericSyncFormula/#type-alias-genericsyncformula","text":"\u01ac GenericSyncFormula : SyncFormula < any , any , ParamDefs , any > Type definition for the formula that implements a sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table.","title":"Type alias: GenericSyncFormula"},{"location":"reference/sdk/types/GenericSyncFormulaResult/","text":"Type alias: GenericSyncFormulaResult \u00b6 \u01ac GenericSyncFormulaResult : SyncFormulaResult < any , any , any > Type definition for the return value of a sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table. Defined in \u00b6 api.ts:213","title":"Type alias: GenericSyncFormulaResult"},{"location":"reference/sdk/types/GenericSyncFormulaResult/#type-alias-genericsyncformularesult","text":"\u01ac GenericSyncFormulaResult : SyncFormulaResult < any , any , any > Type definition for the return value of a sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table.","title":"Type alias: GenericSyncFormulaResult"},{"location":"reference/sdk/types/GenericSyncTable/","text":"Type alias: GenericSyncTable \u00b6 \u01ac GenericSyncTable : SyncTableDef < any , any , ParamDefs , any > Type definition for a static (non-dynamic) sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table. Defined in \u00b6 api.ts:219","title":"Type alias: GenericSyncTable"},{"location":"reference/sdk/types/GenericSyncTable/#type-alias-genericsynctable","text":"\u01ac GenericSyncTable : SyncTableDef < any , any , ParamDefs , any > Type definition for a static (non-dynamic) sync table. Should not be necessary to use directly, see makeSyncTable for defining a sync table.","title":"Type alias: GenericSyncTable"},{"location":"reference/sdk/types/MetadataContext/","text":"Type alias: MetadataContext \u00b6 \u01ac MetadataContext : Record < string , any > A context object that is provided to a metadata formula at execution time. For example, an autocomplete metadata formula for a parameter value may need to know the value of parameters that have already been selected. Those parameter values are provided in this context object. Defined in \u00b6 api.ts:780","title":"Type alias: MetadataContext"},{"location":"reference/sdk/types/MetadataContext/#type-alias-metadatacontext","text":"\u01ac MetadataContext : Record < string , any > A context object that is provided to a metadata formula at execution time. For example, an autocomplete metadata formula for a parameter value may need to know the value of parameters that have already been selected. Those parameter values are provided in this context object.","title":"Type alias: MetadataContext"},{"location":"reference/sdk/types/MetadataFormula/","text":"Type alias: MetadataFormula \u00b6 \u01ac MetadataFormula : BaseFormula <[ ParamDef < string >, ParamDef < string >], any > & { schema? : any } Defined in \u00b6 api.ts:783","title":"Type alias: MetadataFormula"},{"location":"reference/sdk/types/MetadataFormula/#type-alias-metadataformula","text":"\u01ac MetadataFormula : BaseFormula <[ ParamDef < string >, ParamDef < string >], any > & { schema? : any }","title":"Type alias: MetadataFormula"},{"location":"reference/sdk/types/MetadataFormulaResultType/","text":"Type alias: MetadataFormulaResultType \u00b6 \u01ac MetadataFormulaResultType : string | number | MetadataFormulaObjectResultType Defined in \u00b6 api.ts:782","title":"Type alias: MetadataFormulaResultType"},{"location":"reference/sdk/types/MetadataFormulaResultType/#type-alias-metadataformularesulttype","text":"\u01ac MetadataFormulaResultType : string | number | MetadataFormulaObjectResultType","title":"Type alias: MetadataFormulaResultType"},{"location":"reference/sdk/types/NumberSchema/","text":"Type alias: NumberSchema \u00b6 \u01ac NumberSchema : CurrencySchema | SliderSchema | ScaleSchema | NumericSchema | NumericDateSchema | NumericTimeSchema | NumericDateTimeSchema The union of all schemas that can represent number values. Defined in \u00b6 schema.ts:206","title":"Type alias: NumberSchema"},{"location":"reference/sdk/types/NumberSchema/#type-alias-numberschema","text":"\u01ac NumberSchema : CurrencySchema | SliderSchema | ScaleSchema | NumericSchema | NumericDateSchema | NumericTimeSchema | NumericDateTimeSchema The union of all schemas that can represent number values.","title":"Type alias: NumberSchema"},{"location":"reference/sdk/types/ObjectSchemaProperties/","text":"Type alias: ObjectSchemaProperties<K> \u00b6 \u01ac ObjectSchemaProperties < K >: { [K2 in K | string]: Schema & ObjectSchemaProperty } Type parameters \u00b6 Name Type K extends string``never Defined in \u00b6 schema.ts:538","title":"Type alias: ObjectSchemaProperties<K\\>"},{"location":"reference/sdk/types/ObjectSchemaProperties/#type-alias-objectschemapropertiesk","text":"\u01ac ObjectSchemaProperties < K >: { [K2 in K | string]: Schema & ObjectSchemaProperty }","title":"Type alias: ObjectSchemaProperties&lt;K>"},{"location":"reference/sdk/types/PackFormulaMetadata/","text":"Type alias: PackFormulaMetadata \u00b6 \u01ac PackFormulaMetadata : Omit < TypedPackFormula , \"execute\" > Defined in \u00b6 api.ts:477","title":"Type alias: PackFormulaMetadata"},{"location":"reference/sdk/types/PackFormulaMetadata/#type-alias-packformulametadata","text":"\u01ac PackFormulaMetadata : Omit < TypedPackFormula , \"execute\" >","title":"Type alias: PackFormulaMetadata"},{"location":"reference/sdk/types/PackFormulaResult/","text":"Type alias: PackFormulaResult \u00b6 \u01ac PackFormulaResult : $Values < TypeMap > | PackFormulaResult [] Defined in \u00b6 api_types.ts:79","title":"Type alias: PackFormulaResult"},{"location":"reference/sdk/types/PackFormulaResult/#type-alias-packformularesult","text":"\u01ac PackFormulaResult : $Values < TypeMap > | PackFormulaResult []","title":"Type alias: PackFormulaResult"},{"location":"reference/sdk/types/PackFormulaValue/","text":"Type alias: PackFormulaValue \u00b6 \u01ac PackFormulaValue : $Values < Omit < TypeMap , object >> | PackFormulaValue [] Defined in \u00b6 api_types.ts:78","title":"Type alias: PackFormulaValue"},{"location":"reference/sdk/types/PackFormulaValue/#type-alias-packformulavalue","text":"\u01ac PackFormulaValue : $Values < Omit < TypeMap , object >> | PackFormulaValue []","title":"Type alias: PackFormulaValue"},{"location":"reference/sdk/types/PackId/","text":"Type alias: PackId \u00b6 \u01ac PackId : number deprecated Use number in new code. Defined in \u00b6 types.ts:11","title":"Type alias: PackId"},{"location":"reference/sdk/types/PackId/#type-alias-packid","text":"\u01ac PackId : number deprecated Use number in new code.","title":"Type alias: PackId"},{"location":"reference/sdk/types/PackMetadata/","text":"Type alias: PackMetadata \u00b6 \u01ac PackMetadata : PackVersionMetadata & Pick < PackDefinition , \"id\" | \"name\" | \"shortDescription\" | \"description\" | \"permissionsDescription\" | \"category\" | \"logoPath\" | \"exampleImages\" | \"exampleVideoIds\" | \"minimumFeatureSet\" | \"quotas\" | \"rateLimits\" | \"enabledConfigName\" | \"isSystem\" > Stripped-down version of PackDefinition that doesn't contain formula definitions. Defined in \u00b6 compiled_types.ts:60","title":"Type alias: PackMetadata"},{"location":"reference/sdk/types/PackMetadata/#type-alias-packmetadata","text":"\u01ac PackMetadata : PackVersionMetadata & Pick < PackDefinition , \"id\" | \"name\" | \"shortDescription\" | \"description\" | \"permissionsDescription\" | \"category\" | \"logoPath\" | \"exampleImages\" | \"exampleVideoIds\" | \"minimumFeatureSet\" | \"quotas\" | \"rateLimits\" | \"enabledConfigName\" | \"isSystem\" > Stripped-down version of PackDefinition that doesn't contain formula definitions.","title":"Type alias: PackMetadata"},{"location":"reference/sdk/types/PackSyncTable/","text":"Type alias: PackSyncTable \u00b6 \u01ac PackSyncTable : Omit < SyncTable , \"getter\" | \"getName\" | \"getSchema\" | \"listDynamicUrls\" | \"getDisplayUrl\" > & { getDisplayUrl? : MetadataFormulaMetadata ; getName? : MetadataFormulaMetadata ; getSchema? : MetadataFormulaMetadata ; getter : PackFormulaMetadata ; hasDynamicSchema? : boolean ; isDynamic? : boolean ; listDynamicUrls? : MetadataFormulaMetadata } Defined in \u00b6 compiled_types.ts:13","title":"Type alias: PackSyncTable"},{"location":"reference/sdk/types/PackSyncTable/#type-alias-packsynctable","text":"\u01ac PackSyncTable : Omit < SyncTable , \"getter\" | \"getName\" | \"getSchema\" | \"listDynamicUrls\" | \"getDisplayUrl\" > & { getDisplayUrl? : MetadataFormulaMetadata ; getName? : MetadataFormulaMetadata ; getSchema? : MetadataFormulaMetadata ; getter : PackFormulaMetadata ; hasDynamicSchema? : boolean ; isDynamic? : boolean ; listDynamicUrls? : MetadataFormulaMetadata }","title":"Type alias: PackSyncTable"},{"location":"reference/sdk/types/PackVersionMetadata/","text":"Type alias: PackVersionMetadata \u00b6 \u01ac PackVersionMetadata : Omit < PackVersionDefinition , \"formulas\" | \"formats\" | \"defaultAuthentication\" | \"syncTables\" > & { defaultAuthentication? : AuthenticationMetadata ; formats : PackFormatMetadata [] ; formulas : PackFormulasMetadata | PackFormulaMetadata [] ; syncTables : PackSyncTable [] } Stripped-down version of PackVersionDefinition that doesn't contain formula definitions. Defined in \u00b6 compiled_types.ts:48","title":"Type alias: PackVersionMetadata"},{"location":"reference/sdk/types/PackVersionMetadata/#type-alias-packversionmetadata","text":"\u01ac PackVersionMetadata : Omit < PackVersionDefinition , \"formulas\" | \"formats\" | \"defaultAuthentication\" | \"syncTables\" > & { defaultAuthentication? : AuthenticationMetadata ; formats : PackFormatMetadata [] ; formulas : PackFormulasMetadata | PackFormulaMetadata [] ; syncTables : PackSyncTable [] } Stripped-down version of PackVersionDefinition that doesn't contain formula definitions.","title":"Type alias: PackVersionMetadata"},{"location":"reference/sdk/types/ParamDefs/","text":"Type alias: ParamDefs \u00b6 \u01ac ParamDefs : [ ParamDef < UnionType >, ...ParamDef<UnionType>[]] | [] Defined in \u00b6 api_types.ts:225","title":"Type alias: ParamDefs"},{"location":"reference/sdk/types/ParamDefs/#type-alias-paramdefs","text":"\u01ac ParamDefs : [ ParamDef < UnionType >, ...ParamDef<UnionType>[]] | []","title":"Type alias: ParamDefs"},{"location":"reference/sdk/types/ParamValues/","text":"Type alias: ParamValues<ParamDefsT> \u00b6 \u01ac ParamValues < ParamDefsT >: { [K in keyof ParamDefsT]: ParamDefsT[K] extends ParamDef<infer T> ? TypeOfMap<T> : never } & any [] Type parameters \u00b6 Name Type ParamDefsT extends ParamDefs Defined in \u00b6 api_types.ts:235","title":"Type alias: ParamValues<ParamDefsT\\>"},{"location":"reference/sdk/types/ParamValues/#type-alias-paramvaluesparamdefst","text":"\u01ac ParamValues < ParamDefsT >: { [K in keyof ParamDefsT]: ParamDefsT[K] extends ParamDef<infer T> ? TypeOfMap<T> : never } & any []","title":"Type alias: ParamValues&lt;ParamDefsT>"},{"location":"reference/sdk/types/ParamsList/","text":"Type alias: ParamsList \u00b6 \u01ac ParamsList : ParamDef < UnionType >[] Defined in \u00b6 api_types.ts:227","title":"Type alias: ParamsList"},{"location":"reference/sdk/types/ParamsList/#type-alias-paramslist","text":"\u01ac ParamsList : ParamDef < UnionType >[]","title":"Type alias: ParamsList"},{"location":"reference/sdk/types/Schema/","text":"Type alias: Schema \u00b6 \u01ac Schema : BooleanSchema | NumberSchema | StringSchema | ArraySchema | GenericObjectSchema Defined in \u00b6 schema.ts:635","title":"Type alias: Schema"},{"location":"reference/sdk/types/Schema/#type-alias-schema","text":"\u01ac Schema : BooleanSchema | NumberSchema | StringSchema | ArraySchema | GenericObjectSchema","title":"Type alias: Schema"},{"location":"reference/sdk/types/SchemaType/","text":"Type alias: SchemaType<T> \u00b6 \u01ac SchemaType < T >: T extends BooleanSchema ? boolean : T extends NumberSchema ? number : T extends StringSchema ? StringHintTypeToSchemaType < T [ \"codaType\" ]> : T extends ArraySchema ? SchemaType < T [ \"items\" ]>[] : T extends GenericObjectSchema ? ObjectSchemaType < T > : never Type parameters \u00b6 Name Type T extends Schema Defined in \u00b6 schema.ts:685","title":"Type alias: SchemaType<T\\>"},{"location":"reference/sdk/types/SchemaType/#type-alias-schematypet","text":"\u01ac SchemaType < T >: T extends BooleanSchema ? boolean : T extends NumberSchema ? number : T extends StringSchema ? StringHintTypeToSchemaType < T [ \"codaType\" ]> : T extends ArraySchema ? SchemaType < T [ \"items\" ]>[] : T extends GenericObjectSchema ? ObjectSchemaType < T > : never","title":"Type alias: SchemaType&lt;T>"},{"location":"reference/sdk/types/StringSchema/","text":"Type alias: StringSchema \u00b6 \u01ac StringSchema : StringDateSchema | StringTimeSchema | StringDateTimeSchema | DurationSchema | SimpleStringSchema Defined in \u00b6 schema.ts:515","title":"Type alias: StringSchema"},{"location":"reference/sdk/types/StringSchema/#type-alias-stringschema","text":"\u01ac StringSchema : StringDateSchema | StringTimeSchema | StringDateTimeSchema | DurationSchema | SimpleStringSchema","title":"Type alias: StringSchema"},{"location":"reference/sdk/types/SystemAuthentication/","text":"Type alias: SystemAuthentication \u00b6 \u01ac SystemAuthentication : HeaderBearerTokenAuthentication | CustomHeaderTokenAuthentication | QueryParamTokenAuthentication | MultiQueryParamTokenAuthentication | WebBasicAuthentication | AWSSignature4Authentication The union of authentication methods that are supported for system authentication, where the pack author provides credentials used in HTTP requests rather than the user. Defined in \u00b6 types.ts:498","title":"Type alias: SystemAuthentication"},{"location":"reference/sdk/types/SystemAuthentication/#type-alias-systemauthentication","text":"\u01ac SystemAuthentication : HeaderBearerTokenAuthentication | CustomHeaderTokenAuthentication | QueryParamTokenAuthentication | MultiQueryParamTokenAuthentication | WebBasicAuthentication | AWSSignature4Authentication The union of authentication methods that are supported for system authentication, where the pack author provides credentials used in HTTP requests rather than the user.","title":"Type alias: SystemAuthentication"},{"location":"reference/sdk/types/TypedPackFormula/","text":"Type alias: TypedPackFormula \u00b6 \u01ac TypedPackFormula : Formula | GenericSyncFormula Defined in \u00b6 api.ts:474","title":"Type alias: TypedPackFormula"},{"location":"reference/sdk/types/TypedPackFormula/#type-alias-typedpackformula","text":"\u01ac TypedPackFormula : Formula | GenericSyncFormula","title":"Type alias: TypedPackFormula"},{"location":"samples/full/cats/","text":"Cats sample \u00b6 This Pack provides allows you to fetch random cat photos using the Cat-as-a-service API . You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides: A formula for fetching a cat photo. A column format that displays the text on top of a cat photo. A sync table that retrieves all available cat photos. pack.ts import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); pack . addNetworkDomain ( \"cataas.com\" ); // Tag parameter, shared across multiple formulas. const TagParameter = coda . makeParameter ({ type : coda . ParameterType . String , name : \"tag\" , description : \"Only cats with this tag will be selected.\" , optional : true , // Pull the list of tags to use for autocomplete from the API. autocomplete : async function ( context , search ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/api/tags\" , }); let tags = response . body ; // Convert the tags into a list of autocomplete options. return coda . simpleAutocomplete ( search , tags ); }, }); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"size\" , description : \"The size of the text, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"color\" , description : \"The color of the text. Any valid CSS color can be used.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"width\" , description : \"The width of the desired image, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"height\" , description : \"The height of the desired image, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"filter\" , description : \"A filter to apply to the image.\" , autocomplete : [ \"blur\" , \"mono\" , \"sepia\" , \"negative\" , \"paint\" , \"pixel\" ], optional : true , }), TagParameter , ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text , size , color , width , height , filter , tag ], context ) { let url = \"https://cataas.com/cat\" ; if ( tag ) { url += \"/\" + tag ; } if ( text ) { url += \"/says/\" + encodeURIComponent ( text ); } url = coda . withQueryParams ( url , { size : size , color : color , width : width , height : height , filter : filter , json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Column format that displays the cell's value within a random cat image, // using the CatImage() formula defined above. pack . addColumnFormat ({ name : \"Cat Image\" , instructions : \"Displays the text over the image of a random cat.\" , formulaName : \"CatImage\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly }); // Schema for a Cat image. const CatSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { image : { type : coda . ValueType . String , codaType : coda.ValueHintType.ImageReference , }, tags : { type : coda . ValueType . Array , items : { type : coda . ValueType . String }, }, created : { type : coda . ValueType . String , codaType : coda.ValueHintType.DateTime , }, id : { type : coda . ValueType . String }, }, primary : \"image\" , id : \"id\" , featured : [ \"tags\" ], identity : { name : \"Cat\" , }, }); // Sync table that retrieves all cat images, optionally filtered by tags. pack . addSyncTable ({ name : \"Cats\" , identityName : \"Cat\" , schema : CatSchema , connectionRequirement : coda.ConnectionRequirement.None , formula : { name : \"SyncCats\" , description : \"Syncs the cats.\" , parameters : [ TagParameter , ], execute : async function ([ tag ], context ) { let url = coda . withQueryParams ( \"https://cataas.com/api/cats\" , { tags : tag }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let cats = response . body ; let result : any = []; for ( let cat of cats ) { result . push ({ image : \"https://cataas.com/cat/\" + cat . id , tags : cat.tags , created : cat.created_at , id : cat.id , }); } return { result : result , }; }, }, });","title":"Cats"},{"location":"samples/full/cats/#cats-sample","text":"This Pack provides allows you to fetch random cat photos using the Cat-as-a-service API . You can set various parameters for the cat image, such as the width and height, as well as add a text overlay. The Pack provides: A formula for fetching a cat photo. A column format that displays the text on top of a cat photo. A sync table that retrieves all available cat photos. pack.ts import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); pack . addNetworkDomain ( \"cataas.com\" ); // Tag parameter, shared across multiple formulas. const TagParameter = coda . makeParameter ({ type : coda . ParameterType . String , name : \"tag\" , description : \"Only cats with this tag will be selected.\" , optional : true , // Pull the list of tags to use for autocomplete from the API. autocomplete : async function ( context , search ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/api/tags\" , }); let tags = response . body ; // Convert the tags into a list of autocomplete options. return coda . simpleAutocomplete ( search , tags ); }, }); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"size\" , description : \"The size of the text, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"color\" , description : \"The color of the text. Any valid CSS color can be used.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"width\" , description : \"The width of the desired image, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"height\" , description : \"The height of the desired image, in pixels.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"filter\" , description : \"A filter to apply to the image.\" , autocomplete : [ \"blur\" , \"mono\" , \"sepia\" , \"negative\" , \"paint\" , \"pixel\" ], optional : true , }), TagParameter , ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text , size , color , width , height , filter , tag ], context ) { let url = \"https://cataas.com/cat\" ; if ( tag ) { url += \"/\" + tag ; } if ( text ) { url += \"/says/\" + encodeURIComponent ( text ); } url = coda . withQueryParams ( url , { size : size , color : color , width : width , height : height , filter : filter , json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Column format that displays the cell's value within a random cat image, // using the CatImage() formula defined above. pack . addColumnFormat ({ name : \"Cat Image\" , instructions : \"Displays the text over the image of a random cat.\" , formulaName : \"CatImage\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly }); // Schema for a Cat image. const CatSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { image : { type : coda . ValueType . String , codaType : coda.ValueHintType.ImageReference , }, tags : { type : coda . ValueType . Array , items : { type : coda . ValueType . String }, }, created : { type : coda . ValueType . String , codaType : coda.ValueHintType.DateTime , }, id : { type : coda . ValueType . String }, }, primary : \"image\" , id : \"id\" , featured : [ \"tags\" ], identity : { name : \"Cat\" , }, }); // Sync table that retrieves all cat images, optionally filtered by tags. pack . addSyncTable ({ name : \"Cats\" , identityName : \"Cat\" , schema : CatSchema , connectionRequirement : coda.ConnectionRequirement.None , formula : { name : \"SyncCats\" , description : \"Syncs the cats.\" , parameters : [ TagParameter , ], execute : async function ([ tag ], context ) { let url = coda . withQueryParams ( \"https://cataas.com/api/cats\" , { tags : tag }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let cats = response . body ; let result : any = []; for ( let cat of cats ) { result . push ({ image : \"https://cataas.com/cat/\" + cat . id , tags : cat.tags , created : cat.created_at , id : cat.id , }); } return { result : result , }; }, }, });","title":"Cats sample"},{"location":"samples/full/daylight/","text":"Daylight sample \u00b6 This Pack provides a Daylight formula that determines the daylight, sunrise, and sunset at a given location using the Sunrise Sunset API . It accepts a latitude, longitude, an optional date and returns a rich object (schema) as a result. It uses the Fetcher to pull data from an external API. Daylight /** * This Pack provides a \"Daylight\" formula that determines the daylight, * sunrise, and sunset at a given location using the Sunrise Sunset API. * The results are returns as a rich object. * @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API} */ // This import statement provides access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates the new Pack. export const pack = coda . newPack (); // The domain that the Pack will match fetcher requests to. pack . addNetworkDomain ( \"sunrise-sunset.org\" ); // Define a schema that will be used to bundle up the multiple pieces of data // our formula will return. In the Coda doc this will be displayed as a chip. const SunSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { // The values we return are simple strings, but we use the codaType field to // to tell Coda to interpret them as durations and time values. daylight : { type : coda . ValueType . String , codaType : coda.ValueHintType.Duration , }, sunriseUTC : { type : coda . ValueType . String , codaType : coda.ValueHintType.Time , }, sunsetUTC : { type : coda . ValueType . String , codaType : coda.ValueHintType.Time , }, }, // Which of the properties defined above will be shown inside the chip. primary : \"daylight\" , }); // Add a \"Daylight\" formula to the Pack. pack . addFormula ({ name : \"Daylight\" , description : \"Returns the sunrise and sunset for a given location.\" , // This formula takes two required numeric inputs (the latitude and longitude) // and one optional date. parameters : [ coda . makeParameter ({ type : coda . ParameterType . Number , name : \"lat\" , description : \"The latitude to use.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"lng\" , description : \"The longitude to use.\" , }), coda . makeParameter ({ type : coda . ParameterType . Date , name : \"date\" , description : \"The date to use. Defaults to today.\" , // This date parameter is an optional input. optional : true , }), ], // In this formula, we're returning an object with multiple properties. resultType : coda.ValueType.Object , // This object will be defined according to the schema written above. schema : SunSchema , // Everything inside this execute statement will happen anytime the Coda // formula is called in a doc. An array of all user inputs is passed as the // first parameter. The context object is always the second parameter and is // used for fetching data. execute : async function ([ lat , lng , date ], context ) { // Default to today if no date is provided. let lookupDate = date || new Date (); // Format date to yyyy-mm-dd format as required by this API. let formattedDate = lookupDate . toISOString (). split ( \"T\" )[ 0 ]; // Create the URL to fetch, using the helper function coda.withQueryParams // to add on query parameters (ex: \"?lat=40.123...\"). let url = coda . withQueryParams ( \"https://api.sunrise-sunset.org/json\" , { lat : lat , lng : lng , date : formattedDate }); // Fetch the URL and get the response. let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); // The JSON returned by the API is parsed automatically and available in // `response.body`. Here we pull out the content in the \"results\" key. let results = response . body . results ; // Re-format the day_length string to [h] hrs [m] mins [s] secs to work as a // duration. let hours = results . day_length . split ( \":\" )[ 0 ]; let mins = results . day_length . split ( \":\" )[ 1 ]; let secs = results . day_length . split ( \":\" )[ 2 ]; let daylight = ` ${ hours } hrs ${ mins } mins ${ secs } secs` ; // Return the final object. The keys here must match with the properties // defined above in the schema. return { daylight : daylight , sunriseUTC : response.body.results.sunrise , sunsetUTC : response.body.results.sunset , }; }, });","title":"Daylight"},{"location":"samples/full/daylight/#daylight-sample","text":"This Pack provides a Daylight formula that determines the daylight, sunrise, and sunset at a given location using the Sunrise Sunset API . It accepts a latitude, longitude, an optional date and returns a rich object (schema) as a result. It uses the Fetcher to pull data from an external API. Daylight /** * This Pack provides a \"Daylight\" formula that determines the daylight, * sunrise, and sunset at a given location using the Sunrise Sunset API. * The results are returns as a rich object. * @see {@link https://sunrise-sunset.org/api|Sunrise Sunset API} */ // This import statement provides access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates the new Pack. export const pack = coda . newPack (); // The domain that the Pack will match fetcher requests to. pack . addNetworkDomain ( \"sunrise-sunset.org\" ); // Define a schema that will be used to bundle up the multiple pieces of data // our formula will return. In the Coda doc this will be displayed as a chip. const SunSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { // The values we return are simple strings, but we use the codaType field to // to tell Coda to interpret them as durations and time values. daylight : { type : coda . ValueType . String , codaType : coda.ValueHintType.Duration , }, sunriseUTC : { type : coda . ValueType . String , codaType : coda.ValueHintType.Time , }, sunsetUTC : { type : coda . ValueType . String , codaType : coda.ValueHintType.Time , }, }, // Which of the properties defined above will be shown inside the chip. primary : \"daylight\" , }); // Add a \"Daylight\" formula to the Pack. pack . addFormula ({ name : \"Daylight\" , description : \"Returns the sunrise and sunset for a given location.\" , // This formula takes two required numeric inputs (the latitude and longitude) // and one optional date. parameters : [ coda . makeParameter ({ type : coda . ParameterType . Number , name : \"lat\" , description : \"The latitude to use.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"lng\" , description : \"The longitude to use.\" , }), coda . makeParameter ({ type : coda . ParameterType . Date , name : \"date\" , description : \"The date to use. Defaults to today.\" , // This date parameter is an optional input. optional : true , }), ], // In this formula, we're returning an object with multiple properties. resultType : coda.ValueType.Object , // This object will be defined according to the schema written above. schema : SunSchema , // Everything inside this execute statement will happen anytime the Coda // formula is called in a doc. An array of all user inputs is passed as the // first parameter. The context object is always the second parameter and is // used for fetching data. execute : async function ([ lat , lng , date ], context ) { // Default to today if no date is provided. let lookupDate = date || new Date (); // Format date to yyyy-mm-dd format as required by this API. let formattedDate = lookupDate . toISOString (). split ( \"T\" )[ 0 ]; // Create the URL to fetch, using the helper function coda.withQueryParams // to add on query parameters (ex: \"?lat=40.123...\"). let url = coda . withQueryParams ( \"https://api.sunrise-sunset.org/json\" , { lat : lat , lng : lng , date : formattedDate }); // Fetch the URL and get the response. let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); // The JSON returned by the API is parsed automatically and available in // `response.body`. Here we pull out the content in the \"results\" key. let results = response . body . results ; // Re-format the day_length string to [h] hrs [m] mins [s] secs to work as a // duration. let hours = results . day_length . split ( \":\" )[ 0 ]; let mins = results . day_length . split ( \":\" )[ 1 ]; let secs = results . day_length . split ( \":\" )[ 2 ]; let daylight = ` ${ hours } hrs ${ mins } mins ${ secs } secs` ; // Return the final object. The keys here must match with the properties // defined above in the schema. return { daylight : daylight , sunriseUTC : response.body.results.sunrise , sunsetUTC : response.body.results.sunset , }; }, });","title":"Daylight sample"},{"location":"samples/full/hello-world/","text":"Hello World sample \u00b6 This is an example which creates a single formula called Hello, that takes in a string called name and returns \u201cHello, name !\u201c. Hello World /* Start making Packs! Try out the hello world sample below to create your first build. */ // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates your new Pack. export const pack = coda . newPack (); // Here, we add a new formula to this Pack. pack . addFormula ({ // This is the name that will be called in the formula builder. // Remember, your formula name cannot have spaces in it. name : \"Hello\" , description : \"A Hello World example.\" , // If your formula requires one or more inputs, you\u2019ll define them here. // Here, we're creating a string input called \u201cname\u201d. parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name you would like to say hello to.\" , }), ], // The resultType defines what will be returned in your Coda doc. Here, we're // returning a simple text string. resultType : coda.ValueType.String , // Everything inside this execute statement will happen anytime your Coda // formula is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ name ], context ) { return \"Hello \" + name + \"!\" ; }, });","title":"Hello World"},{"location":"samples/full/hello-world/#hello-world-sample","text":"This is an example which creates a single formula called Hello, that takes in a string called name and returns \u201cHello, name !\u201c. Hello World /* Start making Packs! Try out the hello world sample below to create your first build. */ // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This line creates your new Pack. export const pack = coda . newPack (); // Here, we add a new formula to this Pack. pack . addFormula ({ // This is the name that will be called in the formula builder. // Remember, your formula name cannot have spaces in it. name : \"Hello\" , description : \"A Hello World example.\" , // If your formula requires one or more inputs, you\u2019ll define them here. // Here, we're creating a string input called \u201cname\u201d. parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name you would like to say hello to.\" , }), ], // The resultType defines what will be returned in your Coda doc. Here, we're // returning a simple text string. resultType : coda.ValueType.String , // Everything inside this execute statement will happen anytime your Coda // formula is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ name ], context ) { return \"Hello \" + name + \"!\" ; }, });","title":"Hello World sample"},{"location":"samples/full/number-array/","text":"Number Array sample \u00b6 This is an example which creates two formulas that each take in an array of numbers and return the greatest common denominator and least common multiple. Number Array // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This import statement gives you access to all parts of the Coda Packs SDK. export const pack = coda . newPack (); // We'll use an array of numbers in *both* formulas. const numberArray = coda . makeParameter ({ type : coda . ParameterType . NumberArray , name : \"Numbers\" , description : \"the numbers you want to calculate\" , }); // We'll also use this helper function that finds the gcd of two numbers in // both formulas. function gcd ( a , b ) { if ( a === 0 ) { return b ; } return gcd ( b % a , a ); } // This line adds a new formula. pack . addFormula ({ // This is the name that will be called in the formula builder. Remember, your // formula name cannot have spaces in it. name : \"GCD\" , description : \"Returns the greatest common denominator for an array\" , // The needed array of numbers has already been defined above. parameters : [ numberArray ], // In this formula, we're returning a number in the Coda doc. resultType : coda.ValueType.Number , // Everything inside this execute statement will happen anytime your Coda // function is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ numberArray ]) { let gcdResult = numberArray [ 0 ]; for ( let i = 1 ; i < numberArray . length ; i ++ ) { gcdResult = gcd ( numberArray [ i ], gcdResult ); if ( gcdResult === 1 ) { return 1 ; } } return gcdResult ; }, }); // Now, we'll define and add the second formula to the pack. pack . addFormula ({ name : \"LCM\" , description : \"Returns the least common multiple for an array\" , parameters : [ numberArray ], resultType : coda.ValueType.Number , execute : async function ([ numberArray ]) { let lcmResult = numberArray [ 0 ]; for ( let i = 1 ; i < numberArray . length ; i ++ ) { lcmResult = ( numberArray [ i ] * lcmResult ) / gcd ( numberArray [ i ], lcmResult ); } return lcmResult ; }, });","title":"Number Array"},{"location":"samples/full/number-array/#number-array-sample","text":"This is an example which creates two formulas that each take in an array of numbers and return the greatest common denominator and least common multiple. Number Array // This import statement gives you access to all parts of the Coda Packs SDK. import * as coda from \"@codahq/packs-sdk\" ; // This import statement gives you access to all parts of the Coda Packs SDK. export const pack = coda . newPack (); // We'll use an array of numbers in *both* formulas. const numberArray = coda . makeParameter ({ type : coda . ParameterType . NumberArray , name : \"Numbers\" , description : \"the numbers you want to calculate\" , }); // We'll also use this helper function that finds the gcd of two numbers in // both formulas. function gcd ( a , b ) { if ( a === 0 ) { return b ; } return gcd ( b % a , a ); } // This line adds a new formula. pack . addFormula ({ // This is the name that will be called in the formula builder. Remember, your // formula name cannot have spaces in it. name : \"GCD\" , description : \"Returns the greatest common denominator for an array\" , // The needed array of numbers has already been defined above. parameters : [ numberArray ], // In this formula, we're returning a number in the Coda doc. resultType : coda.ValueType.Number , // Everything inside this execute statement will happen anytime your Coda // function is called in a doc. An array of all user inputs is always the 1st // parameter. execute : async function ([ numberArray ]) { let gcdResult = numberArray [ 0 ]; for ( let i = 1 ; i < numberArray . length ; i ++ ) { gcdResult = gcd ( numberArray [ i ], gcdResult ); if ( gcdResult === 1 ) { return 1 ; } } return gcdResult ; }, }); // Now, we'll define and add the second formula to the pack. pack . addFormula ({ name : \"LCM\" , description : \"Returns the least common multiple for an array\" , parameters : [ numberArray ], resultType : coda.ValueType.Number , execute : async function ([ numberArray ]) { let lcmResult = numberArray [ 0 ]; for ( let i = 1 ; i < numberArray . length ; i ++ ) { lcmResult = ( numberArray [ i ] * lcmResult ) / gcd ( numberArray [ i ], lcmResult ); } return lcmResult ; }, });","title":"Number Array sample"},{"location":"samples/full/todoist/","text":"Todoist sample \u00b6 This Pack provides an integration with the task tracking app Todoist . It uses a variety of building blocks to allow users to work with their projects and tasks, including: Formulas that provide rich data about an item given its URL. Column formats that automatically apply those formulas to matching URLs. Action formulas that create and update items, for use in button and automations. Sync tables for pulling in all of the user's items. The Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free. pack.ts import * as coda from \"@codahq/packs-sdk\" ; // Constants. const ProjectUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showProject\\\\?id=([0-9]+)\" ), ]; const TaskUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showTask\\\\?id=([0-9]+)\" ), ]; // Pack setup. export const pack = coda . newPack (); pack . addNetworkDomain ( \"todoist.com\" ); pack . setUserAuthentication ({ type : coda . AuthenticationType . OAuth2 , // OAuth2 URLs and scopes are found in the the Todoist OAuth guide: // https://developer.todoist.com/guides/#oauth authorizationUrl : \"https://todoist.com/oauth/authorize\" , tokenUrl : \"https://todoist.com/oauth/access_token\" , scopes : [ \"data:read_write\" ], // Determines the display name of the connected account. getConnectionName : async function ( context ) { let url = coda . withQueryParams ( \"https://api.todoist.com/sync/v8/sync\" , { resource_types : JSON.stringify ([ \"user\" ]), }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); return response . body . user ? . full_name ; }, }); // Schemas // A reference to a synced Project. Usually you can use // `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary // schema, but that doesn't work in this case since a Project itself can contain // a reference to a parent project. const ProjectReferenceSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { type : coda . ValueType . String , required : true }, projectId : { type : coda . ValueType . Number , required : true }, }, primary : \"name\" , id : \"projectId\" , identity : { name : \"Project\" , }, }); const ProjectSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { description : \"The name of the project.\" , type : coda . ValueType . String , required : true , }, url : { description : \"A link to the project in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url , }, shared : { description : \"Is the project is shared.\" , type : coda . ValueType . Boolean , }, favorite : { description : \"Is the project a favorite.\" , type : coda . ValueType . Boolean , }, projectId : { description : \"The ID of the project.\" , type : coda . ValueType . Number , required : true , }, parentProjectId : { description : \"For sub-projects, the ID of the parent project.\" , type : coda . ValueType . Number , }, // Add a reference to the sync'ed row of the parent project. // References only work in sync tables. parentProject : ProjectReferenceSchema , }, primary : \"name\" , id : \"projectId\" , featured : [ \"url\" ], identity : { name : \"Project\" , }, }); // A reference to a synced Task. Usually you can use // `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary // schema, but that doesn't work in this case since a Project itself can contain // a reference to a parent project. const TaskReferenceSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { type : coda . ValueType . String , required : true }, taskId : { type : coda . ValueType . Number , required : true }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, order : { description : \"The position of the task in the project or parent task.\" , type : coda . ValueType . Number , }, priority : { description : \"The priority of the task.\" , type : coda . ValueType . String , }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, projectId : { description : \"The ID of the project that the task belongs to.\" , type : coda . ValueType . Number , }, parentTaskId : { description : \"For sub-tasks, the ID of the parent task it belongs to.\" , type : coda . ValueType . Number , }, // A reference to the sync'ed row of the project. // References only work in sync tables. project : ProjectReferenceSchema , // Add a reference to the sync'ed row of the parent task. // References only work in sync tables. parentTask : TaskReferenceSchema , }, primary : \"name\" , id : \"taskId\" , featured : [ \"project\" , \"url\" ], identity : { name : \"Task\" , }, }); /** * Convert a Project API response to a Project schema. */ function toProject ( project : any , withReferences = false ) { let result : any = { name : project.name , projectId : project.id , url : project.url , shared : project.shared , favorite : project.favorite , parentProjectId : project.parent_id , }; if ( withReferences && project . parent_id ) { result . parentProject = { projectId : project.parent_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; } return result ; } /** * Convert a Task API response to a Task schema. */ function toTask ( task : any , withReferences = false ) { let result : any = { name : task.content , description : task.description , url : task.url , order : task.order , priority : task.priority , taskId : task.id , projectId : task.project_id , parentTaskId : task.parent_id , }; if ( withReferences ) { // Add a reference to the corresponding row in the Projects sync table. result . project = { projectId : task.project_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; if ( task . parent_id ) { // Add a reference to the corresponding row in the Tasks sync table. result . parentTask = { taskId : task.parent_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; } } return result ; } // Formulas (read-only). pack . addFormula ({ name : \"GetProject\" , description : \"Gets a Todoist project by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the project\" , }), ], resultType : coda.ValueType.Object , schema : ProjectSchema , execute : async function ([ url ], context ) { let projectId = extractProjectId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/projects/\" + projectId , method : \"GET\" , }); return toProject ( response . body ); }, }); pack . addFormula ({ name : \"GetTask\" , description : \"Gets a Todoist task by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ url ], context ) { let taskId = extractTaskId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); return toTask ( response . body ); }, }); // Column Formats. pack . addColumnFormat ({ name : \"Project\" , formulaName : \"GetProject\" , formulaNamespace : \"Deprecated\" , matchers : ProjectUrlPatterns , }); pack . addColumnFormat ({ name : \"Task\" , formulaName : \"GetTask\" , formulaNamespace : \"Deprecated\" , matchers : TaskUrlPatterns , }); // Action formulas (buttons/automations). pack . addFormula ({ name : \"AddProject\" , description : \"Add a new Todoist project\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name of the new project\" , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ name ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/projects\" , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ name : name , }), }); return response . body . url ; }, }); pack . addFormula ({ name : \"AddTask\" , description : \"Add a new task.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name of the task.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"projectId\" , description : \"The ID of the project to add it to. If blank, \" + \"it will be added to the user's Inbox.\" , optional : true , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ name , projectId ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks\" , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ content : name , project_id : projectId , }), }); return response . body . url ; }, }); pack . addFormula ({ name : \"UpdateTask\" , description : \"Updates the name of a task.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task to update.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The new name of the task.\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , isAction : true , execute : async function ([ taskId , name ], context ) { let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId ; await context . fetcher . fetch ({ url : url , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ content : name , }), }); // Get the updated Task and return it, which will update the row in the sync // table. let response = await context . fetcher . fetch ({ url : url , method : \"GET\" , cacheTtlSecs : 0 , // Ensure we are getting the latest data. }); return toTask ( response . body ); }, }); pack . addFormula ({ name : \"MarkAsComplete\" , description : \"Mark a task as completed.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task to be marked as complete.\" , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ taskId ], context ) { let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId + \"/close\" ; await context . fetcher . fetch ({ method : \"POST\" , url : url , headers : { \"Content-Type\" : \"application/json\" , }, }); return \"OK\" ; }, }); // Sync tables. pack . addSyncTable ({ name : \"Projects\" , schema : ProjectSchema , identityName : \"Project\" , formula : { name : \"SyncProjects\" , description : \"Sync projects\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/projects\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let project of response . body ) { results . push ( toProject ( project , true )); } return { result : results , }; }, }, }); pack . addSyncTable ({ name : \"Tasks\" , schema : TaskSchema , identityName : \"Task\" , formula : { name : \"SyncTasks\" , description : \"Sync tasks\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/tasks\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let task of response . body ) { results . push ( toTask ( task , true )); } return { result : results , }; }, }, }); // Helper functions. function extractProjectId ( projectUrl : string ) { for ( let pattern of ProjectUrlPatterns ) { let matches = projectUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid project URL: \" + projectUrl ); } function extractTaskId ( taskUrl : string ) { for ( let pattern of TaskUrlPatterns ) { let matches = taskUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid task URL: \" + taskUrl ); }","title":"Todoist"},{"location":"samples/full/todoist/#todoist-sample","text":"This Pack provides an integration with the task tracking app Todoist . It uses a variety of building blocks to allow users to work with their projects and tasks, including: Formulas that provide rich data about an item given its URL. Column formats that automatically apply those formulas to matching URLs. Action formulas that create and update items, for use in button and automations. Sync tables for pulling in all of the user's items. The Pack uses OAuth2 to connect to a user's Todoist account, which you can create for free. pack.ts import * as coda from \"@codahq/packs-sdk\" ; // Constants. const ProjectUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showProject\\\\?id=([0-9]+)\" ), ]; const TaskUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showTask\\\\?id=([0-9]+)\" ), ]; // Pack setup. export const pack = coda . newPack (); pack . addNetworkDomain ( \"todoist.com\" ); pack . setUserAuthentication ({ type : coda . AuthenticationType . OAuth2 , // OAuth2 URLs and scopes are found in the the Todoist OAuth guide: // https://developer.todoist.com/guides/#oauth authorizationUrl : \"https://todoist.com/oauth/authorize\" , tokenUrl : \"https://todoist.com/oauth/access_token\" , scopes : [ \"data:read_write\" ], // Determines the display name of the connected account. getConnectionName : async function ( context ) { let url = coda . withQueryParams ( \"https://api.todoist.com/sync/v8/sync\" , { resource_types : JSON.stringify ([ \"user\" ]), }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); return response . body . user ? . full_name ; }, }); // Schemas // A reference to a synced Project. Usually you can use // `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary // schema, but that doesn't work in this case since a Project itself can contain // a reference to a parent project. const ProjectReferenceSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { type : coda . ValueType . String , required : true }, projectId : { type : coda . ValueType . Number , required : true }, }, primary : \"name\" , id : \"projectId\" , identity : { name : \"Project\" , }, }); const ProjectSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { description : \"The name of the project.\" , type : coda . ValueType . String , required : true , }, url : { description : \"A link to the project in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url , }, shared : { description : \"Is the project is shared.\" , type : coda . ValueType . Boolean , }, favorite : { description : \"Is the project a favorite.\" , type : coda . ValueType . Boolean , }, projectId : { description : \"The ID of the project.\" , type : coda . ValueType . Number , required : true , }, parentProjectId : { description : \"For sub-projects, the ID of the parent project.\" , type : coda . ValueType . Number , }, // Add a reference to the sync'ed row of the parent project. // References only work in sync tables. parentProject : ProjectReferenceSchema , }, primary : \"name\" , id : \"projectId\" , featured : [ \"url\" ], identity : { name : \"Project\" , }, }); // A reference to a synced Task. Usually you can use // `coda.makeReferenceSchemaFromObjectSchema` to generate these from the primary // schema, but that doesn't work in this case since a Project itself can contain // a reference to a parent project. const TaskReferenceSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , codaType : coda.ValueHintType.Reference , properties : { name : { type : coda . ValueType . String , required : true }, taskId : { type : coda . ValueType . Number , required : true }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, order : { description : \"The position of the task in the project or parent task.\" , type : coda . ValueType . Number , }, priority : { description : \"The priority of the task.\" , type : coda . ValueType . String , }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, projectId : { description : \"The ID of the project that the task belongs to.\" , type : coda . ValueType . Number , }, parentTaskId : { description : \"For sub-tasks, the ID of the parent task it belongs to.\" , type : coda . ValueType . Number , }, // A reference to the sync'ed row of the project. // References only work in sync tables. project : ProjectReferenceSchema , // Add a reference to the sync'ed row of the parent task. // References only work in sync tables. parentTask : TaskReferenceSchema , }, primary : \"name\" , id : \"taskId\" , featured : [ \"project\" , \"url\" ], identity : { name : \"Task\" , }, }); /** * Convert a Project API response to a Project schema. */ function toProject ( project : any , withReferences = false ) { let result : any = { name : project.name , projectId : project.id , url : project.url , shared : project.shared , favorite : project.favorite , parentProjectId : project.parent_id , }; if ( withReferences && project . parent_id ) { result . parentProject = { projectId : project.parent_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; } return result ; } /** * Convert a Task API response to a Task schema. */ function toTask ( task : any , withReferences = false ) { let result : any = { name : task.content , description : task.description , url : task.url , order : task.order , priority : task.priority , taskId : task.id , projectId : task.project_id , parentTaskId : task.parent_id , }; if ( withReferences ) { // Add a reference to the corresponding row in the Projects sync table. result . project = { projectId : task.project_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; if ( task . parent_id ) { // Add a reference to the corresponding row in the Tasks sync table. result . parentTask = { taskId : task.parent_id , name : \"Not found\" , // If sync'ed, the real name will be shown instead. }; } } return result ; } // Formulas (read-only). pack . addFormula ({ name : \"GetProject\" , description : \"Gets a Todoist project by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the project\" , }), ], resultType : coda.ValueType.Object , schema : ProjectSchema , execute : async function ([ url ], context ) { let projectId = extractProjectId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/projects/\" + projectId , method : \"GET\" , }); return toProject ( response . body ); }, }); pack . addFormula ({ name : \"GetTask\" , description : \"Gets a Todoist task by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ url ], context ) { let taskId = extractTaskId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); return toTask ( response . body ); }, }); // Column Formats. pack . addColumnFormat ({ name : \"Project\" , formulaName : \"GetProject\" , formulaNamespace : \"Deprecated\" , matchers : ProjectUrlPatterns , }); pack . addColumnFormat ({ name : \"Task\" , formulaName : \"GetTask\" , formulaNamespace : \"Deprecated\" , matchers : TaskUrlPatterns , }); // Action formulas (buttons/automations). pack . addFormula ({ name : \"AddProject\" , description : \"Add a new Todoist project\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name of the new project\" , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ name ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/projects\" , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ name : name , }), }); return response . body . url ; }, }); pack . addFormula ({ name : \"AddTask\" , description : \"Add a new task.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name of the task.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"projectId\" , description : \"The ID of the project to add it to. If blank, \" + \"it will be added to the user's Inbox.\" , optional : true , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ name , projectId ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks\" , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ content : name , project_id : projectId , }), }); return response . body . url ; }, }); pack . addFormula ({ name : \"UpdateTask\" , description : \"Updates the name of a task.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task to update.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The new name of the task.\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , isAction : true , execute : async function ([ taskId , name ], context ) { let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId ; await context . fetcher . fetch ({ url : url , method : \"POST\" , headers : { \"Content-Type\" : \"application/json\" , }, body : JSON.stringify ({ content : name , }), }); // Get the updated Task and return it, which will update the row in the sync // table. let response = await context . fetcher . fetch ({ url : url , method : \"GET\" , cacheTtlSecs : 0 , // Ensure we are getting the latest data. }); return toTask ( response . body ); }, }); pack . addFormula ({ name : \"MarkAsComplete\" , description : \"Mark a task as completed.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task to be marked as complete.\" , }), ], resultType : coda.ValueType.String , isAction : true , execute : async function ([ taskId ], context ) { let url = \"https://api.todoist.com/rest/v1/tasks/\" + taskId + \"/close\" ; await context . fetcher . fetch ({ method : \"POST\" , url : url , headers : { \"Content-Type\" : \"application/json\" , }, }); return \"OK\" ; }, }); // Sync tables. pack . addSyncTable ({ name : \"Projects\" , schema : ProjectSchema , identityName : \"Project\" , formula : { name : \"SyncProjects\" , description : \"Sync projects\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/projects\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let project of response . body ) { results . push ( toProject ( project , true )); } return { result : results , }; }, }, }); pack . addSyncTable ({ name : \"Tasks\" , schema : TaskSchema , identityName : \"Task\" , formula : { name : \"SyncTasks\" , description : \"Sync tasks\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/tasks\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let task of response . body ) { results . push ( toTask ( task , true )); } return { result : results , }; }, }, }); // Helper functions. function extractProjectId ( projectUrl : string ) { for ( let pattern of ProjectUrlPatterns ) { let matches = projectUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid project URL: \" + projectUrl ); } function extractTaskId ( taskUrl : string ) { for ( let pattern of TaskUrlPatterns ) { let matches = taskUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid task URL: \" + taskUrl ); }","title":"Todoist sample"},{"location":"samples/topic/authentication/","text":"Authentication samples \u00b6 The SDK broadly divides authentication into two categories: authentication that is tied to the user of the pack vs authentication that is managed by the system, aka the pack author. In the pack definition the former is known as defaultAuthentication and the latter systemConnectionAuthentication . You will typically specify one or the other in your pack definition, or neither if your pack does not make http requests or those requests do not require authentication. Default authentication is the most common. Specify this if each user of your pack should log in with OAuth, or have their own API key, or whatever user-specific token is necessary for the pack to be able to retrieve data that is specific to that user. Use system authentication if you as the pack author will provide the necessary tokens to successfully make http requests within your pack. An example would be if your pack returns weather forecasts and the API involved requires an API key, but individual users need not provide their own API key. You as the pack author will register an API key and provide it to Coda, and Coda will apply it to all pack requests regardless of the user. Learn More Template \u00b6 pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , }); OAuth2 (Todoist) \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Adds OAuth2 authentication for the Todoist API. pack . setUserAuthentication ({ type : coda . AuthenticationType . OAuth2 , // OAuth2 URLs and scopes are found in the the Todoist OAuth guide: // https://developer.todoist.com/guides/#oauth authorizationUrl : \"https://todoist.com/oauth/authorize\" , tokenUrl : \"https://todoist.com/oauth/access_token\" , scopes : [ \"data:read_write\" ], // Determines the display name of the connected account. getConnectionName : async function ( context ) { let url = coda . withQueryParams ( \"https://api.todoist.com/sync/v8/sync\" , { resource_types : JSON.stringify ([ \"user\" ]), }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); return response . body . user ? . full_name ; }, });","title":"Authentication"},{"location":"samples/topic/authentication/#authentication-samples","text":"The SDK broadly divides authentication into two categories: authentication that is tied to the user of the pack vs authentication that is managed by the system, aka the pack author. In the pack definition the former is known as defaultAuthentication and the latter systemConnectionAuthentication . You will typically specify one or the other in your pack definition, or neither if your pack does not make http requests or those requests do not require authentication. Default authentication is the most common. Specify this if each user of your pack should log in with OAuth, or have their own API key, or whatever user-specific token is necessary for the pack to be able to retrieve data that is specific to that user. Use system authentication if you as the pack author will provide the necessary tokens to successfully make http requests within your pack. An example would be if your pack returns weather forecasts and the API involved requires an API key, but individual users need not provide their own API key. You as the pack author will register an API key and provide it to Coda, and Coda will apply it to all pack requests regardless of the user. Learn More","title":"Authentication samples"},{"location":"samples/topic/authentication/#template","text":"pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , });","title":"Template"},{"location":"samples/topic/authentication/#oauth2-todoist","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Adds OAuth2 authentication for the Todoist API. pack . setUserAuthentication ({ type : coda . AuthenticationType . OAuth2 , // OAuth2 URLs and scopes are found in the the Todoist OAuth guide: // https://developer.todoist.com/guides/#oauth authorizationUrl : \"https://todoist.com/oauth/authorize\" , tokenUrl : \"https://todoist.com/oauth/access_token\" , scopes : [ \"data:read_write\" ], // Determines the display name of the connected account. getConnectionName : async function ( context ) { let url = coda . withQueryParams ( \"https://api.todoist.com/sync/v8/sync\" , { resource_types : JSON.stringify ([ \"user\" ]), }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); return response . body . user ? . full_name ; }, });","title":"OAuth2 (Todoist)"},{"location":"samples/topic/autocomplete/","text":"Autocomplete samples \u00b6 Autocomplete can be configured for a parameter to provide a defined set of options for the user to select from. You can can pass either a static array or use a function to dynamically generate the options. Learn More Simple autocomplete \u00b6 A formula with a parameter that provides autocomplete for acceptable values. This sample returns the noise that an animal makes, for a limited set of animals. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Returns the noise an animal makes. Ex) \"cow\" => \"moo\". pack . addFormula ({ name : \"AnimalNoise\" , description : \"Gets the noise than an animal makes.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ \"cow\" , \"pig\" , \"sheep\" ], }), ], resultType : coda.ValueType.String , execute : async function ([ animal ], context ) { switch ( animal ) { case \"cow\" : return \"moo\" ; case \"pig\" : return \"oink\" ; case \"sheep\" : return \"baa\" ; default : throw new coda . UserVisibleError ( \"Unknown animal: \" + animal ); } }, }); Dynamic autocomplete \u00b6 A formula with a parameter that provides autocomplete for acceptable values, where the options are pulled dynamically from an API. This sample returns the price for a board game listed on the site Board Game Atlas. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Gets the price of a board game by ID, with autocomplete on the ID. pack . addFormula ({ name : \"GetPrice\" , description : \"Gets the price of a board game.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"gameId\" , description : \"The ID of the game on boardgameatlas.com\" , autocomplete : async function ( context , search , parameters ) { let url = coda . withQueryParams ( \"https://api.boardgameatlas.com/api/search\" , { fuzzy_match : true , name : search }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); let results = response . body . games ; // Generate an array of autocomplete objects, using the game's name as // the label and its ID for the value. return coda . autocompleteSearchObjects ( search , results , \"name\" , \"id\" ); }, }), ], resultType : coda.ValueType.Number , codaType : coda.ValueHintType.Currency , execute : async function ([ gameId ], context ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://api.boardgameatlas.com/api/search?ids=\" + gameId , }); return response . body . games [ 0 ]. price ; }, }); pack . addNetworkDomain ( \"boardgameatlas.com\" ); // Authenticate using a client ID. // See: https://www.boardgameatlas.com/api/docs/apps pack . setSystemAuthentication ({ type : coda . AuthenticationType . QueryParamToken , paramName : \"client_id\" , }); Autocomplete on previous parameter \u00b6 A formula with a parameter that provides autocomplete for acceptable values, where the options depend on the value of a previous parameter. This sample generates a greeting in either English or Spanish. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Greet someone in their language, with the greeting autocomplete adjusting // based on the language selected. pack . addFormula ({ name : \"Greeting\" , description : \"Greet someone.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"language\" , description : \"The language to greet them in.\" , autocomplete : [ { display : \"English\" , value : \"en\" }, { display : \"Spanish\" , value : \"es\" }, ], }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"greeting\" , description : \"The greeting to use.\" , autocomplete : async function ( context , search , { language }) { let options ; if ( language === \"es\" ) { options = [ \"Hola\" , \"Buenos d\u00edas\" ]; } else { options = [ \"Hello\" , \"Howdy\" ]; } return coda . simpleAutocomplete ( search , options ); }, }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name to greet.\" , }), ], resultType : coda.ValueType.String , connectionRequirement : coda.ConnectionRequirement.None , execute : async function ([ language , greeting , name ], context ) { let result = greeting + \" \" + name + \"!\" ; if ( language === \"es\" ) { // Add upside-down exclamation point in the front. result = \"\u00a1\" + result ; } return result ; }, });","title":"Autocomplete"},{"location":"samples/topic/autocomplete/#autocomplete-samples","text":"Autocomplete can be configured for a parameter to provide a defined set of options for the user to select from. You can can pass either a static array or use a function to dynamically generate the options. Learn More","title":"Autocomplete samples"},{"location":"samples/topic/autocomplete/#simple-autocomplete","text":"A formula with a parameter that provides autocomplete for acceptable values. This sample returns the noise that an animal makes, for a limited set of animals. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Returns the noise an animal makes. Ex) \"cow\" => \"moo\". pack . addFormula ({ name : \"AnimalNoise\" , description : \"Gets the noise than an animal makes.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"animal\" , description : \"The selected animal.\" , autocomplete : [ \"cow\" , \"pig\" , \"sheep\" ], }), ], resultType : coda.ValueType.String , execute : async function ([ animal ], context ) { switch ( animal ) { case \"cow\" : return \"moo\" ; case \"pig\" : return \"oink\" ; case \"sheep\" : return \"baa\" ; default : throw new coda . UserVisibleError ( \"Unknown animal: \" + animal ); } }, });","title":"Simple autocomplete"},{"location":"samples/topic/autocomplete/#dynamic-autocomplete","text":"A formula with a parameter that provides autocomplete for acceptable values, where the options are pulled dynamically from an API. This sample returns the price for a board game listed on the site Board Game Atlas. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Gets the price of a board game by ID, with autocomplete on the ID. pack . addFormula ({ name : \"GetPrice\" , description : \"Gets the price of a board game.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"gameId\" , description : \"The ID of the game on boardgameatlas.com\" , autocomplete : async function ( context , search , parameters ) { let url = coda . withQueryParams ( \"https://api.boardgameatlas.com/api/search\" , { fuzzy_match : true , name : search }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); let results = response . body . games ; // Generate an array of autocomplete objects, using the game's name as // the label and its ID for the value. return coda . autocompleteSearchObjects ( search , results , \"name\" , \"id\" ); }, }), ], resultType : coda.ValueType.Number , codaType : coda.ValueHintType.Currency , execute : async function ([ gameId ], context ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://api.boardgameatlas.com/api/search?ids=\" + gameId , }); return response . body . games [ 0 ]. price ; }, }); pack . addNetworkDomain ( \"boardgameatlas.com\" ); // Authenticate using a client ID. // See: https://www.boardgameatlas.com/api/docs/apps pack . setSystemAuthentication ({ type : coda . AuthenticationType . QueryParamToken , paramName : \"client_id\" , });","title":"Dynamic autocomplete"},{"location":"samples/topic/autocomplete/#autocomplete-on-previous-parameter","text":"A formula with a parameter that provides autocomplete for acceptable values, where the options depend on the value of a previous parameter. This sample generates a greeting in either English or Spanish. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Greet someone in their language, with the greeting autocomplete adjusting // based on the language selected. pack . addFormula ({ name : \"Greeting\" , description : \"Greet someone.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"language\" , description : \"The language to greet them in.\" , autocomplete : [ { display : \"English\" , value : \"en\" }, { display : \"Spanish\" , value : \"es\" }, ], }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"greeting\" , description : \"The greeting to use.\" , autocomplete : async function ( context , search , { language }) { let options ; if ( language === \"es\" ) { options = [ \"Hola\" , \"Buenos d\u00edas\" ]; } else { options = [ \"Hello\" , \"Howdy\" ]; } return coda . simpleAutocomplete ( search , options ); }, }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"name\" , description : \"The name to greet.\" , }), ], resultType : coda.ValueType.String , connectionRequirement : coda.ConnectionRequirement.None , execute : async function ([ language , greeting , name ], context ) { let result = greeting + \" \" + name + \"!\" ; if ( language === \"es\" ) { // Add upside-down exclamation point in the front. result = \"\u00a1\" + result ; } return result ; }, });","title":"Autocomplete on previous parameter"},{"location":"samples/topic/column-format/","text":"Column format samples \u00b6 A column format is a custom column type that you apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a formula using that value, typically looking up data related to that value from a third-party API. For example, the Weather pack has a column format Current Weather ; when applied to a column, if you type a city or address into a cell in that column, that location will be used an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell. Learn More Template \u00b6 pack . addColumnFormat ({ name : \"<User-visible name>\" , instructions : \"<Help text for the format>\" , formulaName : \"<Name of the formula to run>\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly }); Text (Reverse) \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Adds a column format to the Pack, which will display the contents of the // column in reverse order. pack . addColumnFormat ({ name : \"Reversed Text\" , // The formula \"Reverse()\" (defined below) will be run on the content of the // column to determine it's display value. formulaName : \"Reverse\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly. instructions : \"Whatever text you enter into this column will be reversed.\" , }); // Adds a formula to this Pack to reverse text. It is used by the column format // above, but can also be used on it's own anywhere in the doc. pack . addFormula ({ resultType : coda.ValueType.String , name : \"Reverse\" , description : \"Reverses text.\" , parameters : [ // Formulas used in column formats can have only one required parameter. coda . makeParameter ({ type : coda . ParameterType . String , name : \"input\" , description : \"The text to reverse.\" , }), // Optional parameters can't be set when run as a column format. coda . makeParameter ({ type : coda . ParameterType . Boolean , name : \"byWord\" , description : \"Reverse the text word-by-word.\" , defaultValue : false , optional : true , }), ], execute : async function ([ input , byWord = false ]) { let separator = \"\" ; if ( byWord ) { separator = \" \" ; } return input . split ( separator ). reverse (). join ( separator ); }, }); Image (Cats) \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Column format that displays the cell's value within a random cat image, // using the CatImage() formula defined above. pack . addColumnFormat ({ name : \"Cat Image\" , instructions : \"Displays the text over the image of a random cat.\" , formulaName : \"CatImage\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly }); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , }), ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text ], context ) { let url = \"https://cataas.com/cat/says/\" + encodeURIComponent ( text ); url = coda . withQueryParams ( url , { json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" ); Rich Data (Todoist) \u00b6 import * as coda from \"@codahq/packs-sdk\" ; // Regular expressions that match Todoist task URLs. Used by the column format // and also the formula that powers it. const TaskUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showTask\\\\?id=([0-9]+)\" ), ]; export const pack = coda . newPack (); // Add a column format that displays a task URL as rich metadata. pack . addColumnFormat ({ name : \"Task\" , // The formula \"GetTask\" below will get run on the cell value. formulaName : \"GetTask\" , formulaNamespace : \"Deprecated\" , // If the first values entered into a new column match these patterns then // this column format will be automatically applied. matchers : TaskUrlPatterns , }); // A schema defining the rich metadata to be returned. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); // Formula that looks up rich metadata about a task given it's URL. This is used // by the \"Task\" column format above, but is also a regular formula that can be // used elsewhere. pack . addFormula ({ name : \"GetTask\" , description : \"Gets a Todoist task by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ url ], context ) { let taskId = extractTaskId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); let task = response . body ; return { name : task.content , description : task.description , url : task.url , taskId : task.id , }; }, }); // Helper function to extract the Task ID from the URL. function extractTaskId ( taskUrl : string ) { for ( let pattern of TaskUrlPatterns ) { let matches = taskUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid task URL: \" + taskUrl ); } // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Column formats"},{"location":"samples/topic/column-format/#column-format-samples","text":"A column format is a custom column type that you apply to any column in any Coda table. A column format tells Coda to interpret the value in a cell by executing a formula using that value, typically looking up data related to that value from a third-party API. For example, the Weather pack has a column format Current Weather ; when applied to a column, if you type a city or address into a cell in that column, that location will be used an input to a formula that fetches the current weather at that location, and the resulting object with weather info will be shown in the cell. Learn More","title":"Column format samples"},{"location":"samples/topic/column-format/#template","text":"pack . addColumnFormat ({ name : \"<User-visible name>\" , instructions : \"<Help text for the format>\" , formulaName : \"<Name of the formula to run>\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly });","title":"Template"},{"location":"samples/topic/column-format/#text-reverse","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Adds a column format to the Pack, which will display the contents of the // column in reverse order. pack . addColumnFormat ({ name : \"Reversed Text\" , // The formula \"Reverse()\" (defined below) will be run on the content of the // column to determine it's display value. formulaName : \"Reverse\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly. instructions : \"Whatever text you enter into this column will be reversed.\" , }); // Adds a formula to this Pack to reverse text. It is used by the column format // above, but can also be used on it's own anywhere in the doc. pack . addFormula ({ resultType : coda.ValueType.String , name : \"Reverse\" , description : \"Reverses text.\" , parameters : [ // Formulas used in column formats can have only one required parameter. coda . makeParameter ({ type : coda . ParameterType . String , name : \"input\" , description : \"The text to reverse.\" , }), // Optional parameters can't be set when run as a column format. coda . makeParameter ({ type : coda . ParameterType . Boolean , name : \"byWord\" , description : \"Reverse the text word-by-word.\" , defaultValue : false , optional : true , }), ], execute : async function ([ input , byWord = false ]) { let separator = \"\" ; if ( byWord ) { separator = \" \" ; } return input . split ( separator ). reverse (). join ( separator ); }, });","title":"Text (Reverse)"},{"location":"samples/topic/column-format/#image-cats","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Column format that displays the cell's value within a random cat image, // using the CatImage() formula defined above. pack . addColumnFormat ({ name : \"Cat Image\" , instructions : \"Displays the text over the image of a random cat.\" , formulaName : \"CatImage\" , formulaNamespace : \"Deprecated\" , // Will be removed shortly }); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , }), ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text ], context ) { let url = \"https://cataas.com/cat/says/\" + encodeURIComponent ( text ); url = coda . withQueryParams ( url , { json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" );","title":"Image (Cats)"},{"location":"samples/topic/column-format/#rich-data-todoist","text":"import * as coda from \"@codahq/packs-sdk\" ; // Regular expressions that match Todoist task URLs. Used by the column format // and also the formula that powers it. const TaskUrlPatterns : RegExp [] = [ new RegExp ( \"^https://todoist.com/app/project/[0-9]+/task/([0-9]+)$\" ), new RegExp ( \"^https://todoist.com/showTask\\\\?id=([0-9]+)\" ), ]; export const pack = coda . newPack (); // Add a column format that displays a task URL as rich metadata. pack . addColumnFormat ({ name : \"Task\" , // The formula \"GetTask\" below will get run on the cell value. formulaName : \"GetTask\" , formulaNamespace : \"Deprecated\" , // If the first values entered into a new column match these patterns then // this column format will be automatically applied. matchers : TaskUrlPatterns , }); // A schema defining the rich metadata to be returned. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); // Formula that looks up rich metadata about a task given it's URL. This is used // by the \"Task\" column format above, but is also a regular formula that can be // used elsewhere. pack . addFormula ({ name : \"GetTask\" , description : \"Gets a Todoist task by URL\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"url\" , description : \"The URL of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ url ], context ) { let taskId = extractTaskId ( url ); let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); let task = response . body ; return { name : task.content , description : task.description , url : task.url , taskId : task.id , }; }, }); // Helper function to extract the Task ID from the URL. function extractTaskId ( taskUrl : string ) { for ( let pattern of TaskUrlPatterns ) { let matches = taskUrl . match ( pattern ); if ( matches && matches [ 1 ]) { return matches [ 1 ]; } } throw new coda . UserVisibleError ( \"Invalid task URL: \" + taskUrl ); } // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Rich Data (Todoist)"},{"location":"samples/topic/dynamic-sync-table/","text":"Dynamic sync table sample \u00b6 Most sync tables have schemas that can be statically defined. For example, if you're writing a sync of a user's Google Calendar events, the structure of an Event from the Google Calendar API is well-known and you can write a schema for what your table should contain. In certain cases, you may want to sync data whose structure is not known in advance and may depend on the user doing the sync. For example, Coda's Jira pack allows users to sync data from their Jira instance, but Jira lets users create arbitrary custom fields for their Issue objects. So the schema of the Issues sync table is not known in advance; it depends on the Jira account that the user is syncing from. Coda supports \"dynamic\" sync tables for cases like these. Instead of including a static schema in your sync table definition, you include a formula that returns a schema. This formula can use the fetcher to make authenticated http requests to your Pack's API so that you may retrieve any necessary info from that third-party service needed to construct an appropriate schema. To define a dynamic schema, use the makeDynamicSyncTable() wrapper function. You will provide a getSchema formula that returns a schema definition. You'll also provide some supporting formulas like getName , to return a name in the UI for the table, in case even the name of the entities being synced is dynamic. There are two subtle variants of dynamic sync tables. A sync table can be dynamic simply because the shape of the entities being synced vary based on who the current user is. For example, in the Jira example, Jira Issues are synced by hitting the same static Jira API url for Issues, but the schema of the issues returned will be different depending on the configuration of the Jira instance of the calling user. Alternatively, a sync table can be dynamic because the data source is specific to each instance of the table. If you were building a sync table to sync data from a Google Sheet, the data source would be the API url of a specific sheet. In this case, the sync table will be bound to a dynamicUrl that defines the data source. This url will be available to all of the formulas to implement the sync table in the sync context, as context.sync.dynamicUrl . To create a sync table that uses dynamic urls, you must implement the listDynamicUrls metadata formula in your dynamic sync table definition. Learn More Template \u00b6 pack . addDynamicSyncTable ({ name : \"<User-visible name for the sync table>\" , getName : async function ( context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; // TODO: Fetch metdata about the datasource and return the name. return \"<Datasource Name>\" ; }, getSchema : async function ( context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; // TODO: Fetch metdata about the datasource and get the list of fields. let properties = { // TODO: Create a property for each field. }; let id = \"<Determine the field containing a unique ID>\" ; let primary = \"<Determine the field containing the display value>\" ; let featured = [ // TODO: Determine which fields to show in the table by default. ]; return coda . makeSchema ({ type : coda . ValueType . Array , items : coda.makeObjectSchema ({ type : coda . ValueType . Object , identity : { name : \"<User-visible name for the column containing the schema>\" , dynamicUrl : datasourceUrl , }, properties : properties , id : id , primary : primary , featured : featured , }), }); }, getDisplayUrl : async function ( context ) { return context . sync ! . dynamicUrl ! ; }, formula : { name : \"<Name of the sync formula, not show to the user>\" , description : \"<Help text for the sync formula, not show to the user>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], execute : async function ([ param ], context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; let url = \"<URL to pull data from>\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let items = response . body . items ; // Adjust the items to fit the schema if required. return { result : items , } }, }, });","title":"Dynamic sync tables"},{"location":"samples/topic/dynamic-sync-table/#dynamic-sync-table-sample","text":"Most sync tables have schemas that can be statically defined. For example, if you're writing a sync of a user's Google Calendar events, the structure of an Event from the Google Calendar API is well-known and you can write a schema for what your table should contain. In certain cases, you may want to sync data whose structure is not known in advance and may depend on the user doing the sync. For example, Coda's Jira pack allows users to sync data from their Jira instance, but Jira lets users create arbitrary custom fields for their Issue objects. So the schema of the Issues sync table is not known in advance; it depends on the Jira account that the user is syncing from. Coda supports \"dynamic\" sync tables for cases like these. Instead of including a static schema in your sync table definition, you include a formula that returns a schema. This formula can use the fetcher to make authenticated http requests to your Pack's API so that you may retrieve any necessary info from that third-party service needed to construct an appropriate schema. To define a dynamic schema, use the makeDynamicSyncTable() wrapper function. You will provide a getSchema formula that returns a schema definition. You'll also provide some supporting formulas like getName , to return a name in the UI for the table, in case even the name of the entities being synced is dynamic. There are two subtle variants of dynamic sync tables. A sync table can be dynamic simply because the shape of the entities being synced vary based on who the current user is. For example, in the Jira example, Jira Issues are synced by hitting the same static Jira API url for Issues, but the schema of the issues returned will be different depending on the configuration of the Jira instance of the calling user. Alternatively, a sync table can be dynamic because the data source is specific to each instance of the table. If you were building a sync table to sync data from a Google Sheet, the data source would be the API url of a specific sheet. In this case, the sync table will be bound to a dynamicUrl that defines the data source. This url will be available to all of the formulas to implement the sync table in the sync context, as context.sync.dynamicUrl . To create a sync table that uses dynamic urls, you must implement the listDynamicUrls metadata formula in your dynamic sync table definition. Learn More","title":"Dynamic sync table sample"},{"location":"samples/topic/dynamic-sync-table/#template","text":"pack . addDynamicSyncTable ({ name : \"<User-visible name for the sync table>\" , getName : async function ( context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; // TODO: Fetch metdata about the datasource and return the name. return \"<Datasource Name>\" ; }, getSchema : async function ( context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; // TODO: Fetch metdata about the datasource and get the list of fields. let properties = { // TODO: Create a property for each field. }; let id = \"<Determine the field containing a unique ID>\" ; let primary = \"<Determine the field containing the display value>\" ; let featured = [ // TODO: Determine which fields to show in the table by default. ]; return coda . makeSchema ({ type : coda . ValueType . Array , items : coda.makeObjectSchema ({ type : coda . ValueType . Object , identity : { name : \"<User-visible name for the column containing the schema>\" , dynamicUrl : datasourceUrl , }, properties : properties , id : id , primary : primary , featured : featured , }), }); }, getDisplayUrl : async function ( context ) { return context . sync ! . dynamicUrl ! ; }, formula : { name : \"<Name of the sync formula, not show to the user>\" , description : \"<Help text for the sync formula, not show to the user>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], execute : async function ([ param ], context ) { let datasourceUrl = context . sync ! . dynamicUrl ! ; let url = \"<URL to pull data from>\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let items = response . body . items ; // Adjust the items to fit the schema if required. return { result : items , } }, }, });","title":"Template"},{"location":"samples/topic/fetcher/","text":"Fetcher samples \u00b6 Communicating with an API or external server is done through the Fetcher , a custom interface for making HTTP requests. The fetcher is made available through the context object passed in to formulas. The fetcher can only send requests to URLs that have have a domain name that's been registered using addNetworkDomain . The fetcher runs asynchronously, and is typically run within an async function that will await the result. Learn More Template (GET) \u00b6 let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"<The URL to fetch>\" , headers : { \"<HeaderName>\" : \"<HeaderValue>\" , // Add more headers as needed. }, }); let data = response . body ; Template (POST) \u00b6 let payload = { // Whatever JSON structure the API expects. }; let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"<The URL to send the request to>\" , headers : { \"Content-Type\" : \"application/json\" , // Add more headers as needed. }, body : JSON.stringify ( payload ), }); let data = response . body ; JSON Array (Bacon Ipsum) \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // When using the fetcher, this is the domain of the API that your pack makes // fetcher requests to. pack . addNetworkDomain ( \"baconipsum.com\" ); // This line adds a new formula to this Pack. pack . addFormula ({ name : \"BaconIpsum\" , description : \"Returns meat-themed lorem ipsum copy.\" , parameters : [], // No parameters required. resultType : coda.ValueType.String , // This function is declared async to that is can wait for the fetcher to // complete. The context parameter provides access to the fetcher. execute : async function ([], context ) { let url = \"https://baconipsum.com/api/?type=meat-and-filler\" ; // The fetcher's fetch method makes the request. The await keyword is used // to wait for the API's response before continuing on through the code. let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); // The API returns an array of strings, which is automatically parsed by // the fetcher into a JavaScript object. let paragraphs = response . body ; // Return the paragraphs separated by a blank line. return paragraphs . join ( \"\\n\\n\" ); }, });","title":"Fetcher"},{"location":"samples/topic/fetcher/#fetcher-samples","text":"Communicating with an API or external server is done through the Fetcher , a custom interface for making HTTP requests. The fetcher is made available through the context object passed in to formulas. The fetcher can only send requests to URLs that have have a domain name that's been registered using addNetworkDomain . The fetcher runs asynchronously, and is typically run within an async function that will await the result. Learn More","title":"Fetcher samples"},{"location":"samples/topic/fetcher/#template-get","text":"let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"<The URL to fetch>\" , headers : { \"<HeaderName>\" : \"<HeaderValue>\" , // Add more headers as needed. }, }); let data = response . body ;","title":"Template (GET)"},{"location":"samples/topic/fetcher/#template-post","text":"let payload = { // Whatever JSON structure the API expects. }; let response = await context . fetcher . fetch ({ method : \"POST\" , url : \"<The URL to send the request to>\" , headers : { \"Content-Type\" : \"application/json\" , // Add more headers as needed. }, body : JSON.stringify ( payload ), }); let data = response . body ;","title":"Template (POST)"},{"location":"samples/topic/fetcher/#json-array-bacon-ipsum","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // When using the fetcher, this is the domain of the API that your pack makes // fetcher requests to. pack . addNetworkDomain ( \"baconipsum.com\" ); // This line adds a new formula to this Pack. pack . addFormula ({ name : \"BaconIpsum\" , description : \"Returns meat-themed lorem ipsum copy.\" , parameters : [], // No parameters required. resultType : coda.ValueType.String , // This function is declared async to that is can wait for the fetcher to // complete. The context parameter provides access to the fetcher. execute : async function ([], context ) { let url = \"https://baconipsum.com/api/?type=meat-and-filler\" ; // The fetcher's fetch method makes the request. The await keyword is used // to wait for the API's response before continuing on through the code. let response = await context . fetcher . fetch ({ method : \"GET\" , url : url }); // The API returns an array of strings, which is automatically parsed by // the fetcher into a JavaScript object. let paragraphs = response . body ; // Return the paragraphs separated by a blank line. return paragraphs . join ( \"\\n\\n\" ); }, });","title":"JSON Array (Bacon Ipsum)"},{"location":"samples/topic/formula/","text":"Formula samples \u00b6 A formula is a JavaScript function that is exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any built-in formula. Formulas take basic types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types. Learn More Template \u00b6 The basic structure of a formula. This sample takes in a single string parameter and returns a string result. pack . addFormula ({ name : \"<User-visible name of formula>\" , description : \"<Help text for the formula>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], resultType : coda.ValueType.String , execute : async function ([ param ], context ) { return \"Hello \" + param ; }, }); Image result \u00b6 A formula that returns an image. This sample gets a random cat image with an optional text overlay or filter applied. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"filter\" , description : \"A filter to apply to the image.\" , autocomplete : [ \"blur\" , \"mono\" , \"sepia\" , \"negative\" , \"paint\" , \"pixel\" ], optional : true , }), ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text , filter ], context ) { let url = \"https://cataas.com/cat\" ; if ( text ) { url += \"/says/\" + encodeURIComponent ( text ); } url = coda . withQueryParams ( url , { filter : filter , json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" ); Rich data result \u00b6 A formula that returns rich data (a schema). This sample gets information about a task in the Todoist application. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // A schema defining the rich metadata to be returned about each task. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); // Formula that looks up rich metadata about a task given it's URL. pack . addFormula ({ name : \"GetTaskById\" , description : \"Gets a Todoist task by ID\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ taskId ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); let task = response . body ; return { name : task.content , description : task.description , url : task.url , taskId : task.id , }; }, }); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Formulas"},{"location":"samples/topic/formula/#formula-samples","text":"A formula is a JavaScript function that is exposed as a Coda formula, that you can use anywhere in a Coda doc that you can use any built-in formula. Formulas take basic types as input, like strings, numbers, dates, booleans, and arrays of these types, and return any of these types or objects whose properties are any of these types. Learn More","title":"Formula samples"},{"location":"samples/topic/formula/#template","text":"The basic structure of a formula. This sample takes in a single string parameter and returns a string result. pack . addFormula ({ name : \"<User-visible name of formula>\" , description : \"<Help text for the formula>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], resultType : coda.ValueType.String , execute : async function ([ param ], context ) { return \"Hello \" + param ; }, });","title":"Template"},{"location":"samples/topic/formula/#image-result","text":"A formula that returns an image. This sample gets a random cat image with an optional text overlay or filter applied. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formula that fetches a random cat image, with various options. pack . addFormula ({ name : \"CatImage\" , description : \"Gets a random cat image.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"Text to display over the image.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"filter\" , description : \"A filter to apply to the image.\" , autocomplete : [ \"blur\" , \"mono\" , \"sepia\" , \"negative\" , \"paint\" , \"pixel\" ], optional : true , }), ], resultType : coda.ValueType.String , codaType : coda.ValueHintType.ImageReference , execute : async function ([ text , filter ], context ) { let url = \"https://cataas.com/cat\" ; if ( text ) { url += \"/says/\" + encodeURIComponent ( text ); } url = coda . withQueryParams ( url , { filter : filter , json : true , }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , cacheTtlSecs : 0 , // Don't cache the result, so we can get a fresh cat. }); return \"https://cataas.com\" + response . body . url ; }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" );","title":"Image result"},{"location":"samples/topic/formula/#rich-data-result","text":"A formula that returns rich data (a schema). This sample gets information about a task in the Todoist application. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // A schema defining the rich metadata to be returned about each task. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , identity : { name : \"Task\" , }, }); // Formula that looks up rich metadata about a task given it's URL. pack . addFormula ({ name : \"GetTaskById\" , description : \"Gets a Todoist task by ID\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"taskId\" , description : \"The ID of the task\" , }), ], resultType : coda.ValueType.Object , schema : TaskSchema , execute : async function ([ taskId ], context ) { let response = await context . fetcher . fetch ({ url : \"https://api.todoist.com/rest/v1/tasks/\" + taskId , method : \"GET\" , }); let task = response . body ; return { name : task.content , description : task.description , url : task.url , taskId : task.id , }; }, }); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Rich data result"},{"location":"samples/topic/parameter/","text":"Parameter samples \u00b6 Coda formulas, actions, and sync tables receive take in user input via parameters. They are required by default, but can by made optional. Variable argument (vararg) parameters can be used to allow for parameters to be set more than once. Learn More Template \u00b6 The basic structure of a parameter. This sample is for a string parameter. coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }); No parameters \u00b6 A formula without any parameters. This sample returns the name of the current day of the week. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formula that gets the current weekday, for example \"Monday\". pack . addFormula ({ name : \"CurrentWeekday\" , description : \"Get the current day of the week.\" , parameters : [], resultType : coda.ValueType.String , execute : async function ([], context ) { let now = new Date (); let formatter = Intl . DateTimeFormat ( \"us-US\" , { weekday : \"long\" }); return formatter . format ( now ); }, }); Optional parameters \u00b6 A formula with some required and some optional parameters. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\". pack . addFormula ({ name : \"Scream\" , description : \"Make text uppercase and add exclamation points.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"The text to scream.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"volume\" , description : \"The number of exclamation points to add.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"character\" , description : \"The character to repeat.\" , optional : true , }), ], resultType : coda.ValueType.String , execute : async function ([ text , volume = 3 , character = \"!\" ], context ) { return text . toUpperCase () + character . repeat ( volume ); }, }); Variable argument parameters \u00b6 A formula that accepts a variable number of arguments. This sample draws a simple diagram using text, with an unknown number of arrow labels and steps. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Takes an unknown number of steps and labels and outputs a simple diagram. // Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\") // Result: Idea --Experiment--> Prototype --Refine--> Product pack . addFormula ({ name : \"Steps\" , description : \"Draws a simple step diagram using text.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"start\" , description : \"The starting step.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"label\" , description : \"The label for the arrow.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"step\" , description : \"The next step.\" , }), ], resultType : coda.ValueType.String , execute : async function ([ start , ... varargs ], context ) { let result = start ; while ( varargs . length > 0 ) { let label ; let step ; // Pull the first set of varargs off the list, and leave the rest. [ label , step , ... varargs ] = varargs ; result += ` -- ${ label } --> ${ step } ` ; } return result ; }, });","title":"Parameters"},{"location":"samples/topic/parameter/#parameter-samples","text":"Coda formulas, actions, and sync tables receive take in user input via parameters. They are required by default, but can by made optional. Variable argument (vararg) parameters can be used to allow for parameters to be set more than once. Learn More","title":"Parameter samples"},{"location":"samples/topic/parameter/#template","text":"The basic structure of a parameter. This sample is for a string parameter. coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , });","title":"Template"},{"location":"samples/topic/parameter/#no-parameters","text":"A formula without any parameters. This sample returns the name of the current day of the week. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formula that gets the current weekday, for example \"Monday\". pack . addFormula ({ name : \"CurrentWeekday\" , description : \"Get the current day of the week.\" , parameters : [], resultType : coda.ValueType.String , execute : async function ([], context ) { let now = new Date (); let formatter = Intl . DateTimeFormat ( \"us-US\" , { weekday : \"long\" }); return formatter . format ( now ); }, });","title":"No parameters"},{"location":"samples/topic/parameter/#optional-parameters","text":"A formula with some required and some optional parameters. This sample formats text to look like screaming, with a optional parameters to override how many exclamation points to use and an alternate character to use. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Formats text to look like screaming. For example, \"Hello\" => \"HELLO!!!\". pack . addFormula ({ name : \"Scream\" , description : \"Make text uppercase and add exclamation points.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"text\" , description : \"The text to scream.\" , }), coda . makeParameter ({ type : coda . ParameterType . Number , name : \"volume\" , description : \"The number of exclamation points to add.\" , optional : true , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"character\" , description : \"The character to repeat.\" , optional : true , }), ], resultType : coda.ValueType.String , execute : async function ([ text , volume = 3 , character = \"!\" ], context ) { return text . toUpperCase () + character . repeat ( volume ); }, });","title":"Optional parameters"},{"location":"samples/topic/parameter/#variable-argument-parameters","text":"A formula that accepts a variable number of arguments. This sample draws a simple diagram using text, with an unknown number of arrow labels and steps. import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Takes an unknown number of steps and labels and outputs a simple diagram. // Example: Steps(\"Idea\", \"Experiment\", \"Prototype\", \"Refine\", \"Product\") // Result: Idea --Experiment--> Prototype --Refine--> Product pack . addFormula ({ name : \"Steps\" , description : \"Draws a simple step diagram using text.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"start\" , description : \"The starting step.\" , }), ], varargParameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"label\" , description : \"The label for the arrow.\" , }), coda . makeParameter ({ type : coda . ParameterType . String , name : \"step\" , description : \"The next step.\" , }), ], resultType : coda.ValueType.String , execute : async function ([ start , ... varargs ], context ) { let result = start ; while ( varargs . length > 0 ) { let label ; let step ; // Pull the first set of varargs off the list, and leave the rest. [ label , step , ... varargs ] = varargs ; result += ` -- ${ label } --> ${ step } ` ; } return result ; }, });","title":"Variable argument parameters"},{"location":"samples/topic/sync-table/","text":"Sync table samples \u00b6 A sync table is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a formula that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects. Learn More Template \u00b6 const MySchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { property1 : { type : coda . ValueType . Number }, property2 : { type : coda . ValueType . String }, // Add more properties here. }, id : \"property1\" , // Which property above is a unique ID. primary : \"property2\" , // Which property above to display by default. identity : { name : \"<User-visible name for the column containing the schema>\" , }, }); pack . addSyncTable ({ name : \"<User-visible name for the sync table>\" , identityName : \"<User-visible name for the column containing the schema>\" , schema : MySchema , formula : { name : \"<Name of the sync formula, not show to the user>\" , description : \"<Help text for the sync formula, not show to the user>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], execute : async function ([ param ], context ) { let url = \"<URL to pull data from>\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let items = response . body . items ; // Adjust the items to fit the schema if required. return { result : items , } }, }, }); Cats \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Schema for a Cat image. const CatSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { image : { type : coda . ValueType . String , codaType : coda.ValueHintType.ImageReference , }, tags : { type : coda . ValueType . Array , items : { type : coda . ValueType . String }, }, created : { type : coda . ValueType . String , codaType : coda.ValueHintType.DateTime , }, id : { type : coda . ValueType . String }, }, primary : \"image\" , id : \"id\" , featured : [ \"tags\" ], identity : { name : \"Cat\" , }, }); // Sync table that retrieves all cat images, optionally filtered by tags. pack . addSyncTable ({ name : \"Cats\" , identityName : \"Cat\" , schema : CatSchema , connectionRequirement : coda.ConnectionRequirement.None , formula : { name : \"SyncCats\" , description : \"Syncs the cats.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"tag\" , description : \"Only cats with this tag will be selected.\" , optional : true , // Pull the list of tags to use for autocomplete from the API. autocomplete : async function ( context , search ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/api/tags\" , }); let tags = response . body ; // Convert the tags into a list of autocomplete options. return coda . simpleAutocomplete ( search , tags ); }, }), ], execute : async function ([ tag ], context ) { let url = coda . withQueryParams ( \"https://cataas.com/api/cats\" , { tags : tag }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let cats = response . body ; let result : any = []; for ( let cat of cats ) { result . push ({ image : \"https://cataas.com/cat/\" + cat . id , tags : cat.tags , created : cat.created_at , id : cat.id , }); } return { result : result , }; }, }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" ); Todoist \u00b6 import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // A schema defining the data in the sync table. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , featured : [ \"description\" , \"url\" ], identity : { name : \"Task\" , }, }); pack . addSyncTable ({ name : \"Tasks\" , schema : TaskSchema , identityName : \"Task\" , formula : { name : \"SyncTasks\" , description : \"Sync tasks\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/tasks\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let task of response . body ) { results . push ({ name : task.content , description : task.description , url : task.url , taskId : task.id , }); } return { result : results , }; }, }, }); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Sync tables"},{"location":"samples/topic/sync-table/#sync-table-samples","text":"A sync table is how to bring structured data from a third-party into Coda. A sync table is a table that you can add to a Coda doc that gets its rows from a third-party data source, that can be refreshed regularly to pull in new or updated data. A sync table is powered by a formula that takes parameters that represent sync options and returns an array of objects representing row data. A sync table also includes a schema describing the structure of the returned objects. Learn More","title":"Sync table samples"},{"location":"samples/topic/sync-table/#template","text":"const MySchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { property1 : { type : coda . ValueType . Number }, property2 : { type : coda . ValueType . String }, // Add more properties here. }, id : \"property1\" , // Which property above is a unique ID. primary : \"property2\" , // Which property above to display by default. identity : { name : \"<User-visible name for the column containing the schema>\" , }, }); pack . addSyncTable ({ name : \"<User-visible name for the sync table>\" , identityName : \"<User-visible name for the column containing the schema>\" , schema : MySchema , formula : { name : \"<Name of the sync formula, not show to the user>\" , description : \"<Help text for the sync formula, not show to the user>\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"<User-visible name of parameter>\" , description : \"<Help text for the parameter>\" , }), // Add more parameters here and in the array below. ], execute : async function ([ param ], context ) { let url = \"<URL to pull data from>\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let items = response . body . items ; // Adjust the items to fit the schema if required. return { result : items , } }, }, });","title":"Template"},{"location":"samples/topic/sync-table/#cats","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // Schema for a Cat image. const CatSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { image : { type : coda . ValueType . String , codaType : coda.ValueHintType.ImageReference , }, tags : { type : coda . ValueType . Array , items : { type : coda . ValueType . String }, }, created : { type : coda . ValueType . String , codaType : coda.ValueHintType.DateTime , }, id : { type : coda . ValueType . String }, }, primary : \"image\" , id : \"id\" , featured : [ \"tags\" ], identity : { name : \"Cat\" , }, }); // Sync table that retrieves all cat images, optionally filtered by tags. pack . addSyncTable ({ name : \"Cats\" , identityName : \"Cat\" , schema : CatSchema , connectionRequirement : coda.ConnectionRequirement.None , formula : { name : \"SyncCats\" , description : \"Syncs the cats.\" , parameters : [ coda . makeParameter ({ type : coda . ParameterType . String , name : \"tag\" , description : \"Only cats with this tag will be selected.\" , optional : true , // Pull the list of tags to use for autocomplete from the API. autocomplete : async function ( context , search ) { let response = await context . fetcher . fetch ({ method : \"GET\" , url : \"https://cataas.com/api/tags\" , }); let tags = response . body ; // Convert the tags into a list of autocomplete options. return coda . simpleAutocomplete ( search , tags ); }, }), ], execute : async function ([ tag ], context ) { let url = coda . withQueryParams ( \"https://cataas.com/api/cats\" , { tags : tag }); let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let cats = response . body ; let result : any = []; for ( let cat of cats ) { result . push ({ image : \"https://cataas.com/cat/\" + cat . id , tags : cat.tags , created : cat.created_at , id : cat.id , }); } return { result : result , }; }, }, }); // Allow the pack to make requests to Cat-as-a-service API. pack . addNetworkDomain ( \"cataas.com\" );","title":"Cats"},{"location":"samples/topic/sync-table/#todoist","text":"import * as coda from \"@codahq/packs-sdk\" ; export const pack = coda . newPack (); // A schema defining the data in the sync table. const TaskSchema = coda . makeObjectSchema ({ type : coda . ValueType . Object , properties : { name : { description : \"The name of the task.\" , type : coda . ValueType . String , required : true , }, description : { description : \"A detailed description of the task.\" , type : coda . ValueType . String , }, url : { description : \"A link to the task in the Todoist app.\" , type : coda . ValueType . String , codaType : coda.ValueHintType.Url }, taskId : { description : \"The ID of the task.\" , type : coda . ValueType . Number , required : true , }, }, primary : \"name\" , id : \"taskId\" , featured : [ \"description\" , \"url\" ], identity : { name : \"Task\" , }, }); pack . addSyncTable ({ name : \"Tasks\" , schema : TaskSchema , identityName : \"Task\" , formula : { name : \"SyncTasks\" , description : \"Sync tasks\" , parameters : [], execute : async function ([], context ) { let url = \"https://api.todoist.com/rest/v1/tasks\" ; let response = await context . fetcher . fetch ({ method : \"GET\" , url : url , }); let results : any [] = []; for ( let task of response . body ) { results . push ({ name : task.content , description : task.description , url : task.url , taskId : task.id , }); } return { result : results , }; }, }, }); // Allow the pack to make requests to Todoist. pack . addNetworkDomain ( \"todoist.com\" ); // Setup authentication using a Todoist API token. pack . setUserAuthentication ({ type : coda . AuthenticationType . HeaderBearerToken , instructionsUrl : \"https://todoist.com/app/settings/integrations\" , });","title":"Todoist"}]}